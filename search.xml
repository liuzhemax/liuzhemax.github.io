<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Alertmanager告警利器</title>
    <url>/2021/09/06/alertmanager%E5%91%8A%E8%AD%A6%E5%88%A9%E5%99%A8/</url>
    <content><![CDATA[<p>安装包下载</p>
<p>地址1：<a href="https://prometheus.io/download/">https://prometheus.io/download/</a></p>
<p>地址2：<a href="https://github.com/prometheus/alertmanager/releases">https://github.com/prometheus/alertmanager/releases</a></p>
<p>使用步骤：</p>
<ol>
<li>
<p>部署Alertmanager</p>
</li>
<li>
<p>配置告警接收人</p>
</li>
<li>
<p>配置Prometheus与Alertmanager通信</p>
</li>
<li>
<p>在Prometheus中创建告警规则</p>
</li>
</ol>
<p>部署Alertmanager （端口9093）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解压安装</span></span><br><span class="line">tar -zxf alertmanager-0.21.0.linux-amd64.tar.gz </span><br><span class="line"><span class="built_in">mv</span> alertmanager-0.21.0.linux-amd64 /opt/monitor/alertmanager</span><br><span class="line"><span class="comment">#配置为系统管理服务</span></span><br><span class="line">vim /usr/lib/systemd/system/alertmanager.service </span><br><span class="line">[Unit]</span><br><span class="line">Description=alertmanager</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/opt/monitor/alertmanager/alertmanager --config.file=/opt/monitor/alertmanager/alertmanager.yml</span><br><span class="line">ExecReload=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="comment">#加载服务配置启动，开机启动</span></span><br><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl start alertmanager</span><br><span class="line">systemctl <span class="built_in">enable</span> alertmanager</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置Prometheus与Alertmanager通信并配置告警接收人</p>
<p><img src="/images/90EF57F51D214435A784D48C34F5D9B5clipboard.png" alt></p>
<p><img src="/images/8FBC40E33B344982904DF05083E4336Dclipboard.png" alt></p>
<p>alertmanager工作目录下配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /opt/monitor/alertmanager/alertmanager.yml</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line"> resolve_timeout: 5m</span><br><span class="line"><span class="comment"># 邮箱服务器</span></span><br><span class="line"> smtp_smarthost: <span class="string">&#x27;smtp.sina.com:25&#x27;</span></span><br><span class="line"> smtp_from: <span class="string">&#x27;lz13753705474@sina.com&#x27;</span></span><br><span class="line"> smtp_auth_username: <span class="string">&#x27;lz13753705474@sina.com&#x27;</span></span><br><span class="line"> smtp_auth_password: <span class="string">&#x27;0b06987008049d86&#x27;</span></span><br><span class="line"> smtp_require_tls: <span class="literal">false</span></span><br><span class="line"> <span class="comment"># 配置路由树</span></span><br><span class="line">route:</span><br><span class="line"> group_by: [<span class="string">&#x27;alertname&#x27;</span>] <span class="comment"># 根据告警规则名称进行分组</span></span><br><span class="line"> group_wait: 10s <span class="comment"># 分组内第一个告警等待时间，10s内如有第二个告警会合并一个告警</span></span><br><span class="line"> group_interval: 10s <span class="comment"># 发送新告警间隔时间</span></span><br><span class="line"> repeat_interval: 10m <span class="comment"># 重复告警间隔发送时间,建议根据情况而定，一般10分钟左右</span></span><br><span class="line"> receiver: <span class="string">&#x27;mail&#x27;</span></span><br><span class="line"> <span class="comment"># 接收人</span></span><br><span class="line">receivers:</span><br><span class="line">- name: <span class="string">&#x27;mail&#x27;</span></span><br><span class="line">  email_configs:</span><br><span class="line">  - to: <span class="string">&#x27;1437626743@qq.com&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置完成后，重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start alertmanager</span><br></pre></td></tr></table></figure>
<p>在Prometheus中创建告警规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /opt/monitor/prometheus/prometheus.yml</span><br></pre></td></tr></table></figure>
<p>启用告警配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">       - 127.0.0.1:9093</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个目录就是一个相对路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule_files:</span><br><span class="line">   - <span class="string">&quot;rules/*.yml&quot;</span></span><br></pre></td></tr></table></figure>
<p>创建告警规则目录rules以及创建告警规则文件node.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt/monitor/prometheus/rules</span><br><span class="line"><span class="built_in">cd</span> /opt/monitor/prometheus/rules</span><br><span class="line">vim node.yml</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">groups</span>:</span><br><span class="line">- name: example <span class="comment">#告警规则组名称</span></span><br><span class="line">  rules:</span><br><span class="line">  <span class="comment"># 任何实例5分钟内无法访问发出告警</span></span><br><span class="line">  - alert: InstanceDown <span class="comment"># 告警规则名称</span></span><br><span class="line">    <span class="built_in">expr</span>: up == 0 <span class="comment"># 基于PromQL的触发条件</span></span><br><span class="line">    <span class="keyword">for</span>: 1m <span class="comment"># 等待评估时间</span></span><br><span class="line">    labels: <span class="comment"># 自定义标签</span></span><br><span class="line">      severity: page</span><br><span class="line">    annotations: <span class="comment"># 指定附加信息</span></span><br><span class="line">      summary: <span class="string">&quot; &#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; 停止工作&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125;：job &#123;&#123; <span class="variable">$labels</span>.job &#125;&#125; 已经停止5分钟以</span></span><br><span class="line"><span class="string">上.&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置完成后，重新加载服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;prometheus pid&gt;</span><br></pre></td></tr></table></figure>
<p>查看告警规则是否生效</p>
<p><img src="/images/D44A576DD1354F15B5CD6D254F34416Eclipboard.png" alt></p>
<p>每个被监控端都有up这个标签，up为1代表服务正常，如果等于0代表服务不正常。所以可以通过up获取所有的被监控端状态</p>
<p><img src="/images/6F7F8346B1E34FF5862B83E3A8399B83clipboard.png" alt></p>
<p>告警状态</p>
<p>• Inactive：这里什么都没有发生。</p>
<p>• Pending：已触发阈值，但未满足告警持续时间</p>
<p>• Firing：已触发阈值且满足告警持续时间。警报发送给接受者。</p>
<p><img src="/images/97838205C8D743CAA1694328225E987Bclipboard.png" alt></p>
<p>现在模拟关闭一台被监控端的node_exporter服务</p>
<p><img src="/images/8B69D93EDCCC41D092BD54FF5A2671F2clipboard.png" alt></p>
<p>被监控端一个主机down了，查看告警 ，可以看到告警处于pending的状态，进入for循环评估当中</p>
<p><img src="/images/E36628FCE54445DA8C827FC2298754E0clipboard.png" alt></p>
<p>在评估期内满足条件告警状态触发了，此时状态为Firing</p>
<p>这里可以在告警规则里面定义一些标签，方便后期的处理，主要是在altermanager里面体现</p>
<p><img src="/images/919BC77515CB4CBB9E008DD1EC82861Bclipboard.png" alt></p>
<p>最后邮件查看</p>
<p><img src="/images/6933258A3B924C248802C4E56C9DC70Cclipboard.png" alt></p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Alertmanager告警收敛</title>
    <url>/2021/09/06/alertmanager%E5%91%8A%E8%AD%A6%E6%94%B6%E6%95%9B/</url>
    <content><![CDATA[<p>分组（group）：将类似性质的警报分类为单个通知</p>
<p>抑制（Inhibition）：当警报发出后，停止重复发送由此警报引发的其他警报</p>
<p>静默（Silences）：是一种简单的特定时间静音提醒的机制</p>
<p><img src="/images/4C85A4B8FE0F4256A2E1CAAFCF27322Bclipboard.png" alt></p>
<h1>抑制规则</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      level: <span class="string">&#x27;high&#x27;</span>           <span class="comment">#指定告警级别</span></span><br><span class="line">    target_match:</span><br><span class="line">      level: <span class="string">&#x27;warning&#x27;</span>        <span class="comment">#指定抑制告警级别</span></span><br><span class="line">    equal: [<span class="string">&#x27;alertname&#x27;</span>, <span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;instance&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>场景： 一台服务器上有nginx服务等等其他的服务，某一天服务器挂掉了，那么如果不做抑制的话，就会发送多个告警邮件，这显然不是我们想要的，这个时候，我们可以通过设定级别标签的方式，比如设定服务器挂掉就是一个高级别，而上面的其他服务设定为警告级别，这样我们就可以使用抑制做告警收敛，也就是只发送一个服务器挂掉的警告，其他的服务的警告就被抑制了。</p>
<p>抑制（Inhibition）的一个流程：</p>
<p>1.当alertmanger收到一个告警，告警内容是(alertname=dwon level=high instnace=192.168.0.12:9100 job=linux)</p>
<p>2.抑制处理，会先判断告警中带不带level: 'high’这个标签</p>
<p>3.如果带的话，就抑制level：'warning’这个标签的告警</p>
<p>5.抑制的前提是两条告警中都必须满足相同的标签，此时来了第二条警告是(alertname=dwon level=waring instnace=192.168.0.12:9100)</p>
<p>6.可以看到第二条警告带有level=waring这个标签并且满足相同的标签</p>
<p>7.那么就不发送由这条高级别的警告引发的其他服务的警告</p>
<p>静默配置</p>
<p>192.168.0.12这台服务器在某个时间段要维护，可以使用静默的方式，通过标签的方式去匹配</p>
<p><img src="/images/AF50FEA4CC2947CAA2E8C3CC88E7229Fclipboard.png" alt></p>
<p><img src="/images/0415451FCC724867A0F2E7EA535AD1BDclipboard.png" alt></p>
<p><img src="/images/53B856BEAEB0462C8FC2BDA5F2DD6344clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>css样式语言</title>
    <url>/2024/03/21/css%E6%A0%B7%E5%BC%8F%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h2 id="CSS介绍">CSS介绍</h2>
<p>CSS：是一种用于修饰网页的文本样式语言，还可以配合Javascript脚本语言动态对网页各元素操作。</p>
<h2 id="使用方法">使用方法</h2>
<p>1、内联方式（行内样式）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>在HTML中如何使用css样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、内部方式（内嵌样式），在head标签中使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3、外部导入方式（推荐），在head标签中使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="选择器">选择器</h2>
<p>选择器：需要改变样式的HTML元素（标签）</p>
<p>常见选择器：标签选择器、类选择器、ID选择器、派生选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">格式： 选择器&#123;属性:值;属性:值;属性:值;....&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择器：元素">选择器：元素</h3>
<p>元素选择器：使用html标签作为选择器，为指定标签设置样式。</p>
<p>示例1：h1元素设置样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">    color: red; </span><br><span class="line">    font-size: 14;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2：多个元素设置样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">h1,h2,h3,h4,h5,h6 &#123;</span><br><span class="line">    color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例3：子元素会继承最高级元素所有属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    color: #000;</span><br><span class="line">    font-family: Verdana, serif; /*字体*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择器：ID">选择器：ID</h3>
<p>id选择器：使用“id”作为选择器，为指定id设置样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">使用格式：#id名&#123;样式...&#125;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>
<p>每个id名称只能在HTML文档中出现一次</p>
</li>
<li>
<p>在实际开发中，id一般预留JavaScript使用</p>
</li>
</ul>
<p>第一步：给标签指定id</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;t&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二步：针对id设置样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#t &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择器：类">选择器：类</h3>
<p>类选择器：使用“类名”作为选择器，为指定类设置样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">使用格式：.类名&#123;样式...&#125;</span><br></pre></td></tr></table></figure>
<p>第一步：给标签指定类</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;c&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二步：针对类设置样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.c &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择器：派生">选择器：派生</h3>
<p>派生选择器：依据元素在其位置的上下文关系来定义样式。</p>
<p><img src="/images/B248D644F61A4E30BA3F58B86F28B912clipboard.png" alt></p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.c</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一号标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="常用属性">常用属性</h2>
<h3 id="CSS常用属性：内边距和外边距">CSS常用属性：内边距和外边距</h3>
<p><img src="/images/D7836BEEB28C497480820C0F9892A152clipboard.png" alt></p>
<p>padding（内边距）：钻戒到盒子内边框的距离<br>
margin（外边距）：钻戒盒子距离桌子边缘的距离<br>
border：钻戒盒子边框宽度</p>
<p><img src="/images/B26BF52C9205438E86C87D41F1E8AAA7clipboard.png" alt></p>
<h3 id="CSS常用属性：字体-font">CSS常用属性：字体 font-*</h3>
<p><img src="/images/2FED46630261480ABACC725E35E38A5Dclipboard.png" alt></p>
<h3 id="CSS常用属性：文本">CSS常用属性：文本</h3>
<p><img src="/images/33121A16EB844B829063B18A84874222clipboard.png" alt></p>
<h3 id="CSS常用属性：边框-border">CSS常用属性：边框 border-*</h3>
<p><img src="/images/681779EA4FBC4C9FB4A7543E0AF83D8Fclipboard.png" alt></p>
<h3 id="CSS常用属性：背景-background">CSS常用属性：背景 background-*</h3>
<p><img src="/images/0755F73AB88D46C4B936D06FD2D13B4Fclipboard.png" alt></p>
<h3 id="CSS常用属性：Flex弹性布局">CSS常用属性：Flex弹性布局</h3>
<p>在之前要控制HTML元素的布局，会用到padding、margin、postion、float等方 法，经过反反复复调试才能实现效果。 自从Flex弹性布局出现，一切似乎豁然开朗！</p>
<p>启用Flex布局，只需要在外部元素设置display: flex属性。</p>
<p>Flex布局有一个隐式的坐标空间，水平方向有一条主轴，垂直方向有一条交叉轴：</p>
<p><img src="/images/DF9E959D178B4E9CAE71395C0A0B4611clipboard.png" alt></p>
<p>改变主轴（横向）的布局：</p>
<p>justify-content:</p>
<ul>
<li>
<p>flex-end：右对齐</p>
</li>
<li>
<p>center：居中对齐</p>
</li>
<li>
<p>space-evenly：平分空间</p>
</li>
<li>
<p>space-between：两端对齐</p>
</li>
</ul>
<p>改变交叉轴（竖向）的布局：</p>
<p>align-items</p>
<ul>
<li>
<p>flex-end：靠下对齐</p>
</li>
<li>
<p>center：居中对齐</p>
</li>
</ul>
<p>调整空间占比（子元素宽度）：</p>
<p>例如第一个元素三分之一，第二个元素占三分之二，第三个元素占三 分之一：flex:1;flex2;flex1</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>django-apscheduler基本使用</title>
    <url>/2024/09/22/django-apscheduler%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="基本介绍">基本介绍</h2>
<p>django-apscheduler支持三种调度任务：固定时间间隔，固定时间点（日期），Crontab 命令。同时，它还支持异步执行、后台执行调度任务 配置简单、功能齐全、使用灵活、支持windows和linux，适合中小型项目。</p>
<p>django-apscheduler中相关的概念和python的定时任务框架apscheduler中的概念是一样的。</p>
<ul>
<li>可以独立运行，也可以放在程序（如Django、Flask）中。</li>
<li>灵活，可以在程序开始前开启定时任务，也可以执行到某个任务时，立即可开启定时任务。</li>
<li>如果依赖程序的话，会占用程序资源。</li>
</ul>
<p><strong>基础组件：</strong><br>
APScheduler 有四种组件，分别是：调度器(scheduler)，作业存储(job store)，触发器(trigger)，执行器(executor)。</p>
<ul>
<li>schedulers（调度器）<br>
它是任务调度器，属于控制器角色。它配置作业存储器和执行器可以在调度器中完成，例如添加、修改和移除作业。</li>
<li>triggers（触发器）<br>
描述调度任务被触发的条件。不过触发器完全是无状态的。</li>
<li>job stores（作业存储器）<br>
任务持久化仓库，默认保存任务在内存中，也可将任务保存都各种数据库中。</li>
<li>executors（执行器）<br>
负责处理作业的运行，它们通常通过在作业中提交指定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。</li>
</ul>
<p><strong>schedulers（调度器）:</strong><br>
它提供 7 种调度器，能够满足我们各种场景的需要。例如：后台执行某个操作，异步执行操作等。调度器分别是：</p>
<ul>
<li>BlockingScheduler : 调度器在当前进程的主线程中运行，也就是会阻塞当前线程。</li>
<li>BackgroundScheduler : 调度器在后台线程中运行，不会阻塞当前线程。（Django框架使用）</li>
<li>AsyncIOScheduler : 结合 asyncio 模块（一个异步框架）一起使用。</li>
<li>GeventScheduler : 程序中使用 gevent（高性能的Python并发框架）作为IO模型，和 - GeventExecutor 配合使用。</li>
<li>TornadoScheduler : 程序中使用 Tornado（一个web框架）的IO模型，用 ioloop.add_timeout 完成定时唤醒。</li>
<li>TwistedScheduler : 配合 TwistedExecutor，用 reactor.callLater 完成定时唤醒。scrapy爬虫框</li>
<li>QtScheduler : 你的应用是一个 Qt 应用，需使用QTimer完成定时唤醒。</li>
</ul>
<p><strong>triggers（触发器）:</strong></p>
<ul>
<li>date 触发器 作业任务只会执行一次。它表示特定的时间点触发。它的参数如下：</li>
</ul>
<p><img src="/images/image-20240922203229220.png" alt></p>
<ul>
<li>interval 触发器 固定时间间隔触发。interval 间隔调度，参数如下：</li>
</ul>
<p><img src="/images/image-20240922203326704.png" alt></p>
<ul>
<li>cron 触发器 在特定时间周期性地触发，和Linux crontab格式兼容。</li>
</ul>
<p><img src="/images/image-20240922203414440.png" alt></p>
<h2 id="安装插件">安装插件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install django-apscheduler</span><br><span class="line">或者</span><br><span class="line">pip install apscheduler</span><br></pre></td></tr></table></figure>
<h2 id="使用插件">使用插件</h2>
<p>修改settings.py增加以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django_apscheduler&#x27;</span>,     <span class="comment"># 新加入的定时任务插件django-apscheduler</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="迁移数据库">迁移数据库</h2>
<p>因为django-apscheduler会创建表来存储定时任务的一些信息，所以将app加入之后需要迁移数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>django_apscheduler_djangojob—用于存储任务的表格</p>
<p><img src="/images/image-20240922194352658.png" alt></p>
<p>django_apscheduler_djangojobexecution—用于存储任务执行状态的表格</p>
<p><img src="/images/image-20240922194313413.png" alt></p>
<ul>
<li>status: 执行状态</li>
<li>duration: 执行了多长时间</li>
<li>exception: 是否出现了什么异常</li>
</ul>
<p>这两个表用来管理你所需要的定时任务，然后就开始在任意view.py下写你需要实现的任务。</p>
<h2 id="创建任务">创建任务</h2>
<h3 id="装饰器">装饰器</h3>
<p>在任意view.py中实现代码</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.background <span class="keyword">import</span> BackgroundScheduler</span><br><span class="line"><span class="keyword">from</span> django_apscheduler.jobstores <span class="keyword">import</span> DjangoJobStore, register_job, register_events</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;django-apscheduler&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 实例化调度器</span></span><br><span class="line">scheduler = BackgroundScheduler()</span><br><span class="line"><span class="comment"># 调度器使用DjangoJobStore()</span></span><br><span class="line">scheduler.add_jobstore(DjangoJobStore(), <span class="string">&quot;default&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加任务</span></span><br><span class="line"><span class="comment"># 每隔5s执行这个任务</span></span><br><span class="line"><span class="meta">@register_job(<span class="params">scheduler,<span class="string">&quot;interval&quot;</span>, seconds=<span class="number">5</span>,args=[<span class="string">&#x27;测试&#x27;</span>],<span class="built_in">id</span>=<span class="string">&#x27;job1&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">job1</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="comment"># 具体要执行的代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s 任务运行成功！%s&#x27;</span> %(name,time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控任务——注册定时任务</span></span><br><span class="line">register_events(scheduler)</span><br><span class="line"><span class="comment"># 调度器开始运行</span></span><br><span class="line">scheduler.start()</span><br><span class="line"><span class="comment">#停止APScheduler运行（如果报错，调度器就立即停止执行）</span></span><br><span class="line"><span class="comment">#scheduler.shutdown()</span></span><br></pre></td></tr></table></figure>
<p>django服务启动后，这个任务会被存储在django_apscheduler_djangojob表中，并按照设置定时执行。</p>
<p>@register_job装饰器参数说明：</p>
<ol>
<li>
<p>scheduler: 指定调度器</p>
</li>
<li>
<p>trigger: 任务执行的方式，共有三种： date、interval、cron。<br>
‘date’ + ‘run_date’ 的参数组合, 能实现单次任务。<br>
例子： 2019-07-07 22:49:00 执行任务<br>
@register_job(scheduler, ‘date’, id=‘test’, run_date=‘2019-07-07 22:49:00’)</p>
<p>‘interval’ + ‘hours’ + ‘minutes’’'+ … 的参数组合，能实现间隔性任务。<br>
例子：每隔3个半小时执行任务<br>
@register_job(scheduler, ‘interval’, id=‘test’, hours=3, minutes=30)<br>
还有seconds,days参数可以选择<br>
注：如果任务需要执行10秒，而间隔设置为1秒，它是不会给你开10个线程同时去执行10个任务的。它会错过其他任务直到当前任务完成。</p>
<p>‘cron’ + ‘hour’ + ‘minute’+…的参数组合，能实现cron类的任务。<br>
例子：每天的8点半执行任务<br>
@register_job(scheduler, ‘cron’, id=‘test’, hour=8, minute=30)<br>
还有day,second,month等参数可以选择。</p>
</li>
<li>
<p>id: 任务的名字，不传的话会自动生成。不过为了之后对任务进行暂停、开启、删除等操作，建议给一个名字。并且是唯一的，如果多个任务取一个名字，之前的任务就会被覆盖。</p>
</li>
<li>
<p>args: list类型，执行代码所需要的参数。</p>
</li>
<li>
<p>next_run_time：datetime类型，开始执行时间。</p>
</li>
</ol>
<h3 id="add-job函数">add_job函数</h3>
<p>装饰器的方法适合于写代码的人自己创建任务，如果想让用户通过页面创建定时任务，需要使用add_job函数。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#与前端的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DjangoCronjobViewSet</span>(<span class="title class_ inherited__">ModelViewSet</span>):</span><br><span class="line">    queryset = DjangoCronjob.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = DjangoCronjobSerializer</span><br><span class="line"></span><br><span class="line">    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend] </span><br><span class="line">    <span class="comment"># 指定自定义的过滤器</span></span><br><span class="line">    <span class="keyword">from</span> .serializers <span class="keyword">import</span> DjangoCronjobFilter</span><br><span class="line">    filterset_class = DjangoCronjobFilter</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    <span class="comment">#创建任务</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">        serializer = self.get_serializer(data=request.data)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># self.perform_create(serializer)</span></span><br><span class="line">            server_ids = request.data.get(<span class="string">&#x27;server_ids&#x27;</span>)</span><br><span class="line">            <span class="comment">#脚本内容</span></span><br><span class="line">            cron_script = request.data.get(<span class="string">&#x27;cron_script&#x27;</span>)</span><br><span class="line">            <span class="comment">#脚本名</span></span><br><span class="line">            command = request.data.get(<span class="string">&#x27;command&#x27;</span>)</span><br><span class="line">            note = request.data.get(<span class="string">&#x27;note&#x27;</span>)</span><br><span class="line">            schedule_str = <span class="built_in">str</span>(request.data.get(<span class="string">&#x27;schedule&#x27;</span>))</span><br><span class="line">            schedule_list = schedule_str.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            minute = schedule_list[<span class="number">0</span>]</span><br><span class="line">            hour = schedule_list[<span class="number">1</span>]</span><br><span class="line">            day = schedule_list[<span class="number">2</span>]</span><br><span class="line">            month = schedule_list[<span class="number">3</span>]</span><br><span class="line">            weekday = schedule_list[<span class="number">4</span>]</span><br><span class="line">            name = request.data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                scheduler.add_job(execute, <span class="string">&#x27;cron&#x27;</span>, minute=minute,hour=hour,day=day,month=month,week=weekday,<span class="built_in">id</span>=name,args=[command,cron_script,server_ids],replace_existing=<span class="literal">True</span>)</span><br><span class="line">                <span class="comment"># 如果没有运行再启动调度器，如果调度器之前没有被启动过，那么它将会开始执行所有已经添加并且没有被暂停的任务。</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> scheduler.running:</span><br><span class="line">                    scheduler.start()</span><br><span class="line">                <span class="comment">#添加任务后暂停运行，后面手动开启</span></span><br><span class="line">                job = scheduler.get_job(name)</span><br><span class="line">                <span class="keyword">if</span> job:</span><br><span class="line">                    job.pause()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                res = &#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;%s&#x27;</span> % e&#125;</span><br><span class="line">                <span class="keyword">return</span> Response(res)</span><br><span class="line">            job = DjangoJob.objects.get(<span class="built_in">id</span>=name)</span><br><span class="line">            DjangoCronjob.objects.create(</span><br><span class="line">                job=job,</span><br><span class="line">                server_ids=server_ids,</span><br><span class="line">                cron_script=cron_script,</span><br><span class="line">                command=command,</span><br><span class="line">                schedule=schedule_str,</span><br><span class="line">                note=note,</span><br><span class="line">            )</span><br><span class="line">            res = &#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;创建成功&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            res = &#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">400</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;%s&#x27;</span> %e&#125;</span><br><span class="line">        <span class="keyword">return</span> Response(res)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#移除任务</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">destroy</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">        instance = self.get_object()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            DjangoJobExecution.objects.<span class="built_in">filter</span>(job_id=<span class="built_in">str</span>(instance)).delete()  <span class="comment">#删除执行记录</span></span><br><span class="line">            self.perform_destroy(instance)  <span class="comment">#删除数据</span></span><br><span class="line">            scheduler.remove_job(<span class="built_in">str</span>(instance)) <span class="comment">#移除任务</span></span><br><span class="line">            res = &#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;删除成功&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            res = &#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;%s&#x27;</span> %e&#125;</span><br><span class="line">        <span class="keyword">return</span> Response(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体要执行的代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">command,cron_script,server_ids</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这样就可以通过前端创建任务了。</p>
<p>add_job函数参数说明：<br>
和装饰器的参数大同小异，只是第一个参数不同。<br>
如果具体要执行的函数和调用它的函数在一个文件中，那么只需要传递这个函数名就可以了（如上面的例子）。<br>
如果业务代码写到另外一个文件中，view.py中只写前后端交互的接口函数，这种情况下传递的参数为一个字符串，格式为： ‘package.module:some.object’，即 包名.模块:函数名。</p>
<h2 id="触发器执行示例">触发器执行示例</h2>
<ul>
<li>date 触发器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 2017-12-13 时刻运行一次 job_func 方法</span></span><br><span class="line">scheduler .add_job(job_func, <span class="string">&#x27;date&#x27;</span>, run_date=date(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">13</span>), args=[<span class="string">&#x27;text&#x27;</span>])</span><br><span class="line"><span class="comment"># 在 2017-12-13 14:00:00 时刻运行一次 job_func 方法</span></span><br><span class="line">scheduler .add_job(job_func, <span class="string">&#x27;date&#x27;</span>, run_date=datetime(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>), args=[<span class="string">&#x27;text&#x27;</span>])</span><br><span class="line"><span class="comment"># 在 2020-12-13 14:00:01 时刻运行一次 job_func 方法</span></span><br><span class="line">scheduler.add_job(job3,<span class="string">&quot;date&quot;</span>,run_date=<span class="string">&#x27;2020-12-13 14:00:01&#x27;</span>,args=[<span class="string">&#x27;王飞&#x27;</span>],<span class="built_in">id</span>=<span class="string">&quot;job3&quot;</span>)</span><br><span class="line"><span class="comment"># 每天0点执行函数的代码,0点的话，hour可以不用写</span></span><br><span class="line">app.scheduler.add_job(函数名, <span class="string">&quot;cron&quot;</span>, hour=<span class="number">0</span>, args=[函数需要传的参数]) </span><br><span class="line"><span class="comment">#每天凌晨3点执行代码</span></span><br><span class="line">app.scheduler.add_job(函数名, <span class="string">&quot;cron&quot;</span>, hour=<span class="number">3</span>, args=[app])</span><br><span class="line"><span class="comment">#如果date后面没有参数的话，就是立刻执行代码，一般测试的时候用</span></span><br><span class="line">app.scheduler.add_job(函数名, <span class="string">&quot;date&quot;</span>, args=[app])</span><br></pre></td></tr></table></figure>
<ul>
<li>interval 触发器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每隔两分钟执行一次 job_func 方法</span></span><br><span class="line">scheduler .add_job(job_func, <span class="string">&#x27;interval&#x27;</span>, minutes=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 在 2017-12-13 14:00:01 ~ 2017-12-13 14:00:10 之间, 每隔两分钟执行一次 job_func 方法</span></span><br><span class="line">scheduler .add_job(job_func, <span class="string">&#x27;interval&#x27;</span>, minutes=<span class="number">2</span>, start_date=<span class="string">&#x27;2017-12-13 14:00:01&#x27;</span> , end_date=<span class="string">&#x27;2017-12-13 14:00:10&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>cron 触发器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在每天的2点35分36分37分 执行 job_func 任务</span></span><br><span class="line">scheduler.add_job(job4,<span class="string">&quot;cron&quot;</span>,hour=<span class="string">&#x27;2&#x27;</span>, minute=<span class="string">&#x27;35-37&#x27;</span>,args=[<span class="string">&#x27;王涛&#x27;</span>],<span class="built_in">id</span>=<span class="string">&quot;job4&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="作业存储-job-store"><strong>作业存储(job store)</strong></h2>
<p>有两种添加方法，其中一种是 add_job()， 另一种则是@register_job()修饰器来修饰函数。</p>
<p>这个两种办法的区别是：第一种方法返回一个 Job 的实例，可以用来改变或者移除 job。第二种方法只适用于应用运行期间不会改变的 job。</p>
<h2 id="执行器-executor"><strong>执行器(executor)</strong></h2>
<p>执行调度任务的模块。最常用的 executor 是 ThreadPoolExecutor，存储路径是在Django数据库中。</p>
<p>执行器 executors 可以使用线程池（ThreadPoolExecutor）和进程池（ProcessPoolExecutor）</p>
<ul>
<li>线程池</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.executors.pool <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line">ThreadPoolExecutor(max_workers)  </span><br><span class="line">ThreadPoolExecutor(<span class="number">20</span>) <span class="comment"># 最多20个线程同时执行</span></span><br><span class="line"></span><br><span class="line">executors = &#123;</span><br><span class="line">	<span class="string">&#x27;default&#x27;</span>: ThreadPoolExecutor(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line">scheduler = BackgroundScheduler(executors=executors)</span><br></pre></td></tr></table></figure>
<ul>
<li>进程池</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.executors.pool <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line">ProcessPoolExecutor(max_workers)</span><br><span class="line">ProcessPoolExecutor(<span class="number">5</span>) <span class="comment"># 最多5个进程同时执行</span></span><br><span class="line"></span><br><span class="line">executors = &#123;</span><br><span class="line">	<span class="string">&#x27;default&#x27;</span>: ProcessPoolExecutor(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">scheduler = BackgroundScheduler(executors=executors)</span><br></pre></td></tr></table></figure>
<h2 id="其他功能">其他功能</h2>
<p>django-apscheduler框架还提供了很多操作定时任务的函数。比如：</p>
<ul>
<li>删除任务：scheduler.remove_job(job_name)</li>
<li>暂停任务：scheduler.pause_job(job_name)</li>
<li>开启任务：scheduler.resume_job(job_name)</li>
<li>获取所有任务：scheduler.get_jobs()</li>
<li>修改任务：scheduler.modify_job(job_name)</li>
</ul>
<p>注：修改任务只能修改参数，如果要修改执行时间的话，有3种方法:<br>
第一就把任务删了重新创建;<br>
第二直接操作数据库;<br>
第三用到下面重设任务。</p>
<ul>
<li>重设任务：scheduler.reschedule_job(job_name)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scheduler.reschedule_job(job_id=<span class="string">&quot;job1&quot;</span>, trigger=<span class="string">&#x27;interval&#x27;</span>, minutes=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>django-apscheduler使用起来十分方便。提供了基于日期、固定时间间隔以及crontab 类型的任务，我们可以在主程序的运行过程中快速增加新作业或删除旧作业，并且作业会存储在数据库中，当调度器重启时，不必重新添加作业，作业会恢复原状态继续执行。django-apscheduler可以当作一个跨平台的调度工具来使用，可以做为 linux 系统crontab 工具或 windows 计划任务程序的替换。需要注意的是，apscheduler不是一个守护进程或服务，它自身不带有任何命令行工具。它主要是要在现有的应用程序中运行。</p>
]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph分布式存储</title>
    <url>/2023/11/08/ceph%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="Ceph概述">Ceph概述</h2>
<h3 id="Ceph介绍">Ceph介绍</h3>
<p>Ceph是一个开源的分布式存储系统，具有高扩展性、高性能、高可靠性等特点，提 供良好的性能、可靠性和可扩展性。支持对象存储、块存储和文件系统。 是目前为云平台提供存储的理想方案</p>
<p><img src="/images/EDB87B969CC3495B9BFCEF3EDA5467EEclipboard.png" alt></p>
<h3 id="Ceph架构">Ceph架构</h3>
<ul>
<li>
<p>RBD（RADOS Block Device）：块存储接口</p>
</li>
<li>
<p>RGW（RADOS Gateway））：对象存储网关，接口与S3和Swift兼容</p>
</li>
<li>
<p>CephFS（Ceph File System）：文件级存储接口</p>
</li>
<li>
<p>RADOS（Reliable Autonomic Distributed Object Store）：抽象的 对象存储集群，Ceph核心，实现用户数据分配、故障转移等集群操作</p>
</li>
<li>
<p>MON：集群状态维护，例如OSD是否健康、PG状态等</p>
</li>
<li>
<p>MDS （Metadata Server） ：CephFS服务依赖的元数据服务</p>
</li>
<li>
<p>OSD（Object Storage Daemon）：对象存储设备，主要存储数据</p>
</li>
</ul>
<p><img src="/images/9D2BDF53EFF44536A3658AF85C227324clipboard.png" alt></p>
<h3 id="Ceph核心概念">Ceph核心概念</h3>
<p>Pool：存储池，是存储对象的逻辑分区，它规定了数据冗余的类型和对应的副本 分布策略；支持两种类型：副本（replicated）和 纠删码（Erasure Code）</p>
<p>PG（ placement group）：放置策略组，对象的集合，该集合里的所有对象都 具有相同的放置策略；简单点说就是相同PG内的对象都会放到相同的硬盘上； PG 是ceph的核心概念， 服务端数据均衡和恢复的最小粒度；引入PG这一层其实是为 了更好的分配数据和定位数据。</p>
<p>右边这张图描述了它们之间的关系：</p>
<ul>
<li>
<p>一个Pool里有很多PG；</p>
</li>
<li>
<p>一个PG里包含一堆对象；一个对象只能属于一个PG；</p>
</li>
<li>
<p>PG属于多个OSD，分布在不同的OSD上；</p>
</li>
</ul>
<p><img src="/images/F12F5EFAC24B45A2ABAB3BFEC92DA2C1clipboard.png" alt></p>
<h2 id="部署Ceph集群">部署Ceph集群</h2>
<h3 id="Ceph版本选择">Ceph版本选择</h3>
<p>Ceph目前最新版本16（P版），市面上应用最广泛的是12（L版）</p>
<p>参考：<a href="https://docs.ceph.com/en/latest/releases/">https://docs.ceph.com/en/latest/releases/</a></p>
<p><img src="/images/F43A32B6AD424611B3F3B3EB94111AD8clipboard.png" alt></p>
<h3 id="Ceph服务器配置推荐">Ceph服务器配置推荐</h3>
<p><img src="/images/4B0E5F7B935A43249DE36E1F971A8130clipboard.png" alt></p>
<h3 id="Ceph集群部署规划">Ceph集群部署规划</h3>
<ul>
<li>
<p>ceph-deploy：ceph集群部署节点，负责集群整体部署， 这里复用node1节点，也可以单独找一台服务器作为部署 节点。</p>
</li>
<li>
<p>monitor：Ceph监视管理节点，承担Ceph集群重要的管 理任务，负责集群状态维护，例如存储池副本数、PG状 态、OSD数量等，至少部署1个，一般需要3或5个节点组 建高可用。</p>
</li>
<li>
<p>osd：Ceph存储节点，实际负责数据存储的节点，集群 中至少有3个OSD，不少于默认副本数，每个OSD对应一 块硬盘。</p>
</li>
</ul>
<p><img src="/images/978109F0AA7A42C4AF692F96AD9C49E0clipboard.png" alt></p>
<p><img src="/images/7C09054CB62A4EC286BD3974E10EDA02clipboard.png" alt></p>
<h3 id="Ceph集群部署：操作系统初始化">Ceph集群部署：操作系统初始化</h3>
<p>ps：3台机器全部操作</p>
<h4 id="关闭防火墙">关闭防火墙</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>
<h4 id="关闭selinux">关闭selinux</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config <span class="comment"># 永久，重启生效</span></span><br><span class="line">setenforce 0 <span class="comment"># 临时</span></span><br></pre></td></tr></table></figure>
<h4 id="关闭swap">关闭swap</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff -a <span class="comment"># 临时</span></span><br><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab <span class="comment"># 永久，重启生效</span></span><br></pre></td></tr></table></figure>
<h4 id="根据规划设置主机名">根据规划设置主机名</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname &lt;hostname&gt;</span><br></pre></td></tr></table></figure>
<h4 id="在node添加hosts">在node添加hosts</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">192.168.0.11 ceph-node01</span></span><br><span class="line"><span class="string">192.168.0.12 ceph-node02</span></span><br><span class="line"><span class="string">192.168.0.13 ceph-node03</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h4 id="设置文件描述符">设置文件描述符</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -SHn 102400</span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/security/limits.conf &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string">* soft nofile 65535 * hard nofile 65535 </span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h4 id="时间同步">时间同步</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ntpdate -y</span><br><span class="line">ntpdate time.windows.com</span><br></pre></td></tr></table></figure>
<h4 id="配置SSH免交互认证">配置SSH免交互认证</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id root@ceph-node01</span><br><span class="line">ssh-copy-id root@ceph-node02</span><br><span class="line">ssh-copy-id root@ceph-node03</span><br></pre></td></tr></table></figure>
<h3 id="Ceph集群部署">Ceph集群部署</h3>
<p>Ceph集群部署方式：</p>
<ul>
<li>
<p>yum：常规的部署方式</p>
</li>
<li>
<p>ceph-ansible：官方基于ansible写的自动化部署工具</p>
</li>
</ul>
<p><a href="https://docs.ceph.com/projects/ceph-ansible/en/latest/">https://docs.ceph.com/projects/ceph-ansible/en/latest/</a></p>
<ul>
<li>ceph-deploy：ceph提供的简易部署工具，可以非常方便部署ceph集群。（推荐）</li>
</ul>
<p><a href="https://docs.ceph.com/projects/ceph-deploy/en/latest/">https://docs.ceph.com/projects/ceph-deploy/en/latest/</a></p>
<p>Ceph集群部署步骤：</p>
<p>1、配置阿里云yum仓库 （所有节点安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/yum.repos.d/ceph.repo &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Ceph]</span></span><br><span class="line"><span class="string">name=Ceph packages for $basearch</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/ceph/rpm-octopus/el7/\$basearch</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">[Ceph-noarch]</span></span><br><span class="line"><span class="string">name=Ceph noarch packages</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/ceph/rpm-octopus/el7/noarch</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">[ceph-source]</span></span><br><span class="line"><span class="string">name=Ceph source packages</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/ceph/rpm-octopus/el7/SRPMS</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>注：如果部署别的版本，将octopus替换为对应版本号即可。</p>
<p>2、安装ceph-deploy工具 （ceph-deploy节点安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install ceph-deploy    </span><br></pre></td></tr></table></figure>
<p>3、创建集群  （ceph-deploy节点安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个my-cluster目录，所有命令在此目录下进行：</span></span><br><span class="line"><span class="built_in">mkdir</span> my-cluster </span><br><span class="line"><span class="built_in">cd</span> my-cluster</span><br><span class="line"><span class="comment">#安装集群缺少的模块</span></span><br><span class="line">yum install epel-release -y     <span class="comment">#所有节点安装</span></span><br><span class="line">yum install python2-pip -y </span><br><span class="line"><span class="comment">#创建一个Ceph集群：</span></span><br><span class="line">ceph-deploy new ceph-node01 ceph-node02 ceph-node03</span><br></pre></td></tr></table></figure>
<p>4、安装Ceph （ceph-deploy节点安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装Ceph包到指定节点：</span></span><br><span class="line">ceph-deploy install --no-adjust-repos ceph-node01 ceph-node02 ceph-node03</span><br><span class="line"><span class="comment">#注：–no-adjust-repos参数是直接使用本地源，不使用官方默认源</span></span><br></pre></td></tr></table></figure>
<p>5、部署Monitor服务 （ceph-deploy节点安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#初始化并部署monitor，收集所有密钥：</span></span><br><span class="line">ceph-deploy mon create-initial</span><br><span class="line"><span class="comment">#使用ceph-deploy命令将配置文件和 admin key复制到管理节点和Ceph节点，以便每次执行ceph CLI命令无需 指定monitor地址和 ceph.client.admin.keyring。</span></span><br><span class="line">ceph-deploy admin ceph-node01 ceph-node02 ceph-node03</span><br></pre></td></tr></table></figure>
<p>6、部署OSD服务并添加硬盘 （ceph-deploy节点安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建6个OSD，分别对应每个节点未使用的硬盘：</span></span><br><span class="line">ceph-deploy osd create --data /dev/sdb ceph-node01</span><br><span class="line">ceph-deploy osd create --data /dev/sdc ceph-node01</span><br><span class="line">ceph-deploy osd create --data /dev/sdb ceph-node02</span><br><span class="line">ceph-deploy osd create --data /dev/sdc ceph-node02</span><br><span class="line">ceph-deploy osd create --data /dev/sdb ceph-node03</span><br><span class="line">ceph-deploy osd create --data /dev/sdc ceph-node03</span><br></pre></td></tr></table></figure>
<p>7、部署MGR服务（ceph-deploy节点安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-deploy mgr create ceph-node01 ceph-node02 ceph-node03</span><br></pre></td></tr></table></figure>
<p>注：MGR是Ceph L版本新增加的组件，主要作用是分担和扩展monitor的部分功能，减轻monitor的负担。 建议每台monitor节点都部署一个mgr，以实现相同级别的高可用。</p>
<p>查看Ceph集群状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph -s</span><br></pre></td></tr></table></figure>
<p><img src="/images/B6B3728400CD4B29B5225EDB4267552Eclipboard.png" alt></p>
<p>解决办法：(3台节点都操作）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装缺少的模块</span></span><br><span class="line">pip3 install pecan werkzeug</span><br><span class="line"><span class="comment">#禁用安全模式</span></span><br><span class="line">ceph config <span class="built_in">set</span> mon auth_allow_insecure_global_id_reclaim <span class="literal">false</span></span><br><span class="line"><span class="comment">#重启mgr服务</span></span><br><span class="line">systemctl restart ceph-mgr.target</span><br></pre></td></tr></table></figure>
<p>查看Ceph版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph -v</span><br></pre></td></tr></table></figure>
<h3 id="Ceph集群服务管理">Ceph集群服务管理</h3>
<p>1、启动所有守护进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl restart ceph.target </span></span><br></pre></td></tr></table></figure>
<p>2、按类型启动守护进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl restart ceph-osd@id </span></span><br><span class="line"><span class="comment"># systemctl restart ceph-mon.target </span></span><br><span class="line"><span class="comment"># systemctl restart ceph-mds.target </span></span><br><span class="line"><span class="comment"># systemctl restart ceph-mgr.target</span></span><br></pre></td></tr></table></figure>
<h3 id="Ceph集群常用管理命令">Ceph集群常用管理命令</h3>
<p><img src="/images/7F1083160E9D463883F3A2931A5768E0clipboard.png" alt></p>
<h2 id="Ceph存储使用">Ceph存储使用</h2>
<h3 id="三种存储类型介绍">三种存储类型介绍</h3>
<p>块存储（RBD）</p>
<p>优点：存储速度较快</p>
<p>缺点：不支持共享存储</p>
<p>应用场景：虚拟机硬盘</p>
<p>典型设备：硬盘、Raid</p>
<p>文件存储（CephFS）</p>
<p>优点：支持共享存储</p>
<p>缺点：读写速度较慢（需要经过操作系统处理再转为块存储）</p>
<p>应用场景：文件共享，多台服务器共享使用同一个存储</p>
<p>典型设备：FTP、NFS</p>
<p>对象存储（Object）</p>
<p>优点：具备块存储的读写性能和文件存储的共享特性</p>
<p>缺点：操作系统不能直接访问，只能通过应用程序级别的API访问</p>
<p>应用场景：图片存储，视频存储</p>
<p>典型设备：阿里云OSS，腾讯云COS</p>
<h3 id="RBD块存储：RBD工作流程">RBD块存储：RBD工作流程</h3>
<p>1、客户端创建一个pool，并指定pg数量，创建rbd设备并挂载到文件系统；</p>
<p>2、用户写入数据，ceph进行对数据切块，每个块的大小默认为4M，每个 块名字是object+序号； 3、将每个object通过pg进行副本位置的分配；</p>
<p>4、pg根据crush算法会寻找3个osd，把这object分别保存在这3个osd上 存储；</p>
<p>5、osd实际把硬盘格式化为xfs文件系统，object存储在这个文件系统就相 当于存储了一个文件rbd0.object1.file。</p>
<p><img src="/images/C1F833C8BF1A42C8BB6FF71D4209EC74clipboard.png" alt></p>
<h3 id="RBD块存储：常用管理命令">RBD块存储：常用管理命令</h3>
<p><img src="/images/408D7E50905B40F491EBC9D864864D67clipboard.png" alt></p>
<h3 id="RBD块存储：RBD创建并使用">RBD块存储：RBD创建并使用</h3>
<p>1、创建存储池</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pool create rbd-pool 128 <span class="comment"># 格式：ceph osd pool create &lt;pool-name&gt; &lt;pg-num&gt;</span></span><br><span class="line">ceph osd pool <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>PG数量设置计算公式：PG数量=(OSD数量*100)/副本数（3）</p>
<p>例如我们的环境：(6*100)/3=200，一般设置是结果向上取2的N次方，所以pool指定的pg数量就是256</p>
<p>2、指定存储池使用存储类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pool application <span class="built_in">enable</span> rbd-pool rbd</span><br></pre></td></tr></table></figure>
<p>3、创建一个10G的块设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd create --size 10240 rbd-pool/image01 <span class="comment"># 格式：rbd create --size &#123;megabytes&#125; &#123;pool-name&#125;/&#123;image-name&#125;</span></span><br></pre></td></tr></table></figure>
<p>4、查看块设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd <span class="built_in">ls</span> rbd-pool</span><br><span class="line">rbd info rbd-pool/image01</span><br></pre></td></tr></table></figure>
<p>节点本地挂载使用块设备：</p>
<p>1、映射</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd map rbd-pool/image01</span><br></pre></td></tr></table></figure>
<p>2、格式化块设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.xfs /dev/rbd0</span><br></pre></td></tr></table></figure>
<p>3、挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/rbd0 /mnt</span><br></pre></td></tr></table></figure>
<p><img src="/images/864B295E82BE4568AC1FEF86F5C98A98clipboard.png" alt></p>
<p>4、取消挂载和内核映射</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /mnt</span><br><span class="line">rbd unmap rbd-pool/image01</span><br></pre></td></tr></table></figure>
<p>远程挂载使用块设备：</p>
<p>1、拷贝配置文件和秘钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-cluster/</span><br><span class="line">scp ceph.conf root@192.168.0.14:/etc/ceph/</span><br><span class="line">scp ceph.client.admin.keyring root@192.168.0.14:/etc/ceph/</span><br></pre></td></tr></table></figure>
<p>2、安装Ceph客户端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">scp /etc/yum.repos.d/ceph.repo root@192.168.0.14:/etc/yum.repos.d/</span><br><span class="line">yum -y install ceph-common</span><br></pre></td></tr></table></figure>
<p>3、剩余操作就与上面一样了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd create --size 20480 rbd-pool/image02</span><br><span class="line">rbd <span class="built_in">ls</span> rbd-pool</span><br><span class="line">rbd map rbd-pool/image02</span><br><span class="line">rbd map rbd-pool/image02</span><br><span class="line">mkfs.xfs /dev/rbd0</span><br><span class="line">mount /dev/rbd0 /mnt/</span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line">umount  /mnt/</span><br><span class="line">rbd unmap rbd-pool/image02</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/7A83483B4F564FFCB93DAB7F16B6B381clipboard.png" alt></p>
<h3 id="RBD块存储：快照">RBD块存储：快照</h3>
<p>快照：在某个时间点的副本，当系统出现问题，可以通过恢复快照恢复之前副本状态。</p>
<p>1、创建快照</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd snap create rbd-pool/image01@snap01</span><br></pre></td></tr></table></figure>
<p>2、查看快照</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd snap list rbd-pool/image01</span><br></pre></td></tr></table></figure>
<p>3、还原快照</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount  /mnt/</span><br><span class="line">rbd unmap rbd-pool/image01</span><br><span class="line">rbd snap rollback rbd-pool/image01@snap01</span><br><span class="line">注：还原快照前需先取消挂载和内核映射，否则会出错</span><br></pre></td></tr></table></figure>
<p>4、重新映射并挂载验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd map rbd-pool/image01</span><br><span class="line">mount /dev/rbd0 /mnt/</span><br></pre></td></tr></table></figure>
<p>5、删除快照</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd snap <span class="built_in">rm</span> rbd-pool/image01@snap01</span><br></pre></td></tr></table></figure>
<p><img src="/images/DCC1F8703F004C94931B35D322DE5913clipboard.png" alt></p>
<p><img src="/images/5CC3159040964F778A9ECE84B505D823clipboard.png" alt></p>
<h3 id="RBD块存储：克隆">RBD块存储：克隆</h3>
<p>克隆：基于指定的块设备克隆出相同的一份出来</p>
<p>1、创建一个块设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd create --size 10240 rbd-pool/image02</span><br></pre></td></tr></table></figure>
<p>2、创建快照</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd snap create rbd-pool/image02@snap01</span><br></pre></td></tr></table></figure>
<p>3、设置快照处于被保护状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd snap protect rbd-pool/image02@snap01</span><br></pre></td></tr></table></figure>
<p>4、通过快照克隆一个新块设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd <span class="built_in">clone</span> rbd-pool/image02@snap01 rbd-pool/image02_clone</span><br><span class="line">rbd info rbd-pool/image02_clone</span><br></pre></td></tr></table></figure>
<p>5、将克隆的块设备独立于父块设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd flatten rbd-pool/image02_clone</span><br></pre></td></tr></table></figure>
<p>基于上述快照之后的步骤</p>
<p><img src="/images/780F3B0FA1E14F2D8D83EB2778C7374Aclipboard.png" alt></p>
<p><img src="/images/44921CAF73254AE79C845AC9FF60312Aclipboard.png" alt></p>
<p>由于克隆的uuid一致，需要在其他机器上挂载验证克隆的镜像是否可用</p>
<p><img src="/images/AB395B73E9C44D609201473CCDC0013Fclipboard.png" alt></p>
<h3 id="CephFS文件系统">CephFS文件系统</h3>
<p>CephFS 是一个基于 ceph 集群且兼容POSIX标准的文件系统。</p>
<p>创建 cephfs 文件系统时需要在 ceph 集群中添加 mds 服务，该服务 负责处理 POSIX 文件系统中的 metadata 部分，实际的数据部分交由 ceph 集群中的OSD处理。</p>
<p>cephfs 支持以内核模块方式加载也支持 fuse 方式加载。无论是内核 模式还是 fuse 模式，都是通过调用 libcephfs 库来实现 cephfs 文件 系统的加载，而 libcephfs 库又调用 librados 库与 ceph 集群进行通 信，从而实现 cephfs 的加载。</p>
<p><img src="/images/C106DA8250B74E1E9116CE0BEE91F50Dclipboard.png" alt></p>
<h3 id="CephFS文件系统：部署MDS服务">CephFS文件系统：部署MDS服务</h3>
<p>部署MDS实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-deploy mds create ceph-node01 ceph-node02 ceph-node03</span><br><span class="line">ceph mds <span class="built_in">stat</span> <span class="comment"># 查看MDS节点状态</span></span><br></pre></td></tr></table></figure>
<h3 id="CephFS文件系统：创建文件系统">CephFS文件系统：创建文件系统</h3>
<p>1、创建存储池</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pool create cephfs_data &lt;pg_num&gt;</span><br><span class="line">ceph osd pool create cephfs_metadata &lt;pg_num&gt;</span><br><span class="line">ceph fs <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>2、创建文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph fs new cephfs cephfs_metadata cephfs_data <span class="comment"># 格式：ceph fs new &lt;fs_name&gt; &lt;metadata&gt; &lt;data&gt; </span></span><br><span class="line">ceph fs <span class="built_in">ls</span> <span class="comment">#查看创建后的cephfs</span></span><br></pre></td></tr></table></figure>
<h3 id="CephFS文件系统：挂载并使用">CephFS文件系统：挂载并使用</h3>
<p>内核模块方式挂载：</p>
<p>1、安装Ceph客户端 （前面已经安装客户端啦）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum -y install ceph-common</span><br></pre></td></tr></table></figure>
<p>2、获取账号名与秘钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph auth list |grep admin -A1</span><br></pre></td></tr></table></figure>
<p>3、挂载本地目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t ceph 192.168.0.11:6789,192.168.0.12:6789,192.168.0.13:6789:/ /mnt/ -o name=admin,secret=AQDPhU5hxkfUHRAAQUcQHyrXTTJCRmBPONmVzg==</span><br><span class="line"><span class="comment">#或者将密钥指定到文件</span></span><br><span class="line">vim /etc/ceph/admin.secret </span><br><span class="line">mount -t ceph 192.168.0.11:6789,192.168.0.12:6789,192.168.0.13:6789:/ /tmp/ -o name=admin,secretfile=/etc/ceph/admin.secret </span><br></pre></td></tr></table></figure>
<p>4、取消挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /mnt</span><br></pre></td></tr></table></figure>
<p>fuse方式挂载：</p>
<p>1、安装fuse</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y ceph-fuse</span><br></pre></td></tr></table></figure>
<p>2、挂载本地目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-fuse -m 192.168.0.11:6789,192.168.0.12:6789,192.168.0.13:6789 /mnt/</span><br><span class="line"><span class="comment">#这里没有指定密钥是因为它默认读取的是/etc/ceph/ceph.client.admin.keyring </span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/ceph/ceph.client.admin.keyring </span></span><br><span class="line">[client.admin]</span><br><span class="line">	key = AQDPhU5hxkfUHRAAQUcQHyrXTTJCRmBPONmVzg==</span><br><span class="line">	caps mds = <span class="string">&quot;allow *&quot;</span></span><br><span class="line">	caps mgr = <span class="string">&quot;allow *&quot;</span></span><br><span class="line">	caps mon = <span class="string">&quot;allow *&quot;</span></span><br><span class="line">	caps osd = <span class="string">&quot;allow *&quot;</span></span><br></pre></td></tr></table></figure>
<p>3、取消卸载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fusermount -u /mnt/</span><br></pre></td></tr></table></figure>
<h3 id="对象存储">对象存储</h3>
<p>Ceph对象存储不能像RBD、CephFS那样方式访问，它是通 过Restfulapi方式进行访问和使用。兼容S3/Swift接口，由 radosgw组件提供服务。所以需要安装这个服务。</p>
<p><img src="/images/8AD3A5006168462C82C97E9640613903clipboard.png" alt></p>
<h3 id="对象存储：部署RGW服务">对象存储：部署RGW服务</h3>
<p>部署RGW服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-deploy rgw create ceph-node01 ceph-node02</span><br></pre></td></tr></table></figure>
<p>验证访问，RGW默认7480端口，浏览器访问：<a href="http://192.168.31.71:7480">http://192.168.31.71:7480</a></p>
<p>返回anonymous说明服务正常。</p>
<h3 id="对象存储：使用">对象存储：使用</h3>
<p>radosgw-admin 是 RADOS 网关用户管理工具。</p>
<p>1、创建S3账号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">radosgw-admin user create --uid=<span class="string">&quot;azhe&quot;</span> --display-name=<span class="string">&quot;azhe&quot;</span></span><br><span class="line">注：记住输出的keys中的access_key和secret_key的值，用于接口访问认证。</span><br><span class="line">如果忘记 也可以通过这个命令查看：radosgw-admin user info --uid=azhe</span><br></pre></td></tr></table></figure>
<p>2、编写Python脚本测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安装连接boto模块，用于连接S3接口：</span><br><span class="line">pip3 install boto</span><br><span class="line">参考示例：https://docs.ceph.com/en/nautilus/radosgw/s3/python/</span><br></pre></td></tr></table></figure>
<h2 id="Kubernetes使用Ceph作为Pod存储">Kubernetes使用Ceph作为Pod存储</h2>
<h3 id="PV与PVC概述">PV与PVC概述</h3>
<p>PersistentVolume（PV）：持久卷，对外部存储资源创建和使用的抽象， 使得存储作为集群中的资源管理；PV又分为静态供给和动态供给，由于静态 供给需要提前创建一堆PV，维护成本较高，所以企业一般使用动态供给。</p>
<p>PersistentVolumeClaim（PVC）：持久卷申请，让用户不需要关心具体 的Volume实现细节，只需要定义PVC需要多少磁盘容量即可。</p>
<p><img src="/images/E6625444C3824E1EA14FE22591E0DE9Cclipboard.png" alt></p>
<h3 id="ceph-csi供给程序">ceph-csi供给程序</h3>
<p>ceph-csi是ceph官方维护的PV供给程序，专门用于在 Kubernetes中使用RBD、CephFS为Pod提供存储。</p>
<p>项目地址：<a href="https://github.com/ceph/ceph-csi">https://github.com/ceph/ceph-csi</a></p>
<p><img src="/images/1F2BE3EE5A734C83A078D4780336D56Fclipboard.png" alt></p>
<h3 id="Pod使用RBD块存储">Pod使用RBD块存储</h3>
<p>关于部署，RBD YAML文件在deploy/rbd/kubernetes目录，课件中YAML改动如下：</p>
<ul>
<li>
<p>全部统一命名空间到ceph-csi</p>
</li>
<li>
<p>将镜像转存到docker hub</p>
</li>
<li>
<p>增加secret.yaml和storageclass.yaml文件</p>
</li>
<li>
<p>将csi-rbdplugin-provisioner.yaml 和 csi-rbdplugin.yaml 中 关于kms配置注释</p>
</li>
</ul>
<p>在使用中，还需要根据自己集群环境修改：</p>
<ul>
<li>
<p>csi-config-map.yaml 修改连接ceph集群信息</p>
</li>
<li>
<p>secret.yaml 修改秘钥</p>
</li>
<li>
<p>storageclass.yaml 修改集群ID和存储池</p>
</li>
</ul>
<h3 id="Pod使用CephFS文件系统">Pod使用CephFS文件系统</h3>
<p>关于部署，RBD YAML文件在deploy/cephfs/kubernetes目录，课件中YAML改动如下：</p>
<ul>
<li>
<p>全部统一命名空间到ceph-csi-cephfs</p>
</li>
<li>
<p>将镜像转存到docker hub</p>
</li>
<li>
<p>增加secret.yaml和storageclass.yaml文件</p>
</li>
<li>
<p>将csi-rbdplugin-provisioner.yaml 和 csi-rbdplugin.yaml 中 关于kms配置注释</p>
</li>
</ul>
<p>在使用中，还需要根据自己集群环境修改：</p>
<ul>
<li>
<p>csi-config-map.yaml 修改连接ceph集群信息</p>
</li>
<li>
<p>secret.yaml 修改秘钥</p>
</li>
<li>
<p>storageclass.yaml 修改集群ID和文件系统名称</p>
</li>
</ul>
<h3 id="小结">小结</h3>
<p><img src="/images/FFC5666BFF9B4DACB117A5B0B5F69C5Dclipboard.png" alt></p>
<p>RBD：</p>
<p>优点：读写性能好，支持镜像快照、克隆</p>
<p>缺点：不支持多节点挂载</p>
<p>适用场景：对读写性能要求高，且无多节点同时读写数据需求的应用，例如数据库</p>
<p>CephFS：</p>
<p>优点：支持K8s所有访问模式，支持多节点同时读写数据</p>
<p>缺点：读写性能一般，延迟时间不稳定</p>
<p>适用场景：对读写性能要求不高，I/O延迟不敏感的应用，例如文件共享</p>
<h2 id="Ceph-监控">Ceph 监控</h2>
<h3 id="Dashboard">Dashboard</h3>
<p>从L版本开始，Ceph 提供了原生的Dashboard功能，通过Dashboard对Ceph集群状态查看和基本管理。</p>
<p>使用Dashboard需要在MGR节点安装软件包： yum install ceph-mgr-dashboard –y</p>
<p>如果是按课程用的O版本会出现下面缺少依赖包提示：</p>
<p><img src="/images/5659B49493B946FF978BA7211DDC481Aclipboard.png" alt></p>
<p>原因分析：这是由于从O版本开始，MGR改为Python3编写，而默认库没有这3个模块包，即使单独找包安装也可能 不生效或者安装不上。从社区得知，这是已知问题，建议使用CentOS8系统或者使用cephadm容器化部署Ceph。 或者降低Ceph版本也可以，例如H版本，这个版本还是Python2编写的，不存在缺包问题。</p>
<p>这里选择降低到H版本，重新部署Ceph集群。</p>
<p>1、清理Ceph集群环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程主机卸载ceph包并清理所有数据</span></span><br><span class="line">ceph-deploy purge ceph-node01 ceph-node02 ceph-node03</span><br><span class="line"><span class="comment"># 清理ceph所有数据（/var/lib/ceph）</span></span><br><span class="line">ceph-deploy purgedata ceph-node01 ceph-node02 ceph-node03</span><br><span class="line"><span class="comment"># 从本地目录移出认证秘钥（my-cluster目录），可选</span></span><br><span class="line">ceph-deploy forgetkeys</span><br><span class="line"><span class="comment"># 彻底清理ceph相关软件包</span></span><br><span class="line">rpm -qa |grep 15.2.13 |xargs -i yum remove &#123;&#125; -y</span><br><span class="line"><span class="comment"># 取消OSD盘创建的LVM逻辑卷映射关系</span></span><br><span class="line">dmsetup info -C |awk <span class="string">&#x27;/ceph/&#123;print $1&#125;&#x27;</span> |xargs -i dmsetup remove &#123;&#125;</span><br><span class="line"><span class="comment"># 清除OSD盘GPT数据结构</span></span><br><span class="line">yum install gdisk -y</span><br><span class="line">sgdisk --zap-all /dev/sdb</span><br></pre></td></tr></table></figure>
<p>2、与之前部署方式一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/yum.repos.d/ceph.repo &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Ceph]</span></span><br><span class="line"><span class="string">name=Ceph packages for $basearch</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/ceph/rpm-nautilus/el7/\$basearch</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">[Ceph-noarch]</span></span><br><span class="line"><span class="string">name=Ceph noarch packages</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/ceph/rpm-nautilus/el7/noarch</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">[ceph-source]</span></span><br><span class="line"><span class="string">name=Ceph source packages</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/ceph/rpm-nautilus/el7/SRPMS</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install ceph-deploy   </span><br><span class="line"><span class="built_in">mkdir</span> my-cluster </span><br><span class="line"><span class="built_in">cd</span> my-cluster</span><br><span class="line">yum install epel-release -y </span><br><span class="line">yum install python2-pip -y </span><br><span class="line">ceph-deploy new ceph-node01 ceph-node02 ceph-node03</span><br><span class="line">ceph-deploy install --no-adjust-repos ceph-node01 ceph-node02 ceph-node03</span><br><span class="line">ceph-deploy mon create-initial</span><br><span class="line">ceph-deploy admin ceph-node01 ceph-node02 ceph-node03</span><br><span class="line">ceph-deploy osd create --data /dev/sdb ceph-node01</span><br><span class="line">ceph-deploy osd create --data /dev/sdc ceph-node01</span><br><span class="line">ceph-deploy osd create --data /dev/sdb ceph-node02</span><br><span class="line">ceph-deploy osd create --data /dev/sdc ceph-node02</span><br><span class="line">ceph-deploy osd create --data /dev/sdb ceph-node03</span><br><span class="line">ceph-deploy osd create --data /dev/sdc ceph-node03</span><br><span class="line">ceph-deploy mgr create ceph-node01 ceph-node02 ceph-node03</span><br></pre></td></tr></table></figure>
<p>3、添加RBD块设备和CephFS文件系统测试</p>
<p>添加RBD块设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pool create rbd-pool 128</span><br><span class="line">ceph osd pool application <span class="built_in">enable</span> rbd-pool rbd</span><br><span class="line">rbd create --size 10240 rbd-pool/image01 </span><br><span class="line">rbd map rbd-pool/image01</span><br><span class="line">mkfs.xfs /dev/rbd0</span><br><span class="line">mount /dev/rbd0 /mnt</span><br></pre></td></tr></table></figure>
<p>添加CephFS文件系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-deploy mds create ceph-node01 ceph-node02 ceph-node03</span><br><span class="line">ceph osd pool create cephfs_data 128</span><br><span class="line">ceph osd pool create cephfs_metadata 128</span><br><span class="line">ceph fs new cephfs cephfs_metadata cephfs_data </span><br><span class="line">mount -t ceph 192.168.0.11:6789,192.168.0.12:6789,192.168.0.13:6789:/ /mnt -o </span><br><span class="line">name=admin,secret=AQBwS9Vgow1+OBAA0eMOK8v5LlU7m+/cg+wIng==</span><br></pre></td></tr></table></figure>
<p>1、在每个MGR节点安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ceph-mgr-dashboard –y</span><br></pre></td></tr></table></figure>
<p>2、开启MGR功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph mgr module <span class="built_in">enable</span> dashboard</span><br></pre></td></tr></table></figure>
<p>3、修改默认配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph config <span class="built_in">set</span> mgr mgr/dashboard/server_addr 0.0.0.0</span><br><span class="line">ceph config <span class="built_in">set</span> mgr mgr/dashboard/server_port 7000 </span><br><span class="line">ceph config <span class="built_in">set</span> mgr mgr/dashboard/ssl <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>4、创建一个dashboard登录用户名密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph dashboard ac-user-create admin administrator -i password.txt</span><br><span class="line">格式：dashboard ac-user-create &lt;username&gt; &#123;&lt;rolename&gt;&#125; &#123;&lt;name&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>5、查看服务访问方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph mgr services</span><br></pre></td></tr></table></figure>
<p>后面如果修改配置，重启生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph mgr module <span class="built_in">disable</span> dashboard</span><br><span class="line">ceph mgr module <span class="built_in">enable</span> dashboard</span><br></pre></td></tr></table></figure>
<p><img src="/images/60E4C32C13634E9F943183C8B5D8CB53clipboard.png" alt></p>
<h3 id="Prometheus-Grafana监控Ceph">Prometheus+Grafana监控Ceph</h3>
<ul>
<li>Prometheus（普罗米修斯）：容器监控系统。</li>
</ul>
<p>官网：<a href="https://prometheus.io">https://prometheus.io</a></p>
<ul>
<li>Grafana：是一个开源的度量分析和可视化系统。</li>
</ul>
<p>官网：<a href="https://grafana.com/grafana">https://grafana.com/grafana</a></p>
<p>1、Docker部署Prometheus+Grafana</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">yum install docker-ce -y</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">docker run -d --name=grafana -p 3000:3000 grafana/grafana</span><br><span class="line">docker run -d --name=prometheus -p 9090:9090 prom/prometheus</span><br></pre></td></tr></table></figure>
<p>2、启用MGR Prometheus插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph mgr module <span class="built_in">enable</span> prometheus </span><br><span class="line">curl 127.0.0.1:9283/metrics <span class="comment"># # 测试promtheus指标接口</span></span><br></pre></td></tr></table></figure>
<p>3、配置Prometheus采集</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it prometheus sh</span><br><span class="line">vi /etc/prometheus/prometheus.yml</span><br><span class="line">- job_name: <span class="string">&#x27;ceph&#x27;</span> </span><br><span class="line">static_configs: </span><br><span class="line">- targets: [<span class="string">&#x27;192.168.31.71:9283&#x27;</span>] </span><br><span class="line">docker restart prometheus</span><br></pre></td></tr></table></figure>
<p>4、访问Grafana仪表盘</p>
<p><a href="http://IP:3000">http://IP:3000</a></p>
<p>默认用户名密码均为admin</p>
<ol>
<li>
<p>添加Prometheus为数据源：Configuration -&gt; Data sources -&gt; Promethes -&gt; 输入URL <a href="http://IP:9090">http://IP:9090</a></p>
</li>
<li>
<p>导入Ceph监控仪表盘：Dashboards -&gt; Manage -&gt; Import -&gt; 输入仪表盘ID，加载</p>
</li>
</ol>
<ul>
<li>
<p>Ceph-Cluster ID：2842</p>
</li>
<li>
<p>Ceph-OSD ID：5336</p>
</li>
<li>
<p>Ceph-Pool ID：5342</p>
</li>
</ul>
<p><img src="/images/708F09AB64F74A36A68B51DD463540CAclipboard.png" alt></p>
]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>Ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>django-csrf防护</title>
    <url>/2024/03/10/django-csrf%E9%98%B2%E6%8A%A4/</url>
    <content><![CDATA[<h2 id="CSRF是什么">CSRF是什么</h2>
<p>CSRF（Cross Site Request Forgery）：跨站请求伪造，实现的原 理是CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻 击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网 站发起伪造用户操作的请求，达到攻击目的。</p>
<p><img src="/images/6386C10278484770A5B4D8C0B2760792clipboard.png" alt></p>
<h2 id="Django-CSRF工作原理">Django CSRF工作原理</h2>
<p>Django怎么验证一个请求是不是CSRF？</p>
<p>Django处理客户端请求时，会生成一个随机Token，放到响应内容一起返回，然后需要前端每次POST请求时带上这 个Token，可以放到POST数据里键为csrfmiddlewaretoken，或者放到请求头键为X-CSRFToken，Django从这两个 位置取，每次处理都会拦截验证，通过比对两者是否一致来判断这个请求是不是非法，非法就返回403状态码。</p>
<h2 id="使用CSRF防护机制">使用CSRF防护机制</h2>
<p>常见有三种方法可以携带CSRF Token发送给服务端：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- from表单添加&#123;% csrf_token %&#125;标签，表单会携带一同提交 </span><br><span class="line"></span><br><span class="line">- 如果你是Ajax请求，需要把csrf token字符串（也是通过拿&#123;% csrf_token %&#125;标签产生的值）放到data里一起提交， 并且键名为csrfmiddlewaretoken或者放到请求头传递服务端 </span><br><span class="line"></span><br><span class="line">- 指定取消某函数视图CSRF防护</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/3992633A619A4F61A077053659D3873Dclipboard.png" alt></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">方式1：</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">方式2：</span><br><span class="line">var csrf_token = $(&quot;[name=&#x27;csrfmiddlewaretoken&#x27;]&quot;).val();</span><br><span class="line">var data = &#123;&#x27;id&#x27;: &#x27;123&#x27;, &#x27;csrfmiddlewaretoken&#x27;: csrf_token&#125;;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &quot;POST&quot;,</span><br><span class="line">    url: &quot;/api&quot;,</span><br><span class="line">    data: data,</span><br><span class="line">    dataType: &#x27;json&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">方式<span class="number">3</span>：</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django-orm基本使用</title>
    <url>/2024/03/06/django-orm%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="了解静态网站与动态网站">了解静态网站与动态网站</h2>
<p><img src="/images/94E5E1A185CA4402951D3F3F69679E09clipboard.png" alt></p>
<p><img src="/images/0D2412B7A898421EAB246885BE8E6874clipboard.png" alt></p>
<h2 id="ORM-是什么">ORM 是什么</h2>
<p>对象关系映射（Object Relational Mapping，ORM）：是一种程序设计技术，用于实现面向对象编程语言 里不同类型系统的数据之间的转换。简单来说就是在编程语言中实现的一种虚拟对象数据库。我们对虚拟对象 数据库进行操作，它会转换成具体的SQL去操作数据库，这样一来我们就不需要学习复杂的SQL语句了。</p>
<p>ORM优势：不必熟悉复杂的SQL语句，容易上手，避免新手写SQL效率问题。</p>
<p><img src="/images/89AC71DE3AA7498BAA2C9EC2DC693BEEclipboard.png" alt></p>
<h2 id="Model（模型类）">Model（模型类）</h2>
<p>1、使用模型类定义一个User表，包含多字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># myapp/models.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(models.Model):</span><br><span class="line">    user = models.CharField(max_length=<span class="number">30</span>) <span class="comment"># 用户名 </span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>) <span class="comment"># 姓名 </span></span><br><span class="line">    sex = models.CharField(max_length=<span class="number">10</span>) <span class="comment"># 性别</span></span><br><span class="line">    age = models.IntegerField() <span class="comment"># 年龄 </span></span><br><span class="line">    label = models.CharField(max_length=<span class="number">100</span>) <span class="comment"># 标签</span></span><br></pre></td></tr></table></figure>
<p>2、在settings.py配置文件中INSTALLED_APPS列表添加APP名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [ </span><br><span class="line">    <span class="comment">#... </span></span><br><span class="line">    <span class="string">&#x27;myapp&#x27;</span>, </span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>3、将模型类生成具体的数据库表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成迁移文件 </span></span><br><span class="line">python manage.py makemigrations </span><br><span class="line"><span class="comment"># 执行迁移文件生成表 </span></span><br><span class="line">python mange.py migrate</span><br></pre></td></tr></table></figure>
<p>4、进入数据库查看表</p>
<p>生成表名的默认格式：应用名_模型类名小写</p>
<h2 id="使用MySQL数据库">使用MySQL数据库</h2>
<p>1、使用docker启动一个mysql实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name db \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -v mysqldata:/var/lib/mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123456 \ </span><br><span class="line">  mysql:5.7 --character-set-server=utf8</span><br></pre></td></tr></table></figure>
<p>2、使用pip工具安装pymysql模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure>
<p>3、修改django默认连接数据库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># devops/settings.py</span></span><br><span class="line">DATABASES = &#123; </span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123; </span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;test&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;192.168.1.11&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>, </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、指定数据库驱动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># myapp/__init__.py</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>
<p>5、执行迁移文件生成表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python mange.py migrate</span><br></pre></td></tr></table></figure>
<h2 id="ORM增删改查">ORM增删改查</h2>
<p>增：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_add</span>(<span class="params">request</span>):</span><br><span class="line">    User.objects.create(</span><br><span class="line">    user=<span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    name=<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    sex=<span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    age=<span class="string">&#x27;30&#x27;</span>,</span><br><span class="line">    label=<span class="string">&quot;IT,讲师,老司机&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;用户添加成功！&quot;</span>)</span><br><span class="line">    </span><br><span class="line">或者用save方法保存：</span><br><span class="line">obj = User(</span><br><span class="line">    user=user,</span><br><span class="line">    name=name,</span><br><span class="line">    sex=sex,</span><br><span class="line">    age=age,</span><br><span class="line">    label=label</span><br><span class="line">    )</span><br><span class="line">obj.save()</span><br></pre></td></tr></table></figure>
<p>查：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_list</span>(<span class="params">request</span>):</span><br><span class="line">    user_list = User.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;user.html&quot;</span>, &#123;<span class="string">&#x27;user_list&#x27;</span>: user_list&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 获取所有数据</span></span><br><span class="line">User.objects.<span class="built_in">all</span>() </span><br><span class="line"><span class="comment"># 加条件获取数据</span></span><br><span class="line">User.objects.<span class="built_in">filter</span>(user=<span class="string">&#x27;amei&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取单条数据</span></span><br><span class="line">User.objects.<span class="built_in">filter</span>(age__gt=<span class="number">28</span>) </span><br><span class="line">User.objects.get(<span class="built_in">id</span>=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">User.objects.<span class="built_in">filter</span>(user=<span class="string">&#x27;amei&#x27;</span>).update(age=<span class="number">27</span>,label=<span class="string">&#x27;公关,漂亮,喜欢购物&#x27;</span>)</span><br><span class="line">或者</span><br><span class="line">obj = User.objects.get(user=<span class="string">&#x27;amei&#x27;</span>)</span><br><span class="line">obj.age = <span class="number">25</span></span><br><span class="line">obj.save()</span><br></pre></td></tr></table></figure>
<p>删：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">User.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">3</span>).delete()</span><br><span class="line">或者 </span><br><span class="line">obj = User.objects.get(<span class="built_in">id</span>=<span class="number">2</span>) </span><br><span class="line">obj.delete()</span><br></pre></td></tr></table></figure>
<h2 id="Django内置管理后台">Django内置管理后台</h2>
<p>管理后台：一个网站一般都会开发一个后台系统，为管理员提供一种更简单的数据库操作方式。</p>
<p><img src="/images/EED3F4410E1A4F96B8B175BE8ECBC129clipboard.png" alt></p>
<p>1、访问URL</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin <span class="comment"># 内建管理后台功能</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line">urlpatterns = [</span><br><span class="line">     path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),  <span class="comment"># 内建管理后台访问地址</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>2、创建管理员账号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>
<p>3、注册模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># myapp/admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> models</span><br><span class="line">admin.site.register(models.User) </span><br></pre></td></tr></table></figure>
<p>4、设置语言和时区</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># devops/settings.py</span></span><br><span class="line">LANGUAGE_CODE = <span class="string">&#x27;zh-hans&#x27;</span></span><br><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">USE_I18N = <span class="literal">True</span></span><br><span class="line">USE_L10N = <span class="literal">True</span></span><br><span class="line">USE_TZ = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/39F4D4BED2234603834981AC7915056Eclipboard.png" alt></p>
<h2 id="模型中的Meta类与方法">模型中的Meta类与方法</h2>
<p>Django模型类的Meta是一个内部类,它用于定义一些Django模型类的行为特性。</p>
<p>以下是该常用属性：</p>
<p><img src="/images/3E7993007F9F4BB5BB53916745C28751clipboard.png" alt></p>
<p>示例：模型类Meta与方法使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(models.Model):</span><br><span class="line">    user = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    sex = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    label = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        app_label = <span class="string">&quot;myapp&quot;</span>      <span class="comment"># 指定APP名称</span></span><br><span class="line">        db_table = <span class="string">&quot;myapp_user&quot;</span>  <span class="comment"># 自定义生成的表名</span></span><br><span class="line">        verbose_name = <span class="string">&quot;用户表&quot;</span>  <span class="comment"># 对象的可读名称</span></span><br><span class="line">        verbose_name_plural = <span class="string">&quot;用户表&quot;</span>    <span class="comment"># 名称复数形式</span></span><br><span class="line">        ordering = [<span class="string">&quot;sex&quot;</span>]       <span class="comment"># 对象的默认顺序，用于获取对象列表时</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name      <span class="comment"># 返回字段值</span></span><br></pre></td></tr></table></figure>
<h2 id="模型类常用字段与选项">模型类常用字段与选项</h2>
<p><img src="/images/39F2E7BC69F94D24A8035EA24A03A813clipboard.png" alt></p>
<p><img src="/images/26C7AB78197542B2A11754111D6ABC5Cclipboard.png" alt></p>
<h2 id="QuerySet对象序列化">QuerySet对象序列化</h2>
<p>序列化：将Python对象转为传输的数据格式，例如json</p>
<p>反序列化：将传输的数据格式转为Python对象</p>
<p>ORM查询返回的是QuerySet对象，如果你要提供数据接口，这显然是不行的。</p>
<p>有两种方法可以转为JSON字符串：</p>
<ul>
<li>
<p>使用内建函数 serializers</p>
</li>
<li>
<p>遍历QuerySet对象将字段拼接成字典，再通过json库编码</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> serializers</span><br><span class="line">obj = User.objects.<span class="built_in">all</span>()</span><br><span class="line">data = serializers.serialize(<span class="string">&#x27;json&#x27;</span>, obj)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">obj = User.objects.<span class="built_in">all</span>()</span><br><span class="line">l = [] <span class="comment"># [&#123;&#125;,&#123;&#125;]</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    d[<span class="string">&#x27;name&#x27;</span>] = i.name</span><br><span class="line">    d[<span class="string">&#x27;user&#x27;</span>] = i.user</span><br><span class="line">    d[<span class="string">&#x27;sex&#x27;</span>] = i.sex</span><br><span class="line">    d[<span class="string">&#x27;age&#x27;</span>] = i.age</span><br><span class="line">    d[<span class="string">&#x27;label&#x27;</span>] = i.label</span><br><span class="line">    l.append(d)</span><br><span class="line">json_data = json.dumps(l)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django-session管理</title>
    <url>/2024/03/09/django-session%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="Session与Cookie是什么">Session与Cookie是什么</h2>
<p>就像你去电商平台购物一样，而网站采用是HTTP协议，它本身就是一个无状态的，是记不住你上次来做了什 么事，那怎么记住每个用户呢。 于是，服务器给每个用户贴了一个小纸条，上面记录了服务器给我们返回的一些信息。然后服务器看到这张 小纸条就知道我们是谁了。</p>
<p>这个小纸条就是Cookie。那么Cookie怎么工作的呢？</p>
<ol>
<li>
<p>浏览器第一次访问服务器时，服务器此时肯定不知道它的身份，所以创建一个独特的身份标识数据，格式 为key=value，放入到Set-Cookie字段里，随着响应报文发给浏览器。</p>
</li>
<li>
<p>浏览器看到有Set-Cookie字段以后就知道这是服务器给的身份标识，于是就保存起来，下次请求时会自动 将此key=value值放入到Cookie字段中发给服务器。</p>
</li>
<li>
<p>服务器收到请求报文后，发现Cookie字段中有值，就能根据此值识别用户的身份然后提供个性化的服务。</p>
</li>
</ol>
<p><img src="/images/A58506BB21654F168E25E8CDD282D8BBclipboard.png" alt></p>
<p>有了Cookie实现了有状态这一需求，那为什么又来一个Session呢？</p>
<p>试想一下，如果将用户账户的一些信息都存入Cookie中的话，一旦信息被拦截，那么所有的账户信息都会可 能被泄露丢，这是不安全的。所以就出现了Session，在一次会话中将重要信息保存在Session中，浏览器只 记录SessionId一个SessionId对应一次会话请求。</p>
<p><img src="/images/03FEC9F09E124736A7B565F47EA77B14clipboard.png" alt></p>
<h2 id="Django使用Session">Django使用Session</h2>
<p><img src="/images/D9F464FD6C3146F0B594B3F3A1D62825clipboard.png" alt></p>
<p>在settings.py配置文件中设置客户端Cookie：</p>
<p><img src="/images/2FEA9AB36A324D2D8A83687F9259DA4Cclipboard.png" alt></p>
<p>在视图中操作Session：</p>
<p><img src="/images/9D68E45CBCFF409799617704627C3AEDclipboard.png" alt></p>
<h2 id="自己实现用户登录认证">自己实现用户登录认证</h2>
<p>案例：自己实现登录认证机制</p>
<ol>
<li>
<p>登录</p>
</li>
<li>
<p>视图验证登录</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> devops2.user_login <span class="keyword">import</span> login_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_decorator  </span><span class="comment">#自定义认证登录装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method ==<span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        ###############内置认证机制################</span></span><br><span class="line"><span class="string">        #验证用户</span></span><br><span class="line"><span class="string">        user = auth.authenticate(username=username,password=password)  #验证通过返回用户名，否则返回None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        if user:</span></span><br><span class="line"><span class="string">            auth.login(request,user)  #将request与用户对象（包含session）传给login()函数</span></span><br><span class="line"><span class="string">            request.session[&#x27;username&#x27;] = username  #往session临时存储数据</span></span><br><span class="line"><span class="string">            return redirect(&#x27;/&#x27;)   #跳转到首页</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            msg = &#x27;用户名或密码错误&#x27;</span></span><br><span class="line"><span class="string">            return render(request,&#x27;login.html&#x27;,&#123;&#x27;msg&#x27;:msg&#125;)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#自定义用户认证</span></span><br><span class="line"></span><br><span class="line">        user_obj = User.objects.get(user=username)</span><br><span class="line">        <span class="keyword">if</span> user_obj.user:</span><br><span class="line">            <span class="keyword">if</span> user_obj.password == password:</span><br><span class="line">                request.session[<span class="string">&#x27;is_login&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">                request.session[<span class="string">&#x27;username&#x27;</span>] = username</span><br><span class="line">                <span class="keyword">return</span> redirect(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                msg = <span class="string">&#x27;用户名或密码错误!&#x27;</span></span><br><span class="line">                <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>, &#123;<span class="string">&#x27;msg&#x27;</span>: msg&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">&#x27;用户名或密码错误!&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>, &#123;<span class="string">&#x27;msg&#x27;</span>: msg&#125;)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>退出登录</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logout</span>(<span class="params">request</span>):</span><br><span class="line">    request.session.flush()</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/login&#x27;</span>)   <span class="comment">#跳转到登录页</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>装饰器</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#登录装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">request</span>):</span><br><span class="line">        is_login = request.session.get(<span class="string">&#x27;is_login&#x27;</span>,<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> is_login:</span><br><span class="line">            <span class="keyword">return</span> func(request)  <span class="comment">#执行原函数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django-url路由系统</title>
    <url>/2024/03/02/django-url%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="URL路由系统是什么">URL路由系统是什么</h2>
<p>简而言之，路由系统就是URL路径和视图函数的一个对应关系，也可以称为转发器。</p>
<h2 id="URL配置">URL配置</h2>
<p>URL路由系统格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># devops/urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(regex, view, kwargs=<span class="literal">None</span>, name=<span class="literal">None</span>)</span><br><span class="line">]   </span><br></pre></td></tr></table></figure>
<p>urlpatterns：一个列表，每一个path()函数是一个元素，对应一个视图</p>
<p>参数：</p>
<ul>
<li>
<p>regex：一个字符串或者正则表达式，匹配URL</p>
</li>
<li>
<p>view：对应一个函数视图或者类视图（as_view()的结果），必须返回一个HttpResponse对象，Django将这个 对象转换成一个HTTP响应</p>
</li>
<li>
<p>kwargs：可选，字典形式数据传递给对应视图</p>
</li>
<li>
<p>name：可选，URL名称</p>
</li>
</ul>
<h2 id="URL路由分发">URL路由分发</h2>
<p><img src="/images/D0A118729148494DB15656ECF74A4B9Eclipboard.png" alt></p>
<p>URL路由分发好处：urls配置解耦，方便管理</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># devops/urls.py</span></span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views <span class="keyword">as</span> myapp_views</span><br><span class="line"></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    path(<span class="string">&#x27;index&#x27;</span>, views.index), </span><br><span class="line">    path(<span class="string">&#x27;myapp/&#x27;</span>, include(<span class="string">&#x27;myapp_views.urls&#x27;</span>)), </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># myapp/urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;hello&quot;</span>, views.hello)</span><br><span class="line">]  </span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://127.0.0.1:8000/myapp/hello">http://127.0.0.1:8000/myapp/hello</a></p>
<h2 id="URL正则表达式匹配">URL正则表达式匹配</h2>
<p>URL路径也可以使用正则表达式匹配，re_path()替代path()</p>
<p>示例：博客文章归档访问形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path </span><br><span class="line"><span class="keyword">from</span> devops <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    re_path(<span class="string">&#x27;articles/2020/$&#x27;</span>, views.specified_2020), </span><br><span class="line">    re_path(<span class="string">&#x27;^articles/([0-9]&#123;4&#125;)/$&#x27;</span>, views.year_archive), </span><br><span class="line">    re_path(<span class="string">&#x27;^articles/([0-9]&#123;4&#125;)/([0-9]&#123;2&#125;)/$&#x27;</span>, views.month_archive), </span><br><span class="line">    re_path(<span class="string">&#x27;^articles/([0-9]&#123;4&#125;)/([0-9]&#123;2&#125;)/([0-9]+)/$&#x27;</span>, views.article_detail),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>视图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">specified_2020</span>(<span class="params">request</span>): </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;指定2020年 文章列表&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">year_archive</span>(<span class="params">request, year</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;%s年 文章列表&quot;</span> % year)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">month_archive</span>(<span class="params">request, year, month</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;%s年/%s月 文章列表&quot;</span> % (year, month))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">article_detail</span>(<span class="params">request, year, month, <span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;%s年/%s月 文章ID: %s&quot;</span> %(year, month, <span class="built_in">id</span>))   </span><br></pre></td></tr></table></figure>
<p>命名分组语法：(?P<name>pattern) 其中name是名称，pattern是匹配的正则表达式</name></p>
<p>示例：博客文章归档访问形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path </span><br><span class="line"><span class="keyword">from</span> devops <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    re_path(<span class="string">&#x27;articles/2020/$&#x27;</span>, views.specified_2020), </span><br><span class="line">    re_path(<span class="string">&#x27;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$&#x27;</span>, views.year_archive),</span><br><span class="line">    re_path(<span class="string">&#x27;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/$&#x27;</span>, views.month_archive),</span><br><span class="line">    re_path(<span class="string">&#x27;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;id&gt;[0-9]+)/$&#x27;</span>, views.article_detail),</span><br><span class="line">]    </span><br></pre></td></tr></table></figure>
<h2 id="URL名称">URL名称</h2>
<p>在前端代码里经常会指定URL，例如超链接，提交表单等，这时用URL反查就方便多了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">之前：</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/hello&quot;</span>&gt;</span>您好<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">之后：</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;hello&#x27; %&#125;&quot;</span>&gt;</span>您好<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django基本使用</title>
    <url>/2024/03/01/django%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Django-是什么">Django 是什么</h2>
<p>Django是Python的一个主流Web框架，提供一站式解决方案，开发成本低，内建ORM、数据管理后台、登录 认证、表单、RESTAPI等功能，适合开发中大型项目。</p>
<p>其他Web框架：</p>
<ul>
<li>
<p>Flask（轻量级）</p>
</li>
<li>
<p>Tornado（异步）</p>
</li>
</ul>
<p>官方文档：<a href="https://docs.djangoproject.com/zh-hans">https://docs.djangoproject.com/zh-hans</a></p>
<h2 id="安装Django">安装Django</h2>
<p>安装Django：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install django==<span class="number">3.2</span> -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<h2 id="创建项目、创建应用">创建项目、创建应用</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、创建项目 </span><br><span class="line">django-admin startproject devops </span><br><span class="line"><span class="number">2</span>、创建应用 </span><br><span class="line">python manage.py startapp myapp </span><br><span class="line"><span class="number">3</span>、运行项目 </span><br><span class="line">python manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8888</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/6AB0E23D5A9B417392400B1F235AAC00clipboard.png" alt></p>
<p><img src="/images/E48D50A108DB4F39A70574E763CAA14Cclipboard.png" alt></p>
<h2 id="牛刀小试：第一个页面、第二个页面">牛刀小试：第一个页面、第二个页面</h2>
<p>1、添加URL路由</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># devops/urls.py </span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin </span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path </span><br><span class="line"><span class="keyword">from</span> devops <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;index&#x27;</span>, views.index),  <span class="comment"># /index访问</span></span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>2、添加视图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># devops/views.py </span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse <span class="comment"># 导入处理响应模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>): </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;首页&quot;</span>)    </span><br></pre></td></tr></table></figure>
<p><img src="/images/989D29361F7B4AC5A3FD70B9D366AC4Eclipboard.png" alt></p>
<p>案例：网页展示日志文件</p>
<p>1、添加URL路由</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># devops/urls.py </span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin </span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path </span><br><span class="line"><span class="keyword">from</span> devops <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    path(<span class="string">&#x27;index&#x27;</span>, views.index), </span><br><span class="line">    path(<span class="string">&#x27;logs&#x27;</span>, views.logs), </span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>2、添加视图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># devops/views.py </span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render </span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>): </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;首页&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logs</span>(<span class="params">request</span>): </span><br><span class="line">    <span class="keyword">import</span> os </span><br><span class="line">    current_dir = os.path.dirname(os.path.abspath(__file__)) </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(current_dir + <span class="string">&#x27;\\access.log&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        result = f.read()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;logs.html&quot;</span>, &#123;<span class="string">&quot;result&quot;</span>: result&#125;)    </span><br></pre></td></tr></table></figure>
<p>3、创建HTML模板</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># devops/templates/logs.html</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>日志<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Nginx访问日志<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;&#123; result &#125;&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Django工作流程">Django工作流程</h2>
<p><img src="/images/E957DE8062AC4E7FB138DFBCA17393B2clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django-webssh实现</title>
    <url>/2024/09/23/django-webssh%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="实现思路">实现思路</h2>
<p>要想实现类似SSH终端功能并非易事，主要难点在于页面与连接的目标是实时交互的。说起实时交互，相信大家都有接触过，例如qq、微信、在线客服这些都是，像一些网页版的在线聊天系统常用的实现方案就是websocket。</p>
<p>WebSocket协议与HTTP的主要区别：HTTP是无状态协议，由客户端发起请求，客户端与服务器“一问一答”，因此服务器端无法主动向客户端发送信息。而WebSocket是基于TCP长连接的协议，客户端与服务器建立连接后，服务器端随时能向客户端发送信息。</p>
<p>WebSocket协议的主要价值在于其与HTTP的差异（服务器端与客户端能够保持实时的双向通信），使其在某些应用情景下比HTTP更能满足技术需求。</p>
<p>Django Web框架实现WebSocket主要有两种方式：channels和dwebsocket。</p>
<p>Channels是针对Django项目的一个增强框架，使得Django不仅支持HTTP协议，还能支持WebSocket协议。</p>
<p>为了更好的模拟shell终端，还需要一个前端库xterm.js ，这是一个比较成熟的shell终端模拟库，目前大部分公司实现的webssh都是用的这个。</p>
<p>官网：<a href="https://xtermjs.org/">https://xtermjs.org/</a></p>
<h2 id="所需技术">所需技术</h2>
<ul>
<li>channels: 是Django的扩展模块，用于处理WebSocket。</li>
<li>xterm.js：前端模拟 shell 终端的一个库</li>
<li>paramiko：python下对 ssh2 封装的一个库</li>
<li>channels_redis: 使用redis作为存储，维护不同消息传递。</li>
</ul>
<h2 id="具体实现">具体实现</h2>
<ol>
<li>xterm.js 在浏览器端模拟 shell 终端, 监听用户输入通过 websocket 将用户输入的内容上传到 django</li>
<li>django 接受到用户上传的内容, 将用户在前端页面输入的内容通过 paramiko 建立的 ssh 通道上传到远程服务器执行</li>
<li>paramiko 将远程服务器的处理结果返回给 django</li>
<li>django 将 paramiko 返回的结果通过 websocket 返回给用户</li>
<li>xterm.js 接收 django 返回的数据并将其写入前端页面</li>
</ol>
<p><img src="/images/image-20240923204539855.png" alt></p>
<h3 id="前端（vue">前端（vue)</h3>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install xterm</span><br></pre></td></tr></table></figure>
<p>前端页面：devops_web/src/views/server/TerminalCreate.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;el-dialog</span><br><span class="line">          :model-value=&quot;visible&quot;</span><br><span class="line">          title=&quot;终端&quot;</span><br><span class="line">          @close=&quot;dialogClose&quot;</span><br><span class="line">          width=&quot;80%&quot;</span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line">     &lt;el-form :model=&quot;form&quot; ref=&quot;formRef&quot; :rules=&quot;formRules&quot; label-width=&quot;100px&quot;&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;SSH IP&quot; prop=&quot;ssh_ip&quot;&gt; &lt;!-- pod 名称输入框 --&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;form.ssh_ip&quot; /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;SSH 端口&quot; prop=&quot;ssh_port&quot;&gt; &lt;!-- pod 名称输入框 --&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;form.ssh_port&quot; /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt; &lt;!-- namespace 输入框 --&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;form.username&quot; /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;!-- pod 名称输入框 --&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;form.password&quot; /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">        &lt;div id=&quot;terminal&quot; /&gt; &lt;!-- 终端视图容器 --&gt;</span><br><span class="line">      &lt;/el-form&gt;</span><br><span class="line"></span><br><span class="line">      &lt;template #footer&gt;</span><br><span class="line">        &lt;span class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">          &lt;el-button @click=&quot;dialogClose&quot;&gt;取消&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;连接&lt;/el-button&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/el-dialog&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; Terminal &#125; from &#x27;xterm&#x27; // 导入 xterm 包，用于创建和操作终端对象</span><br><span class="line">    import &#123; common as xtermTheme &#125; from &#x27;xterm-style&#x27; // 导入 xterm 样式主题</span><br><span class="line">    import &#x27;xterm/css/xterm.css&#x27; // 导入 xterm CSS 样式</span><br><span class="line">    import &#123; FitAddon &#125; from &#x27;xterm-addon-fit&#x27; // 导入 xterm fit 插件，用于调整终端大小</span><br><span class="line">    import &#123; WebLinksAddon &#125; from &#x27;xterm-addon-web-links&#x27; // 导入 xterm web-links 插件，可以捕获 URL 并将其转换为可点击链接</span><br><span class="line">    import &#x27;xterm/lib/xterm.js&#x27; // 导入 xterm 库</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Terminal&quot;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            visible: Boolean,</span><br><span class="line">            row: &#x27;&#x27;,  // 当前行内容</span><br><span class="line">        &#125;,</span><br><span class="line">          data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">              xterm: &#x27;&#x27;,</span><br><span class="line">              form: &#123;</span><br><span class="line">                username: &#x27;&#x27;, // 默认命名空间为 &quot;default&quot;</span><br><span class="line">                password: &#x27;&#x27;, // 默认 shell 命令为 &quot;bash&quot;</span><br><span class="line">                ssh_ip: &#x27;&#x27;,</span><br><span class="line">                ssh_port: &#x27;&#x27;,</span><br><span class="line">              &#125;,</span><br><span class="line">              formRules: &#123;</span><br><span class="line">                  username: [</span><br><span class="line">                      &#123;required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27;&#125;,</span><br><span class="line">                  ],</span><br><span class="line">                  password: [</span><br><span class="line">                      &#123;required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27;&#125;,</span><br><span class="line">                  ],</span><br><span class="line">                  ssh_ip: [</span><br><span class="line">                      &#123;required: true, message: &#x27;请输入SSH IP地址&#x27;, trigger: &#x27;blur&#x27;&#125;,</span><br><span class="line">                  ],</span><br><span class="line">                  ssh_port: [</span><br><span class="line">                      &#123;required: true, message: &#x27;请输入SSH端口&#x27;, trigger: &#x27;blur&#x27;&#125;,</span><br><span class="line">                  ],</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">          onRest()&#123;</span><br><span class="line">            this.$refs.formRef.resetFields();</span><br><span class="line">          &#125;,</span><br><span class="line">           dialogClose() &#123;</span><br><span class="line">                this.$emit(&#x27;update:visible&#x27;, false);  // 当对话框关闭，通过父组件更新为false</span><br><span class="line">                this.onRest(); //重置表单</span><br><span class="line">                window.location.reload();</span><br><span class="line">              &#125;,</span><br><span class="line">            onSubmit() &#123;</span><br><span class="line">              // 创建一个新的 Terminal 对象</span><br><span class="line">                this.xterm = new Terminal(&#123;</span><br><span class="line">                theme: xtermTheme,  //背景色</span><br><span class="line">                rendererType: &#x27;canvas&#x27;, //渲染类型</span><br><span class="line">                convertEol: true, //启用时，光标将设置为下一行的开头</span><br><span class="line">                cursorBlink: true,  //光标闪烁</span><br><span class="line">              &#125;)</span><br><span class="line"></span><br><span class="line">              // 创建并加载 FitAddon 和 WebLinksAddon</span><br><span class="line">               const fitAddon = new FitAddon()</span><br><span class="line">               this.xterm.loadAddon(fitAddon)</span><br><span class="line">               this.xterm.loadAddon(new WebLinksAddon())</span><br><span class="line"></span><br><span class="line">              // 打开这个终端，并附加到 HTML 元素上</span><br><span class="line">              this.xterm.open(document.getElementById(&#x27;terminal&#x27;))</span><br><span class="line"></span><br><span class="line">              // 调整终端的大小以适应其父元素</span><br><span class="line">               fitAddon.fit()</span><br><span class="line"></span><br><span class="line">              // 创建一个新的 WebSocket 连接，并通过 URL 参数传递 pod, namespace, container 和 command 信息</span><br><span class="line">              const ws = new WebSocket(`ws://$&#123;process.env.VUE_APP_API_HOST&#125;:$&#123;process.env.VUE_APP_API_PORT&#125;/webssh/?host_ip=$&#123;this.form.ssh_ip&#125;&amp;host_port=$&#123;this.form.ssh_port&#125;&amp;sys_user_name=$&#123;this.form.username&#125;&amp;sys_user_passwd=$&#123;this.form.password&#125;`);</span><br><span class="line"></span><br><span class="line">              // 当 WebSocket 连接打开时，发送一个 resize 消息给服务器，告诉它终端的尺寸</span><br><span class="line">              ws.onopen = () =&gt; &#123;</span><br><span class="line">                ws.send(JSON.stringify(&#123;</span><br><span class="line">                  type: &#x27;resize&#x27;,</span><br><span class="line">                  rows: this.xterm.rows,</span><br><span class="line">                  cols: this.xterm.cols</span><br><span class="line">                &#125;))</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              // 当从服务器收到消息时，写入终端显示</span><br><span class="line">              ws.onmessage = (evt) =&gt; &#123;</span><br><span class="line">                // console.log(evt.data)</span><br><span class="line">                this.xterm.write(evt.data)</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              // 当发生错误时，也写入终端显示</span><br><span class="line">              ws.onerror = (evt) =&gt; &#123;</span><br><span class="line">                this.xterm.write(evt.data)</span><br><span class="line">              &#125;</span><br><span class="line">              ws.onclose = (evt) =&gt; &#123;</span><br><span class="line">                  this.xterm.write(&#x27;\n\r\x1B[1;3;31m连接关闭！\x1B[0m&#x27;);</span><br><span class="line">               &#125;;</span><br><span class="line"></span><br><span class="line">              // 当窗口尺寸变化时，重新调整终端的尺寸，并发送一个新的 resize 消息给服务器</span><br><span class="line">              window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123;</span><br><span class="line">                fitAddon.fit()</span><br><span class="line">                ws.send(JSON.stringify(&#123;</span><br><span class="line">                  type: &#x27;resize&#x27;,</span><br><span class="line">                  rows: this.xterm.rows,</span><br><span class="line">                  cols: this.xterm.cols</span><br><span class="line">                &#125;))</span><br><span class="line">              &#125;)</span><br><span class="line"></span><br><span class="line">              // 当在终端中键入字符时，发送一个 input 消息给服务器</span><br><span class="line">              this.xterm.onData((data) =&gt; &#123;</span><br><span class="line">                // console.log(data)</span><br><span class="line">                // xterm.write(data);  //写入终端</span><br><span class="line">                ws.send(JSON.stringify(&#123;</span><br><span class="line">                  type: &#x27;input&#x27;,</span><br><span class="line">                  text: data</span><br><span class="line">                &#125;))</span><br><span class="line">              &#125;)</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="服务端（Django-Channels">服务端（Django Channels)</h3>
<p>安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install channels==<span class="number">2.4</span><span class="number">.0</span></span><br><span class="line">pip install channels_redis</span><br><span class="line">pip install paramiko</span><br></pre></td></tr></table></figure>
<p>在settings.py文件中注册channels</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;channels&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">ASGI_APPLICATION = <span class="string">&#x27;devops.routing.application&#x27;</span></span><br></pre></td></tr></table></figure>
<p>devops_api/devops_api/asgi.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ASGI config for devops_api project.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It exposes the ASGI callable as a module-level variable named ``application``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information on this files, see</span></span><br><span class="line"><span class="string">https://docs.djangoproject.com/en/3.2/howto/deployment/asgi/</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.core.asgi <span class="keyword">import</span> get_asgi_application</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;devops_api.settings&#x27;</span>)</span><br><span class="line"></span><br><span class="line">application = get_asgi_application()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="配置路由">配置路由</h3>
<p>devops_api/devops_api/routing.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> channels.auth <span class="keyword">import</span> AuthMiddlewareStack</span><br><span class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> ProtocolTypeRouter, URLRouter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"><span class="keyword">from</span> devops_api.consumers <span class="keyword">import</span> SSHConsumer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果是 WebSocket 连接 (ws://或 wss://), 则连接会交给 AuthMiddlewareStack验证去请求对象，然后连接将被给到 URLRouter</span></span><br><span class="line">application = ProtocolTypeRouter(&#123;</span><br><span class="line"><span class="comment"># &#x27;http&#x27;: # 普通的HTTP请求不需要我们手动在这里添加，框架会自动加载</span></span><br><span class="line"><span class="comment"># 用于WebSocket认证</span></span><br><span class="line">    <span class="string">&#x27;websocket&#x27;</span>: AuthMiddlewareStack(</span><br><span class="line">        <span class="comment"># 用于WebSocket认证</span></span><br><span class="line">        URLRouter([</span><br><span class="line">        <span class="comment"># URL路由匹配,访问webssh的时候，交给SSHConsumer处理</span></span><br><span class="line">            re_path(<span class="string">r&#x27;^webssh/&#x27;</span>, SSHConsumer),</span><br><span class="line">        ])</span><br><span class="line">    ),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="websocket服务端消费">websocket服务端消费</h3>
<p>devops_api/devops_api/consumers.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#import websocket</span></span><br><span class="line"><span class="keyword">from</span> channels.generic.websocket <span class="keyword">import</span> WebsocketConsumer</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> asgiref.sync <span class="keyword">import</span> async_to_sync</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamConsumer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, websocket</span>):</span><br><span class="line">        self.websocket = websocket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self,host_ip,host_port,sys_user_name,sys_user_passwd,term=<span class="string">&#x27;xterm&#x27;</span>,cols=<span class="number">150</span>, rows=<span class="number">42</span></span>):</span><br><span class="line">        <span class="comment">#实例化SSHClient</span></span><br><span class="line">        ssh_client = paramiko.SSHClient()</span><br><span class="line">        <span class="comment">#当远程服务器没有本地主机的密钥时自动添加到本地，这样不用在建立连接的时候输入yes或no进行确认</span></span><br><span class="line">        ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment">#连接ssh服务器，这里是以账号密码方式进行确认</span></span><br><span class="line">            ssh_client.connect(host_ip,host_port,sys_user_name,sys_user_passwd,timeout=<span class="number">10</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;连接成功&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            message  = <span class="built_in">str</span>(e)</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="comment">#self.websocket.send是服务端给客户端发送消息</span></span><br><span class="line">            self.websocket.send(message)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;连接失败&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#打开ssh通道，建立长连接</span></span><br><span class="line">        transport = ssh_client.get_transport()</span><br><span class="line">        <span class="comment">#建立会话session</span></span><br><span class="line">        self.ssh_channel = transport.open_session()</span><br><span class="line">        <span class="comment">#获取终端，并设置term和终端大小,width终端宽度，height终端高度</span></span><br><span class="line">        self.ssh_channel.get_pty(term=term,width=cols,height=rows)</span><br><span class="line">        <span class="comment">#激活终端，这样就可以正常登录了</span></span><br><span class="line">        self.ssh_channel.invoke_shell()</span><br><span class="line">        msg = <span class="string">f&quot;开始连接到<span class="subst">&#123;sys_user_name&#125;</span>@<span class="subst">&#123;host_ip&#125;</span> \r\n&quot;</span></span><br><span class="line">        self.websocket.send(msg)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">            mess = self.ssh_channel.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>,<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">            message = json.dumps(&#123;<span class="string">&#x27;flag&#x27;</span>: <span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;message&#x27;</span>: mess&#125;)</span><br><span class="line">            self.send_to_ws_mes(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#断开websocket和关闭ssh通道</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.websocket.close()</span><br><span class="line">            self.ssh_channel.close()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#发送消息到ws</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_to_ws_mes</span>(<span class="params">self,event</span>):</span><br><span class="line">        <span class="comment">#字符串转换字典</span></span><br><span class="line">        text_data = json.loads(event)</span><br><span class="line">        message = text_data[<span class="string">&#x27;message&#x27;</span>]</span><br><span class="line">        self.websocket.send(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#从websocket接收的数据发送到ssh</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_ws_to_ssh</span>(<span class="params">self,data</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.ssh_channel.send(data)</span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">            self.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#ssh返回的数据输出给websocket</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_ssh_to_ws</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.ssh_channel.exit_status_ready():</span><br><span class="line">                <span class="comment">#需要转码为utf-8形式</span></span><br><span class="line">                data = self.ssh_channel.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">                message = &#123;<span class="string">&#x27;flag&#x27;</span>: <span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;message&#x27;</span>: data&#125;</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(data) != <span class="number">0</span>:</span><br><span class="line">                    self.send_to_ws_mes(json.dumps(message))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            message = &#123;<span class="string">&#x27;flag&#x27;</span>: <span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;message&#x27;</span>: <span class="built_in">str</span>(e)&#125;</span><br><span class="line">            self.send_to_ws_mes(json.dumps(message))</span><br><span class="line">            self.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shell</span>(<span class="params">self, data</span>):</span><br><span class="line">        Thread(target=self._ws_to_ssh, args=(data,)).start()</span><br><span class="line">        Thread(target=self._ssh_to_ws).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#前端传过来的数据会加个flag，如果flag是resize，则调用resize_pty方法来动态调整窗口的大小，否则就正常调用执行命令的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">resize_pty</span>(<span class="params">self, cols, rows</span>):</span><br><span class="line">        self.ssh_channel.resize_pty(width=cols, height=rows)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承WebsocketConsumer 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SSHConsumer</span>(<span class="title class_ inherited__">WebsocketConsumer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 有客户端来向后端发起websocket连接的请求时，自动触发</span></span><br><span class="line">        host_info = self.scope[<span class="string">&quot;query_string&quot;</span>].decode()  <span class="comment"># b&#x27;auth_type=kubeconfig&amp;token=7402e616e80cc5d9debe66f31b7a8ed6&#x27;</span></span><br><span class="line">        self.host_ip = host_info.split(<span class="string">&#x27;&amp;&#x27;</span>)[<span class="number">0</span>].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#self.host_name = host_info.split(&#x27;&amp;&#x27;)[1].split(&#x27;=&#x27;)[1]</span></span><br><span class="line">        self.host_port = host_info.split(<span class="string">&#x27;&amp;&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        self.sys_user_name = host_info.split(<span class="string">&#x27;&amp;&#x27;</span>)[<span class="number">2</span>].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        self.sys_user_passwd = host_info.split(<span class="string">&#x27;&amp;&#x27;</span>)[<span class="number">3</span>].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#accept表示服务端允许和客户端创建连接.</span></span><br><span class="line">        self.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.ssh = StreamConsumer(websocket=self)</span><br><span class="line">        self.ssh.connect(self.host_ip,self.host_port,self.sys_user_name,self.sys_user_passwd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">disconnect</span>(<span class="params">self, close_code</span>):</span><br><span class="line">        <span class="comment">#客户端与服务端断开连接时，自动触发（客户端断开，服务端也得断开）</span></span><br><span class="line">        self.ssh.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">receive</span>(<span class="params">self, text_data=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment">#浏览器基于websocket向后端发送数据，自动触发接收消息。</span></span><br><span class="line">        <span class="comment">#text_data是从客户端端(websocket)接收到的消息</span></span><br><span class="line">        text_data = json.loads(text_data) <span class="comment">#str转换为dict</span></span><br><span class="line">        <span class="comment"># print(text_data)</span></span><br><span class="line">        <span class="keyword">if</span> text_data.get(<span class="string">&#x27;flag&#x27;</span>) == <span class="string">&#x27;resize&#x27;</span>: <span class="comment">#如果为resize是改变终端通道的大小</span></span><br><span class="line">            self.ssh.resize_pty(cols=text_data[<span class="string">&#x27;cols&#x27;</span>], rows=text_data[<span class="string">&#x27;rows&#x27;</span>])</span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#否则正常执行命令</span></span><br><span class="line">            data = text_data.get(<span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            self.ssh.shell(data=data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="配置channels存储">配置channels存储</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name redis -d -p 6379:6379 redis:5</span><br></pre></td></tr></table></figure>
<p>在settings.py配置文件添加redis配置，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CHANNEL_LAYERS = &#123;</span><br><span class="line">    <span class="comment"># 真实上线使用redis</span></span><br><span class="line">    <span class="comment"># &#x27;default&#x27;: &#123;</span></span><br><span class="line">    <span class="comment">#     &#x27;BACKEND&#x27;: &#x27;channels_redis.core.RedisChannelLayer&#x27;,</span></span><br><span class="line">    <span class="comment">#     &#x27;CONFIG&#x27;: &#123;</span></span><br><span class="line">    <span class="comment">#         &quot;hosts&quot;: [(&#x27;127.0.0.1&#x27;, 6379)],  # 需修改redis的地址</span></span><br><span class="line">    <span class="comment">#     &#125;,</span></span><br><span class="line">    <span class="comment"># &#125;,</span></span><br><span class="line">    <span class="comment"># 测试阶段，放到内存中即可</span></span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;channels.layers.InMemoryChannelLayer&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>用户打开浏览器–》浏览器发送websocket请求给Django建立长连接–》Django与要操作的服务器建立SSH通道，实时的将收到的用户数据发送给SSH后的主机，并将主机执行的结果数据返回给浏览器。</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django模板系统</title>
    <url>/2024/03/04/django%E6%A8%A1%E6%9D%BF%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="模板是什么">模板是什么</h2>
<p>Django模板系统：用于自动渲染一个文本文件，一般用于HTML页面。模板引擎渲 染的最终HTML内容返回给客户端浏览器。</p>
<p>模板文件有两部分组成：</p>
<ul>
<li>
<p>静态部分，例如html、css、js</p>
</li>
<li>
<p>动态部分，django模板语言，类似于jinja语法</p>
</li>
</ul>
<h2 id="变量">变量</h2>
<p>变量定义：在函数视图render中的context传入，类似于字典对象。</p>
<p>变量在模板中引用，格式：</p>
<p>注释：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# 注释内容 #&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">request</span>):</span><br><span class="line">    user = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;阿三&#x27;</span>, <span class="string">&#x27;property&#x27;</span>: &#123;<span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;user.html&#x27;</span>, &#123;<span class="string">&#x27;user&#x27;</span>: user&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>用户信息<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">传递过来的字典: &#123;&#123; user &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">姓名: &#123;&#123; user.name &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">性别: &#123;&#123; user.property.sex &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">年龄: &#123;&#123; user.property.age &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="标签">标签</h2>
<h3 id="标签：条件判断">标签：条件判断</h3>
<p><img src="/images/4A6CD91D015F4B38AF28E8B542D95E33clipboard.png" alt></p>
<p>if条件判断：判定给定的条件是否满足（True或False），根据判断的结果决定执行的语句。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">语法： </span><br><span class="line">&#123;% if <span class="tag">&lt;<span class="name">表达式</span>&gt;</span> %&#125; </span><br><span class="line">    <span class="tag">&lt;<span class="name">内容块</span>&gt;</span> </span><br><span class="line">&#123;% elif <span class="tag">&lt;<span class="name">表达式</span>&gt;</span> %&#125; </span><br><span class="line">    <span class="tag">&lt;<span class="name">内容块</span>&gt;</span> </span><br><span class="line">&#123;% else %&#125; </span><br><span class="line">    <span class="tag">&lt;<span class="name">内容块</span>&gt;</span> </span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标签：操作符">标签：操作符</h3>
<p><img src="/images/25A09402522C468EA1B35111931BD63Aclipboard.png" alt></p>
<h3 id="标签：循环">标签：循环</h3>
<p><img src="/images/C77A9F4BFB064DAEB0820DBEF1D9EAC8clipboard.png" alt></p>
<p>for循环：一般用于遍历数据类型的元素进行处理，例如列表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">语法： </span><br><span class="line">&#123;% for <span class="tag">&lt;<span class="name">变量</span>&gt;</span> in <span class="tag">&lt;<span class="name">序列</span>&gt;</span> %&#125; </span><br><span class="line">    <span class="tag">&lt;<span class="name">内容块</span>&gt;</span> </span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用过滤器">常用过滤器</h2>
<p>过滤器：在变量被显示前修改值的一种方法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">语法：&#123;&#123; value | 过滤器:参数 &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/7AAEE6ADA5D84A088C6DE3B76A250F5Aclipboard.png" alt></p>
<p>参考资料：<a href="https://docs.djangoproject.com/zh-hans/3.1/ref/templates/builtins/">https://docs.djangoproject.com/zh-hans/3.1/ref/templates/builtins/</a></p>
<h2 id="模板继承">模板继承</h2>
<p>模板继承主要是为了提高代码重用，减轻开发人员的工作量。 典型应用：网站的头部、尾部信息。</p>
<p>1、定义一个基础模板，也称为母板，这个页面存放整个网站共用的内容</p>
<p>templates/base.html</p>
<p>2、在子模板继承这个母版</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends ‘base.html’ %&#125;</span><br></pre></td></tr></table></figure>
<p>3、在基础模板预留子模板差异化内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% block 名称 %&#125; 预留区域 &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>4、在子模板里同样语法引用并填充预留区域内容</p>
<p><img src="/images/DC8CA3CCA2EF44E4A19FE93E32CF25C6clipboard.png" alt></p>
<h2 id="模板导入">模板导入</h2>
<p>模板导入：导入一个模板（一般是某个网页功能）到当前模板</p>
<p>将一个功能创建为模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># templates/hello.html</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.hello</span> &#123; </span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red; </span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    子模板</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>       </span><br></pre></td></tr></table></figure>
<p>模板导入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125; </span><br><span class="line">&#123;% block title %&#125;首页&#123;% endblock %&#125; </span><br><span class="line">&#123;% block context %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&gt;这是首页！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    &#123;% include &quot;hello.html&quot; %&#125; </span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用静态文件">引用静态文件</h2>
<p>1、在settings.py配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">&#x27;static&#x27;</span>),</span><br><span class="line">) </span><br><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注：STATICFILES_DIRS告诉Django哪个目录是“静态文件的文件夹”</p>
<p>2、在模板文件引用静态文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/static/main.css&quot;</span>&gt;</span></span><br><span class="line">或者 </span><br><span class="line">&#123;% load static %&#125; # 在模板文件开头</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;main.css&#x27; %&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django多表操作</title>
    <url>/2024/03/07/django%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="多表关系">多表关系</h2>
<p>常见的数据模型关系有：</p>
<ul>
<li>
<p>一对一(one-to-one)，OneToOneField</p>
</li>
<li>
<p>一对多，多对一(one-to-many)，ForeignKey</p>
</li>
<li>
<p>多对多（many-to-many），ManyToManyField</p>
</li>
</ul>
<h2 id="一对一">一对一</h2>
<p>一对一：一个表中的每条记录对应另一个表中的每条记录，使用OneToOneField建立关系。</p>
<p>例如：一个人对应一个身份证号，一个身份证号也对应一个人</p>
<p>应用场景：当一个表想扩展字段，最常用的方式就是在这个表添加一个对一关系</p>
<h3 id="一对一：创建模型关系">一对一：创建模型关系</h3>
<p>示例：定义一对一模型关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(models.Model):</span><br><span class="line">    user = models.CharField(max_length=<span class="number">30</span>, verbose_name=<span class="string">&quot;用户名&quot;</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>, verbose_name=<span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">    sex = models.CharField(max_length=<span class="number">30</span>, verbose_name=<span class="string">&quot;性别&quot;</span>)</span><br><span class="line">    age = models.IntegerField(verbose_name=<span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">    label = models.CharField(max_length=<span class="number">100</span>, verbose_name=<span class="string">&quot;标签&quot;</span>)</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">IdCard</span>(models.Model):</span><br><span class="line">    number = models.CharField(max_length=<span class="number">20</span>, verbose_name=<span class="string">&quot;卡号&quot;</span>)</span><br><span class="line">    address = models.CharField(max_length=<span class="number">50</span>, default=<span class="string">&quot;北京&quot;</span>)</span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE)  <span class="comment"># 定义一对一的模型关系</span></span><br></pre></td></tr></table></figure>
<h3 id="一对一：增删改查">一对一：增删改查</h3>
<p>增：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">方式<span class="number">1</span>：</span><br><span class="line">user_obj = User.objects.create(user=<span class="string">&#x27;alan&#x27;</span>,name=<span class="string">&#x27;阿兰&#x27;</span>,sex=<span class="string">&#x27;女&#x27;</span>,age=<span class="string">&#x27;25&#x27;</span>,label=<span class="string">&quot;运营,漂亮,喜欢购物&quot;</span>)</span><br><span class="line">IdCard.objects.create(user=user_obj, number=<span class="string">&quot;456789&quot;</span>, address=<span class="string">&quot;北京&quot;</span>)</span><br><span class="line">方式<span class="number">2</span>：</span><br><span class="line">user = User()</span><br><span class="line">user.user=<span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">user.name = <span class="string">&quot;阿兰&quot;</span></span><br><span class="line">user.sex = <span class="string">&#x27;女&#x27;</span></span><br><span class="line">user.age = <span class="number">25</span></span><br><span class="line">user.label = <span class="string">&quot;运营,漂亮,喜欢购物&quot;</span></span><br><span class="line">user.save()</span><br></pre></td></tr></table></figure>
<p>向已有用户添加身份证信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_obj = User.objects.get(user=<span class="string">&quot;amei&quot;</span>)</span><br><span class="line">IdCard.objects.create(user=user_obj, </span><br><span class="line">number=<span class="string">&quot;123456789&quot;</span>, address=<span class="string">&quot;北京&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>查：</p>
<p>反向查询：通过用户查到身份证信息（user-&gt;idcard）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = User.objects.get(user=<span class="string">&quot;amei&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(user.idcard.number)</span><br><span class="line"><span class="built_in">print</span>(user.idcard.address)</span><br></pre></td></tr></table></figure>
<p>正向查询：从身份证表查用户（idcard-&gt;user）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">idcard = IdCard.objects.get(user_id=<span class="number">1</span>) </span><br><span class="line"><span class="built_in">print</span>(idcard.user.user)</span><br><span class="line"><span class="built_in">print</span>(idcard.user.name)</span><br></pre></td></tr></table></figure>
<p>改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">User.objects.<span class="built_in">filter</span>(user=<span class="string">&quot;amei&quot;</span>).update(age=<span class="string">&quot;26&quot;</span>)</span><br><span class="line">user_obj = User.objects.get(user=<span class="string">&quot;amei&quot;</span>)</span><br><span class="line"><span class="comment"># 修改身份证信息</span></span><br><span class="line">user_obj.idcard.address=<span class="string">&quot;北京&quot;</span></span><br><span class="line">user_obj.idcard.save()</span><br><span class="line"><span class="comment"># 修改用户信息</span></span><br><span class="line">user_obj.age = <span class="number">24</span></span><br><span class="line">user_obj.save()</span><br></pre></td></tr></table></figure>
<p>删：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">User.objects.<span class="built_in">filter</span>(user=<span class="string">&quot;alan&quot;</span>).delete()</span><br></pre></td></tr></table></figure>
<h2 id="一对多">一对多</h2>
<p>一对一是表与表之间的关系，而一对多、多对多是表与表中数据的关系</p>
<p>一对多：A表中的某个记录对应B表中的多条记录，使用ForeignKey建立关系。</p>
<p>例如：项目部署涉及表</p>
<p>一对多：一个项目有多个应用，一个应用只能属于一个项目</p>
<p>多对多：一个应用部署到多台服务器，一个服务器部署多个应用</p>
<p><img src="/images/FA258B5EDEF8441DAEF0340F9B5A76CAclipboard.png" alt></p>
<h3 id="一对多：创建模型关系">一对多：创建模型关系</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Project</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    describe = models.CharField(max_length=<span class="number">100</span>, null=<span class="literal">True</span>)</span><br><span class="line">    datetime = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span>  self.name</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&#x27;project&#x27;</span></span><br><span class="line">        verbose_name_plural = <span class="string">&#x27;项目&#x27;</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">App</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    describe = models.CharField(max_length=<span class="number">100</span>, null=<span class="literal">True</span>)</span><br><span class="line">    datetime = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    project = models.ForeignKey(Project, on_delete=models.CASCADE) <span class="comment"># 定义一对多的模型关系</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span>  self.name</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&#x27;app&#x27;</span></span><br><span class="line">        verbose_name_plural = <span class="string">&#x27;应用&#x27;</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Server</span>(models.Model):</span><br><span class="line">    hostname = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    ip = models.GenericIPAddressField()</span><br><span class="line">    describe = models.CharField(max_length=<span class="number">100</span>, null=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span>  self.hostname</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&#x27;server&#x27;</span></span><br><span class="line">        verbose_name_plural = <span class="string">&#x27;服务器&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="一对多：增删改查">一对多：增删改查</h3>
<p>向项目表添加已知的项目名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Project.objects.create(name=<span class="string">&quot;电商项目&quot;</span>,describe=<span class="string">&quot;电商项目描述...&quot;</span>)</span><br><span class="line">Project.objects.create(name=<span class="string">&quot;在线教育项目&quot;</span>,describe=<span class="string">&quot;在线教育项目描述...&quot;</span>)</span><br><span class="line">Project.objects.create(name=<span class="string">&quot;大数据项目&quot;</span>,describe=<span class="string">&quot;大数据项目描述...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>创建新应用并加入到项目中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">project_obj = Project.objects.get(name=<span class="string">&quot;电商项目&quot;</span>)</span><br><span class="line">App.objects.create(name=<span class="string">&quot;product&quot;</span>,describe=<span class="string">&quot;商品服务&quot;</span>,project=project_obj) </span><br></pre></td></tr></table></figure>
<p>注：操作模型类记得先导入 from myapp.models import Project,App</p>
<p>正向查询：通过应用名称查询所属项目（app-&gt;project）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">查询某个应用所属项目：</span><br><span class="line">app = App.objects.get(name=<span class="string">&quot;product&quot;</span>)  <span class="comment"># 获取应用</span></span><br><span class="line">app.project.name   <span class="comment"># 根据获取的应用，查询对应项目名称</span></span><br><span class="line">查询所有应用所属项目：</span><br><span class="line">app_list = App.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> app_list:</span><br><span class="line">    <span class="built_in">print</span>(i.name, i.project.name, i.project.describe)</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">release</span>(<span class="params">request</span>):</span><br><span class="line">    app = App.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span>  render(request, <span class="string">&quot;release.html&quot;</span>, &#123;<span class="string">&quot;app&quot;</span>:app&#125;)</span><br><span class="line">    </span><br><span class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> app_list %&#125;</span><br><span class="line">    &#123;&#123; i.<span class="built_in">id</span> &#125;&#125;</span><br><span class="line">    &#123;&#123; i.name &#125;&#125;</span><br><span class="line">    &#123;&#123; i.describe &#125;&#125;</span><br><span class="line">    &#123;&#123; i.project.<span class="built_in">id</span> &#125;&#125;</span><br><span class="line">    &#123;&#123; i.project.name &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>反向查询：通过项目名称查询有哪些应用（project-&gt;app）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">查询某个项目有哪些应用：</span><br><span class="line">project = Project.objects.get(name=<span class="string">&quot;电商项目&quot;</span>) <span class="comment"># 获取项目</span></span><br><span class="line">project.app_set.<span class="built_in">all</span>()  <span class="comment"># 根据获取的项目，查询所有应用</span></span><br><span class="line"></span><br><span class="line">查询所有项目有哪些引用：</span><br><span class="line">project = Project.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> project:</span><br><span class="line">    <span class="built_in">print</span>(i.name, i.app_set.<span class="built_in">all</span>())</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">app</span>(<span class="params">request</span>):</span><br><span class="line">    project_list = Project.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;app.html&quot;</span>, &#123;<span class="string">&quot;project_list&quot;</span>: project_list&#125;)</span><br><span class="line">    </span><br><span class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> project_list %&#125;</span><br><span class="line">    &#123;&#123; i &#125;&#125;</span><br><span class="line">    &#123;% <span class="keyword">for</span> x <span class="keyword">in</span> i.app_set.<span class="built_in">all</span> %&#125;</span><br><span class="line">        &#123;&#123; x &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多对多">多对多</h2>
<p>多对多：A表中的某个记录对应B表中的多条记录，B表中的某个记录对应A表中多条记 录。使用ManyToManyField建立关系。</p>
<p>例如：一个应用部署到多台服务器，一个服务器部署多个应用</p>
<p><img src="/images/E140AF0A2CC44801BD9E13898998BD6Eclipboard.png" alt></p>
<h3 id="多对多：创建模型关系">多对多：创建模型关系</h3>
<p>示例：定义多对多模型关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>(models.Model):</span><br><span class="line">    hostname = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    ip = models.GenericIPAddressField()</span><br><span class="line">    describe = models.CharField(max_length=<span class="number">100</span>, null=<span class="literal">True</span>)</span><br><span class="line">    app = models.ManyToManyField(App)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span>  self.hostname</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&#x27;server&#x27;</span></span><br><span class="line">        verbose_name_plural = <span class="string">&#x27;服务器&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Django会自动创建一个表来管理多对多关系，称为中间表；这个中间表的名称使用多对多的 名称和包含这张表的模型的名称生成，也可以使用db_table选项指定这个中间表名称。</p>
<p><img src="/images/690C2450EBED4E568216DB16BEA43EECclipboard.png" alt></p>
<h3 id="多对多：增删改查">多对多：增删改查</h3>
<p>添加服务器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Server.objects.create(hostname=<span class="string">&quot;ec-test1&quot;</span>, ip=<span class="string">&quot;192.168.1.10&quot;</span>, describe=<span class="string">&quot;电商项目测试服务器1&quot;</span>)</span><br><span class="line">Server.objects.create(hostname=<span class="string">&quot;ec-test2&quot;</span>, ip=<span class="string">&quot;192.168.1.11&quot;</span>, describe=<span class="string">&quot;电商项目测试服务器2&quot;</span>)</span><br><span class="line">Server.objects.create(hostname=<span class="string">&quot;bigdata-test1&quot;</span>, ip=<span class="string">&quot;192.168.1.11&quot;</span>, describe=<span class="string">&quot;大数据项目测试服务器1&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>部署一个应用到指定服务器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">project_obj = Project.objects.get(name=<span class="string">&quot;电商项目&quot;</span>)</span><br><span class="line">app = App.objects.create(name=<span class="string">&quot;portal&quot;</span>,describe=<span class="string">&quot;前端服务&quot;</span>,project=project_obj)</span><br><span class="line">server = Server.objects.get(hostname=<span class="string">&quot;ec-test1&quot;</span>)</span><br><span class="line">server.app.add(app)  <span class="comment"># 将服务器关联到应用</span></span><br></pre></td></tr></table></figure>
<p>正向查询：查询服务器部署了哪些应用（server-&gt;app）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">查询某台服务器部署了哪些应用：</span><br><span class="line">server = Server.objects.get(hostname=<span class="string">&quot;ec-test1&quot;</span>)</span><br><span class="line">server.app.<span class="built_in">all</span>()</span><br><span class="line">查询所有服务器部署了哪些应用：</span><br><span class="line">server_list = Server.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> server_list:</span><br><span class="line">    <span class="built_in">print</span>(i.hostname, i.app.<span class="built_in">all</span>()) </span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">server</span>(<span class="params">request</span>):</span><br><span class="line">    server_list = Server.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;server.html&quot;</span>, &#123;<span class="string">&quot;server_list&quot;</span>: server_list&#125;)</span><br><span class="line">    </span><br><span class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> server_list %&#125;</span><br><span class="line">    &#123;&#123; i &#125;&#125;</span><br><span class="line">    &#123;% <span class="keyword">for</span> x <span class="keyword">in</span> i.app.<span class="built_in">all</span> %&#125;</span><br><span class="line">    &#123;&#123; x.name &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>反向查询：查看某个应用部署到哪些服务器，通过项目名称查询有哪些应用（app-&gt;server）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">查询某个应用部署到哪些服务器：</span><br><span class="line">app = App.objects.get(name=<span class="string">&quot;portal&quot;</span>)</span><br><span class="line">app.server_set.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line">查询所有应用部署到哪些服务器：</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> app_list:</span><br><span class="line">    <span class="built_in">print</span>(i.name, i.server_set.<span class="built_in">all</span>())</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">app_server</span>(<span class="params">request</span>):</span><br><span class="line">     app_list = App.objects.<span class="built_in">all</span>()</span><br><span class="line">     <span class="keyword">return</span> render(request, <span class="string">&quot;app.html&quot;</span>, &#123;<span class="string">&quot;app_list&quot;</span>: app_list&#125;)</span><br><span class="line">     </span><br><span class="line"> &#123;% <span class="keyword">for</span> i <span class="keyword">in</span> app_list %&#125;</span><br><span class="line">     &#123;&#123; i &#125;&#125;</span><br><span class="line">     &#123;% <span class="keyword">for</span> x <span class="keyword">in</span> i.server_set.<span class="built_in">all</span> %&#125;</span><br><span class="line">        &#123;&#123; x &#125;&#125;</span><br><span class="line">     &#123;% endfor %&#125;</span><br><span class="line"> &#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多对多：中间表关系操作">多对多：中间表关系操作</h3>
<p>增加：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server = Server.objects.get(hostname=<span class="string">&quot;ec-test1&quot;</span>)  <span class="comment"># 获取已有的服务器</span></span><br><span class="line">server.app.add(<span class="number">3</span>)  <span class="comment"># 将应用id3关联该服务器</span></span><br><span class="line">server.app.add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)  <span class="comment"># 将应用id1、2、3关联该服务器</span></span><br></pre></td></tr></table></figure>
<p>删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server.app.remove(<span class="number">3</span>) <span class="comment"># 将应用id3与该服务器取消关联</span></span><br></pre></td></tr></table></figure>
<p>清空:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server.app.clear() <span class="comment"># 将该服务器取消所有应用关联</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django用户认证系统</title>
    <url>/2024/03/08/django%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="内置用户认证系统">内置用户认证系统</h2>
<p>Django内置一个用户认证系统，使用auth模块实现。 auth模块提供了登录、注册、效验、修改密码、注销、验证用户是否登录等功能。</p>
<p><img src="/images/1EC11F41D7A7453EAA9DF261FF30CC98clipboard.png" alt></p>
<p>Django默认创建的数据库表：</p>
<ul>
<li>
<p>auth_user ：用户表</p>
</li>
<li>
<p>auth_user_groups ：用户所属组的表</p>
</li>
<li>
<p>auth_user_user_permissions ：用户权限表</p>
</li>
<li>
<p>auth_group ：用户组表</p>
</li>
<li>
<p>auth_group_permissions ：用户组权限表</p>
</li>
<li>
<p>auth_permission ：存放全部权限的表，其他的表的权限都是从此表中外键连接过去的</p>
</li>
<li>
<p>django_session ：保存HTTP状态</p>
</li>
<li>
<p>django_migrations ：数据库迁移记录</p>
</li>
</ul>
<h2 id="auth模块使用">auth模块使用</h2>
<h3 id="auth模块：login">auth模块：login()</h3>
<p>示例：登录认证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> auth</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> reqeust.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 对用户数据验证</span></span><br><span class="line">        user = auth.authenticate(username=username, password=password)</span><br><span class="line">        <span class="comment"># 如果效验成功，返回一个用户对象，否则返回一个None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            <span class="comment"># 2. 验证通过后，将request与用户对象（包含session）传给login()函数</span></span><br><span class="line">            auth.login(request, user)</span><br><span class="line">            <span class="comment"># 3. 跳转到首页</span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">&quot;用户名或密码错误！&quot;</span></span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>,&#123;<span class="string">&#x27;msg&#x27;</span>: msg&#125;)</span><br></pre></td></tr></table></figure>
<p>登录表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="auth模块：logout">auth模块：logout()</h3>
<p>示例：退出登录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> login,logout</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logout</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 清除当前用户的session信息</span></span><br><span class="line">    auth.logout(request)</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/login&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="auth模块：login-required装饰器">auth模块：login_required装饰器</h3>
<p>login_required装饰器：判断用户是否登录，如果没有登录引导至登录页面，登录 成功后跳转到目的页面。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line"><span class="meta">@login_required()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在settings.py文件设置没有登录默认跳转页面：</p>
<p>LOGIN_URL = ‘/login/’</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django视图</title>
    <url>/2024/03/03/django%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="Django内置函数">Django内置函数</h2>
<p><img src="/images/3A318DC82EB74AAD948E920387264192clipboard.png" alt></p>
<h2 id="HTTP请求流程">HTTP请求流程</h2>
<p><img src="/images/8044F21A02454AB28815A3E1F525342Dclipboard.png" alt></p>
<p><img src="/images/630588136B13476FAEF4DF9D26D5C7C7clipboard.png" alt></p>
<h2 id="HttpRequest对象">HttpRequest对象</h2>
<h3 id="HttpRequest对象：常用属性">HttpRequest对象：常用属性</h3>
<p>Django会建立一个包含请求源数据的HttpRequest对象，当Django加载对应的视图时，HttpRequest 对象将作为函数视图的第一个参数（request），每个视图负责返回一个HttpResponse对象。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;首页&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/FA8AD22440424358BBCD1CC26CE6E3EAclipboard.png" alt></p>
<h3 id="HttpRequest对象：常用方法">HttpRequest对象：常用方法</h3>
<p><img src="/images/F28749AFAF8A46DD87648A1CA7F14BF0clipboard.png" alt></p>
<h3 id="HttpRequest对象：接收URL参数">HttpRequest对象：接收URL参数</h3>
<p>URL参数形式：<a href="http://www.baidu.cn/demo/?id=1&amp;value=100">http://www.baidu.cn/demo/?id=1&amp;value=100</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">url_args</span>(<span class="params">request</span>): </span><br><span class="line">    args1 = request.GET[<span class="string">&#x27;a&#x27;</span>] </span><br><span class="line">    args2 = request.GET[<span class="string">&#x27;b&#x27;</span>] </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="built_in">int</span>(args1) + <span class="built_in">int</span>(args2))</span><br></pre></td></tr></table></figure>
<h3 id="HttpRequest对象：QueryDict对象">HttpRequest对象：QueryDict对象</h3>
<p>request.GET和request.POST返回的都是一个QueryDict对象，类似于字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>): </span><br><span class="line">    req = request.GET </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(req)) </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;首页&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/82FC0A1DB5F64C23B35634CA89CCEBDCclipboard.png" alt></p>
<h3 id="HttpRequest对象：小结">HttpRequest对象：小结</h3>
<p>request对象应用场景：</p>
<ul>
<li>
<p>获取客户端信息、请求页面情况</p>
</li>
<li>
<p>接收客户端上传的数据，例如文件</p>
</li>
<li>
<p>根据客户端特定信息做相应的处理，例如根据请求方法</p>
</li>
</ul>
<h2 id="HttpResponse对象">HttpResponse对象</h2>
<h3 id="HttpResponse对象：HttpResponse函数">HttpResponse对象：HttpResponse函数</h3>
<p>HttpResponse函数：给浏览器返回数据。</p>
<p>语法：HTTPResponse(content=响应体，content_type=响应体数据类型，status=状态码)</p>
<p>示例：返回HTML内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;&lt;h1&gt;Hello Django!&lt;h1&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>示例：设置响应头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">request</span>):</span><br><span class="line">    res = HttpResponse(<span class="string">&quot;Hello APP!&quot;</span>)</span><br><span class="line">    res[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;amei&quot;</span></span><br><span class="line">    res.status_code = <span class="number">302</span></span><br></pre></td></tr></table></figure>
<h3 id="HttpResponse对象：render函数">HttpResponse对象：render函数</h3>
<p>render指定模板，返回一个渲染后的HttpResponse对象。</p>
<p>语法：render(request, template_name, context=None, content_type=None, status=None, using=None)</p>
<ul>
<li>
<p>request：固定参数，django封装的请求</p>
</li>
<li>
<p>template_name：返回html模板</p>
</li>
<li>
<p>context：传入模板中的内容，用于渲染模板，默认空字典</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">current_datetime</span>(<span class="params">request</span>):</span><br><span class="line">    now = datetime.now()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;demo.html&#x27;</span>, &#123;<span class="string">&#x27;datetime&#x27;</span>: now&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="HttpResponse对象：redirect函数">HttpResponse对象：redirect函数</h3>
<p>redirect函数：重定向，发起第二次请求</p>
<p>语法：redirect(to, *args, **kwargs)</p>
<p>参数可以是：</p>
<ul>
<li>
<p>一个视图</p>
</li>
<li>
<p>一个绝对的或者相对的URL</p>
</li>
<li>
<p>一个模型，对象是重定向的URL</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_redirect</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="HttpResponse对象：StreamingHttpResponse函数">HttpResponse对象：StreamingHttpResponse函数</h3>
<p>StreamingHttpResponse函数：流式响应可迭代对象，一般用于响应大数据内容</p>
<p>示例：下载文件</p>
<p>URL路由：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re_path(<span class="string">&#x27;^download/$&#x27;</span>, views.download), </span><br><span class="line">re_path(<span class="string">r&#x27;^down_file/(?P&lt;filename&gt;.*)$&#x27;</span>, views.down_file, name=<span class="string">&quot;down_file&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>视图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> StreamingHttpResponse</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">request</span>):</span><br><span class="line">    file_list = os.listdir(<span class="string">&#x27;upload&#x27;</span>) </span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;download.html&quot;</span>, &#123;<span class="string">&#x27;file_list&#x27;</span>: file_list&#125;)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down_file</span>(<span class="params">request, filename</span>):</span><br><span class="line">    file_path = os.path.join(<span class="string">&#x27;upload&#x27;</span>, filename)</span><br><span class="line">    response = StreamingHttpResponse(<span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>)) </span><br><span class="line">    response[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/octet-stream&#x27;</span> </span><br><span class="line">    response[<span class="string">&#x27;Content-Disposition&#x27;</span>] = <span class="string">&#x27;attachment; filename=%s&#x27;</span> %(os.path.basename(file_path)) <span class="comment"># 指定下载文件名 </span></span><br><span class="line">    <span class="keyword">return</span> response </span><br></pre></td></tr></table></figure>
<p>模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>文件列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  &#123;% for i in  file_list %&#125;</span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;down_file&#x27; i  %&#125;&quot;</span>&gt;</span>&#123;&#123; i &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="HttpResponse对象：-FileResponse函数">HttpResponse对象： FileResponse函数</h3>
<p>FileResponse函数： StreamingHttpResponse的子类，针对文件提供响应</p>
<p>示例：下载文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">down_file</span>(<span class="params">request, filename</span>): </span><br><span class="line">    file_path = os.path.join(<span class="string">&#x27;upload&#x27;</span>, filename) </span><br><span class="line">    response = FileResponse(<span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>)) </span><br><span class="line">    response[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/octet-stream&#x27;</span></span><br><span class="line">    response[<span class="string">&#x27;Content-Disposition&#x27;</span>] = <span class="string">&#x27;attachment; filename=%s&#x27;</span> %(os.path.basename(file_path))</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<h3 id="HttpResponse对象：-JsonResponse函数">HttpResponse对象： JsonResponse函数</h3>
<p>JsonResponse函数：响应一个JSON对象</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_response</span>(<span class="params">request</span>): </span><br><span class="line">    res = &#123;<span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;bar&#x27;</span>&#125; </span><br><span class="line">    <span class="keyword">return</span> JsonResponse(res)</span><br></pre></td></tr></table></figure>
<p><img src="/images/B034746534EA4C4AB46108B4DB4232EEclipboard.png" alt></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django知识回顾</title>
    <url>/2024/05/01/django%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<h2 id="前后端分离开发模式">前后端分离开发模式</h2>
<p><img src="/images/D34E145E31EF45E2B6EB1F1719DA81AFclipboard.png" alt></p>
<p>前后端分离前：前端页面看到的效果都是由后端控制，即后端渲染HTML页面，前端与后端的耦合度很高。</p>
<p>前后端分离前存在的问题：</p>
<ul>
<li>
<p>PC、APP、Pad等多端流行</p>
</li>
<li>
<p>前后端开发职责不清晰：各司其职，最大程度减少开发难度，方便协作</p>
</li>
<li>
<p>开发效率问题，一般后端开发需先等前端页面准备好，有时前端也一直配 合后端，能力受限</p>
</li>
<li>
<p>前后端代码混在一起，日积月累，维护成本增加</p>
</li>
<li>
<p>后端开发语言和模板耦合</p>
</li>
</ul>
<p><img src="/images/E17427775FE84472B9C09BB004F751C0clipboard.png" alt></p>
<p>前后端分离后：后端仅返回前端所需要的数据，不再渲染HTML页面，不再 控制前端的效果，至于前端展示什么效果，都由前端自己决定。</p>
<h2 id="认识RestFulAPI">认识RestFulAPI</h2>
<p>什么是RestfulAPI：</p>
<ul>
<li>
<p>REST（Representational State Transfer，表征状态转移）是一种Web服务的软件架构风格。 描述网络中客户端与服务端的一种交互方式，它本身不常用，常用的是如何设计RestfulAPI （REST风格的网络接口）</p>
</li>
<li>
<p>RestfulAPI风格就是把所有的数据都当做资源，对表的操作就是对资源操作</p>
</li>
<li>
<p>资源就是指的URL，基于URL对资源操作，Web服务在URL上支持一系列请求方法，如下表所 示。</p>
</li>
</ul>
<p><img src="/images/FA431794CEC14C5DB652997DE4A72F16clipboard.png" alt></p>
<p>示例：</p>
<p>非REST的URL：<a href="http://ip/get_user?id=123">http://ip/get_user?id=123</a></p>
<p>REST的URL：<a href="http://ip/user/123">http://ip/user/123</a></p>
<h2 id="回顾Django开发模式">回顾Django开发模式</h2>
<p><img src="/images/2651E0F3AB50418585350C0E004817FFclipboard.png" alt></p>
<h2 id="Django-REST-Framework初探">Django REST Framework初探</h2>
<p>Django REST framework （简称：DRF）是一个强大而灵活的Web API 工具。 遵循RESTFullAPI风格，功能完善，可快速开发API平台。</p>
<p>官网文档：https:// <a href="http://www.django-rest-framework.org">www.django-rest-framework.org</a></p>
<p>Django REST framework 最新版使用要求：</p>
<ul>
<li>
<p>Python（3.6、3.7、3.8、3.9、3.10）</p>
</li>
<li>
<p>Django（2.2、3.0、3.1、3.2、4.0）</p>
</li>
</ul>
<p>安装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install djangorestframework</span><br></pre></td></tr></table></figure>
<p>添加rest_framework到INSTALLED_APPS设置中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [ </span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>
<p>示例：实现用户增删改查</p>
<p>步骤：</p>
<p>一、创建APP</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py startapp myapp_api</span><br></pre></td></tr></table></figure>
<p>二、定义数据模型并同步数据库</p>
<p><img src="/images/74A3F38F114F437AA36095C282EA3DDEclipboard.png" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations </span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<p>三、编写序列化器文件</p>
<p>myapp_api/serializers.py</p>
<p><img src="/images/F6C62EC5926145F2B6A0B71C8A488A89clipboard.png" alt></p>
<p>四、编写视图</p>
<p><img src="/images/CF49F3A738ED4FE1BE2BC41AAFF3C3C5clipboard.png" alt></p>
<p>五、添加API路由</p>
<p>devops/urls.py</p>
<p><img src="/images/B05108E86E374381AFB13F3A3443B2EFclipboard.png" alt></p>
<p>myapp_api/urls.py</p>
<p><img src="/images/7E7D563E6C3F47D1B8AB9B0D5E4982CAclipboard.png" alt></p>
<p><img src="/images/897C736BF6F44F76A9284D3CA42E2318clipboard.png" alt></p>
<p>上图是访问/myapp_api/api/地址获得。</p>
<p>这是DRF自带的API调试系统，结果显示自动注册路由的API 地址，可通过这个地址完成用户信息数据的增删改查：</p>
<p>增、查：<a href="http://127.0.0.1:8000/myapp_api/api/user/">http://127.0.0.1:8000/myapp_api/api/user/</a></p>
<p>删、改：<a href="http://127.0.0.1:8000/myapp_api/api/user/2/">http://127.0.0.1:8000/myapp_api/api/user/2/</a></p>
]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title>drf常用功能</title>
    <url>/2024/05/04/drf%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="主流认证方式">主流认证方式</h2>
<p>主流认证方式：</p>
<ul>
<li>
<p>Session</p>
</li>
<li>
<p>Token</p>
</li>
<li>
<p>JWT</p>
</li>
</ul>
<h3 id="主流认证方式：Session认证">主流认证方式：Session认证</h3>
<p><img src="/images/E3B36C187C82414586DA0A7367E1B31Bclipboard.png" alt></p>
<h3 id="主流认证方式：Token认证">主流认证方式：Token认证</h3>
<p><img src="/images/BA52A032787A42758426CAF01D8AACB1clipboard.png" alt></p>
<h3 id="主流认证方式：JWT认证">主流认证方式：JWT认证</h3>
<p><img src="/images/E2F18ADD59A84E83ACE7E0F825E8D7E8clipboard.png" alt></p>
<h2 id="DRF认证">DRF认证</h2>
<h3 id="DRF认证与权限">DRF认证与权限</h3>
<p>目前DRF可任意访问，没有任何限制，是不符合生产环境标准的，因此接下来学习认证实现访问控制。</p>
<p>DRF支持四种认证方式：</p>
<ul>
<li>
<p>BasicAuthentication：基于用户名和密码的认证，适用于测试</p>
</li>
<li>
<p>SessionAuthentication：基于Session的认证</p>
</li>
<li>
<p>TokenAuthentication：基于Token的认证</p>
</li>
<li>
<p>RemoteUserAuthentication：基于远程用户的认证</p>
</li>
</ul>
<p>DRF支持权限：</p>
<ul>
<li>
<p>IsAuthenticated：只有登录用户才能访问所有API</p>
</li>
<li>
<p>AllowAny：允许所有用户</p>
</li>
<li>
<p>IsAdminUser：仅管理员用户</p>
</li>
<li>
<p>IsAuthenticatedOrReadOnly：登录的用户可以读写API，未登录用户只读</p>
</li>
</ul>
<h3 id="DRF认证：Session认证">DRF认证：Session认证</h3>
<p><img src="/images/A812511EBAB24D9EBFFEB01CE69B1C20clipboard.png" alt></p>
<p><img src="/images/1D91E9CE52744E6CB827F933C91A077Eclipboard.png" alt></p>
<h3 id="DRF认证：Token认证">DRF认证：Token认证</h3>
<p><img src="/images/DEF412843B6C4704A5C2B3E6F57F59ADclipboard.png" alt></p>
<p><img src="/images/7AD845D09CCD45B5B68A0B680AD0FB26clipboard.png" alt></p>
<p>默认的obtain_auth_token视图返回的数据是比较简单的，只有token一项，如果想返回更多的信息， 例如用户名，可以重写ObtainAuthToken类的方法实现：</p>
<p><img src="/images/F5000B15B5194E3FAFE7B8B1A7FC5D4Bclipboard.png" alt></p>
<h2 id="限流">限流</h2>
<p>可以对接口访问的频率进行限制，以减轻服务器压力。</p>
<p>应用场景：投票、购买数量等</p>
<p><img src="/images/B796AEA5D2864F808470AA5EAAE0D064clipboard.png" alt></p>
<h2 id="过滤">过滤</h2>
<p>对于列表数据可能需要根据字段进行过滤，我们可以通过添加django-fitlter扩展来增强支持。</p>
<p>文档：https ://www.django-rest-framework.org/api-guide/filtering/</p>
<p>安装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install django-<span class="built_in">filter</span></span><br></pre></td></tr></table></figure>
<p>添加APP：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line"> ...</span><br><span class="line"> <span class="string">&#x27;django_filters&#x27;</span></span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>
<p>添加DRF配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line"><span class="comment"># 过滤</span></span><br><span class="line"><span class="string">&#x27;DEFAULT_FILTER_BACKENDS&#x27;</span>: (<span class="string">&#x27;django_filters.rest_framework.DjangoFilterBackend&#x27;</span>,)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在视图中指定过滤的字段：</p>
<p><img src="/images/B6434EAC66CB4A22A08B4DCA224B85BFclipboard.png" alt></p>
<p>测试：<a href="http://127.0.0.1:8001/myapp_api/api/user?name=%E9%98%BF%E5%93%B2">http://127.0.0.1:8001/myapp_api/api/user?name=阿哲</a></p>
<h2 id="搜索和排序">搜索和排序</h2>
<p>DRF提供过滤器帮助我们快速对字段进行搜索和排序。</p>
<p><img src="/images/DE1892A5D524426EBD4CD412F7FAB733clipboard.png" alt></p>
<p>搜索测试：<a href="http://127.0.0.1:8001/myapp_api/api/user?search=%E9%98%BF%E5%93%B2">http://127.0.0.1:8001/myapp_api/api/user?search=阿哲</a></p>
<p>排序测试：<a href="http://127.0.0.1:8001/myapp_api/api/user?ordering=id">http://127.0.0.1:8001/myapp_api/api/user?ordering=id</a></p>
<p>注：默认是正序排列，字段前面加横杠（例如-id）表示倒序排列</p>
<h2 id="分页">分页</h2>
<p>分页是数据表格必备的功能，可以在前端实现，也可以在后端实现，为了避免响 应数据过大，造成前端压力，一般在后端实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK =&#123;</span><br><span class="line">    <span class="comment">#分页</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PAGINATION_CLASS&#x27;</span>: <span class="string">&#x27;rest_framework.pagination.PageNumberPagination&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PAGE_SIZE&#x27;</span>: <span class="number">3</span> , <span class="comment"># 每页数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/706016A1999644A19A216B4D1604543Eclipboard.png" alt></p>
<p>默认分页器灵活度不高，例如不能动态传递每页条数，可以通过重写 PageNumberPagination类属性改变默认配置。</p>
<p>myapp_api/pagination.py</p>
<p><img src="/images/32FE1DECE1BB439BB3BDC9C7CB0A8B14clipboard.png" alt></p>
<p>DRF配置指定模块路径：</p>
<p><img src="/images/2A22682600B84FBEBBA23CB5343C68C8clipboard.png" alt></p>
<p>测试：<a href="http://127.0.0.1:8001/myapp_api/api/user?page_num=2&amp;page_size=3">http://127.0.0.1:8001/myapp_api/api/user?page_num=2&amp;page_size=3</a></p>
<p><img src="/images/70F7975C4A31404D99A6F8570F8FF650clipboard.png" alt></p>
<h2 id="自动生成接口文档">自动生成接口文档</h2>
<p>由于项目开发经验欠缺或着急上线，需求不断改动，项目设计阶段定义的接口已经面目全非，这给 前端开发人员参考带来一定困难，如何改善这个问题呢？</p>
<p>Swagger来了，它是一个应用广泛的REST API文档自动生成工具，生成的文档可供前端人员查看。</p>
<p>文档参考：https ://django-rest-swagger.readthedocs.io/en/latest/</p>
<p>安装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install django-rest-swagger</span><br></pre></td></tr></table></figure>
<p>添加APP：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">     ...</span><br><span class="line">     <span class="string">&#x27;rest_framework_swagger&#x27;</span>,</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>
<p>DRF配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># API接口文档</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_SCHEMA_CLASS&#x27;</span>: <span class="string">&#x27;rest_framework.schemas.coreapi.AutoSchema&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>URL路由：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework_swagger.views <span class="keyword">import</span> get_swagger_view</span><br><span class="line">schema_view = get_swagger_view(title=<span class="string">&#x27;接口文档&#x27;</span>)</span><br><span class="line">urlpatterns += [</span><br><span class="line">    re_path(<span class="string">&#x27;^docs/$&#x27;</span>, schema_view),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><img src="/images/6D7AF83697AB496299CD0AB7FE0F9282clipboard.png" alt></p>
]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title>drf序列化器</title>
    <url>/2024/05/02/drf%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/</url>
    <content><![CDATA[<h2 id="序列化与反序列化介绍">序列化与反序列化介绍</h2>
<p>在日常开发中，会从别的API获取数据或者自己写API提供数据，数据格式一般都是采用 JSON格式。这期间就会涉及两个专业术语：</p>
<ul>
<li>
<p>序列化：将python对象转json</p>
</li>
<li>
<p>反序列化：将json转为python对象</p>
</li>
</ul>
<h2 id="之前常用三种序列化方式">之前常用三种序列化方式</h2>
<p>之前经常用json模式完成序列化与反序列化操作：</p>
<ul>
<li>
<p>序列化应用场景示例：用ORM查询数据，采用JSON格式API返回数据。</p>
</li>
<li>
<p>反序列化应用场景示例：从别的API获取数据，在Python里处理。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json </span><br><span class="line"><span class="comment"># 序列化 </span></span><br><span class="line">computer = &#123;<span class="string">&quot;主机&quot;</span>:<span class="number">5000</span>,<span class="string">&quot;显示器&quot;</span>:<span class="number">1000</span>,<span class="string">&quot;鼠标&quot;</span>:<span class="number">60</span>,<span class="string">&quot;键盘&quot;</span>:<span class="number">150</span>&#125; </span><br><span class="line">json.dumps(computer) </span><br><span class="line"><span class="comment"># 反序列化 </span></span><br><span class="line">json.loads(json_obj)</span><br></pre></td></tr></table></figure>
<p>Serializers是Django内置的一个序列化器，可直接将Python对象转为JSON格式，但不支 持反序列化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> serializers </span><br><span class="line">obj = User.objects.<span class="built_in">all</span>() </span><br><span class="line">data = serializers.serialize(<span class="string">&#x27;json&#x27;</span>, obj)</span><br></pre></td></tr></table></figure>
<p>JsonResponse模块自动将Python对象转为JSON对象并响应。</p>
<h2 id="DRF序列化器三种类型">DRF序列化器三种类型</h2>
<p>DRF中有一个serializers模块专门负责数据序列化，DRF提供的方案更先进、更高级别的序列化方案。</p>
<p>序列化器支持三种类型：</p>
<ul>
<li>
<p>Serializer：对Model（数据模型）进行序列化，需自定义字段映射。</p>
</li>
<li>
<p>ModelSerializer：对Model进行序列化，会自动生成字段和验证规则，默认还包含简单的create()和update()方法。</p>
</li>
<li>
<p>HyperlinkedModelSerializer：与ModelSerializer类似，只不过使用超链接来表示关系而不是主键ID。</p>
</li>
</ul>
<h3 id="DRF序列化器：Serializer">DRF序列化器：Serializer</h3>
<p><img src="/images/57834BFA72604216B2454EF9F52EAA4Dclipboard.png" alt></p>
<p><img src="/images/F41A31A33C09447CBA91CF27D0C18DF3clipboard.png" alt></p>
<p><img src="/images/ABAF41BB6161439BA94B251B98B7631Dclipboard.png" alt></p>
<p><img src="/images/8899633F07CF4CD484E8CAFBD28B03ABclipboard.png" alt></p>
<p><img src="/images/5E3E23470F6349E7945A835C6B320671clipboard.png" alt></p>
<h3 id="DRF序列化器：小结">DRF序列化器：小结</h3>
<p>序列化器工作流程：</p>
<p>序列化（读数据）：视图里通过ORM从数据库获取数据查询集对象-&gt; 数据传入序列化器-&gt; 序列化器将数据进行序列化-&gt; 调用序列化器的.data获取数据-&gt; 响应返回前端</p>
<p>反序列化（写数据）：视图获取前端提交的数据-&gt; 数据传入序列化器-&gt; 调用序列化器 的.is_valid方法进行效验-&gt; 调用序列化器的.save()方法保存数据</p>
<p>序列化器常用方法与属性：</p>
<ul>
<li>
<p>serializer.is_valid()：调用序列化器验证是否通过，传入raise_exception=True可以在 验证失败时由DRF响应400异常。</p>
</li>
<li>
<p>serializer.errors：获取反序列化器验证的错误信息</p>
</li>
<li>
<p>serializer.data：获取序列化器返回的数据</p>
</li>
<li>
<p>serializer.save()：将验证通过的数据保存到数据库（ORM操作）</p>
</li>
</ul>
<h3 id="DRF序列化器：序列化器参数">DRF序列化器：序列化器参数</h3>
<p><img src="/images/3FCE1815EC494E19BA8C04CB7A0A1F92clipboard.png" alt></p>
<h3 id="DRF序列化器：扩展验证规则">DRF序列化器：扩展验证规则</h3>
<p>如果常用参数无法满足验证要求时，可通过钩子方法扩展验证规则。</p>
<p>局部钩子：validate_字段名(self, 字段值)</p>
<p>全局钩子：validate(self, 所有校验的数据字典)</p>
<p><img src="/images/86AF9B0339A0479FAE712A09965725D7clipboard.png" alt></p>
<p>如果钩子无法满足需要，可以自定义验证器，更灵活。</p>
<p>在序列化类外面定义验证器，使用validators参数指定验证器。</p>
<p><img src="/images/8CA45E40B3044C6D9273699CB46DD53Fclipboard.png" alt></p>
<h3 id="DRF序列化器：ModelSerializer">DRF序列化器：ModelSerializer</h3>
<p>ModelSerializer 类型不需要自定义字段映射和定义create、update方法，使用起来方便很多！</p>
<p><img src="/images/3E4AF8ECA3B54DCA801ADCFCF2CCF55Aclipboard.png" alt></p>
<p>Meta类常用属性：</p>
<ul>
<li>
<p>fields：显示所有或指定字段</p>
</li>
<li>
<p>exclude：排除某个字段，元组格式，不能与fields同时用</p>
</li>
<li>
<p>read_only_fields：只读字段，即只用于序列化，不支持修改</p>
</li>
<li>
<p>extra_kwargs：添加或修改原有的字段参数，字典格式</p>
</li>
<li>
<p>depth：根据关联的数据递归显示，一般是多表</p>
</li>
</ul>
<p><img src="/images/5140C2DA1CC443E99E8A3E856FFC827Eclipboard.png" alt></p>
<h3 id="DRF序列化器：HyperModelSerializer">DRF序列化器：HyperModelSerializer</h3>
<p>与MedelSerializer使用方法一样。只不过它使用超链接来表示关系而不是主键ID。</p>
<p>示例：基于前面用户管理修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更改序列化器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserSerializer</span>(serializers.HyperlinkedModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">    model = User</span><br><span class="line">    fields = <span class="string">&quot;__all__&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 更改视图</span></span><br><span class="line">user_ser = UserSerializer(queryset, many=<span class="literal">True</span>, context=&#123;<span class="string">&#x27;request&#x27;</span>: request&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改路由</span></span><br><span class="line">re_path(<span class="string">&#x27;^api/user/$&#x27;</span>, views.UserView.as_view(), name=<span class="string">&quot;user-detail&quot;</span>),</span><br><span class="line">re_path(<span class="string">&#x27;^api/user/(?P&lt;pk&gt;\d+)/$&#x27;</span>, views.UserView.as_view(), name=<span class="string">&quot;user-detail&quot;</span>),</span><br></pre></td></tr></table></figure>
<p><img src="/images/4DD2402B1656431BAE7F3D11A1CA3BBDclipboard.png" alt></p>
<h2 id="DRF序列化器关联表显示">DRF序列化器关联表显示</h2>
<p>例如：应用发布系统项目涉及表</p>
<p>一对多：一个项目有多个应用，一个应用只能属于一个项目</p>
<p>多对多：一个应用部署到多台服务器，一个服务器部署多个应用</p>
<p><img src="/images/701D3760C94F42DBAF935B5530E26E7Aclipboard.png" alt></p>
<p>1、定义数据模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Project</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    project = models.ForeignKey(Project, on_delete=models.CASCADE) <span class="comment"># 一对多</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>(models.Model):</span><br><span class="line">    hostname = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    ip = models.GenericIPAddressField()</span><br><span class="line">    app = models.ManyToManyField(App)  <span class="comment"># 多对多</span></span><br></pre></td></tr></table></figure>
<p>2、定义序列化器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProjectSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Project</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = App</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Server</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br></pre></td></tr></table></figure>
<p>3、定义视图</p>
<p><img src="/images/BD4522FD691947AAA6AE4A041A6B1A0Bclipboard.png" alt></p>
<p>4、定义路由</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re_path(<span class="string">&#x27;^api/project/$&#x27;</span>, views.ProjectView.as_view()), </span><br><span class="line">re_path(<span class="string">&#x27;^api/app/$&#x27;</span>, views.AppView.as_view()),</span><br><span class="line">re_path(<span class="string">&#x27;^api/server/$&#x27;</span>, views.ServerView.as_view()),</span><br></pre></td></tr></table></figure>
<p>5、添加测试数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">创建项目：</span><br><span class="line"><span class="keyword">from</span> myapp_api.models <span class="keyword">import</span> Project, App, Server</span><br><span class="line">Project.objects.create(name=<span class="string">&quot;电商&quot;</span>)</span><br><span class="line">Project.objects.create(name=<span class="string">&quot;教育&quot;</span>)</span><br><span class="line">创建应用并指定项目：</span><br><span class="line">project_obj = Project.objects.get(name=<span class="string">&quot;电商&quot;</span>)</span><br><span class="line">App.objects.create(name=<span class="string">&quot;portal&quot;</span>, project=project_obj)</span><br><span class="line">App.objects.create(name=<span class="string">&quot;gateway&quot;</span>, project=project_obj)</span><br><span class="line">创建服务器：</span><br><span class="line">Server.objects.create(hostname=<span class="string">&quot;test1&quot;</span>, ip=<span class="string">&quot;192.168.31.10&quot;</span>)</span><br><span class="line">Server.objects.create(hostname=<span class="string">&quot;test2&quot;</span>, ip=<span class="string">&quot;192.168.31.11&quot;</span>)</span><br><span class="line">将应用部署到服务器：</span><br><span class="line">app_obj = App.objects.get(name=<span class="string">&quot;portal&quot;</span>)</span><br><span class="line">server_obj = Server.objects.get(hostname=<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">server_obj.app.add(app_obj)</span><br></pre></td></tr></table></figure>
<p>序列化器返回是当前模型中的字段，如果字段是外键时，返回的是外键对应id，如图所 示，如果想要显示外键对应的详细信息如何做呢？</p>
<p>有两种方法：</p>
<ul>
<li>
<p>定义字段为外键对应序列化类：例如project=ProjectSerializer(read_only=True)， 这种适合针对某个外键字段。</p>
</li>
<li>
<p>序列化类中Meta类启用depth：深度获取关联表数据，这种所有外键都会显示出来。</p>
</li>
</ul>
<p><img src="/images/556DAD7EF3174473ACCA60F1A4580693clipboard.png" alt></p>
<p>一对多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    project = ProjectSerializer(read_only=<span class="literal">True</span>) <span class="comment"># 一对多，返回关联的项目详情</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = App</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = App</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br><span class="line">        depth = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/7CAAA66E29CA4D52ACCCD64FDFAF5B3Aclipboard.png" alt></p>
<p>多对多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    app = AppSerializer(many=<span class="literal">True</span>)  <span class="comment"># 多对多，返回关联的应用详情</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Server</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Server</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br><span class="line">        depth = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/12F1A8F1EB2D409FABA2B12145B375F0clipboard.png" alt></p>
<h2 id="DRF序列化器：SerializerMethodField">DRF序列化器：SerializerMethodField</h2>
<p>DRF序列化器默认仅返回数据模型中已存在资源，如果想新增返回字段或者二次处理，该 如何操作呢？用SerializerMethodFiled</p>
<p>示例：给项目API增加一个字段，这个字段数据可从别的表中获取</p>
<p><img src="/images/621E3E1F030041F9B6F9E4BD2F15E876clipboard.png" alt></p>
<h2 id="改变序列化和反序列化行为">改变序列化和反序列化行为</h2>
<p>可以通过重写下面两个方法改变序列化和反序列化的行为：</p>
<ul>
<li>
<p>to_internal_value()：处理反序列化的输入数据，自动转换Python对象，方便处理。</p>
</li>
<li>
<p>to_representation()：处理序列化数据的输出。</p>
</li>
</ul>
<p>示例：如果提交API的数据与序列化器要求的格式不符合，序列化器就会出现错误。 这时就可以重写to_internal_value()方法只提取出我们需要的数据。</p>
<p><img src="/images/029276C5CD164F06AA0D58C6FC80379Dclipboard.png" alt></p>
<p>示例：希望给返回的数据添加一个统计应用数量的字段</p>
<p><img src="/images/183CB3BF6E574AB3B12DEBCFC63B32D2clipboard.png" alt></p>
]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK Stack收集Kubernetes应用日志</title>
    <url>/2023/06/10/elk-stack%E6%94%B6%E9%9B%86kubernetes%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="需求背景">需求背景</h2>
<ul>
<li>
<p>业务发展越来越庞大，服务器越来越多</p>
</li>
<li>
<p>各种访问日志、应用日志、错误日志量越来越多</p>
</li>
<li>
<p>开发人员排查问题，需要到服务器上查日志，效率低、权限不好控制</p>
</li>
<li>
<p>运维需实时关注业务访问情况</p>
</li>
</ul>
<h2 id="容器特性给日志采集带来的难度">容器特性给日志采集带来的难度</h2>
<p>容器特性给日志采集带来的难度：</p>
<ul>
<li>
<p>K8s弹性伸缩性：导致不能预先确定采集的目标</p>
</li>
<li>
<p>容器隔离性：容器的文件系统与宿主机是隔离，导致 日志采集器读取日志文件受阻</p>
</li>
</ul>
<h2 id="日志按体现方式分类">日志按体现方式分类</h2>
<p>应用程序日志记录体现方式分为两类：</p>
<ul>
<li>
<p>标准输出：输出到控制台，使用kubectl logs可以看到</p>
</li>
<li>
<p>日志文件：写到容器的文件系统的文件</p>
</li>
</ul>
<p>示例：标准输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run nginx --image=nginx </span><br><span class="line">kubectl get pod -o wide</span><br><span class="line">curl -I 10.244.36.65</span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx -- bash</span><br></pre></td></tr></table></figure>
<p><img src="/images/1AD8668512ED40C7982F71EEF7578947clipboard.png" alt></p>
<p><img src="/images/BCA6E0A58E0B4B57864D0463C3A40454clipboard.png" alt></p>
<p>日志文件在宿主机上的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -o wide     <span class="comment">#查看pod所在节点</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/AC3C714989FF4404BD41B4DFF6EE4508clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#采集所有容器的日志</span></span><br><span class="line">/var/lib/docker/containers/*/*-json.log</span><br></pre></td></tr></table></figure>
<p>示例：日志文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run tomcat --image=tomcat</span><br><span class="line">kubectl get pod -o wide</span><br><span class="line">curl 10.244.36.66:8080</span><br><span class="line">kubectl <span class="built_in">exec</span> -it tomcat -- bash</span><br></pre></td></tr></table></figure>
<p><img src="/images/ABF0ED03F8B84009870BC9853D2F5CFAclipboard.png" alt></p>
<p>方式一：使用emptyDir数据卷挂载容器日志路径到宿主机上，DaemonSet方式部署，在每个节点部署日志采集器采集日志。</p>
<p>vim tomcat.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: tomcat-web</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: tomcat</span><br><span class="line">    name: web</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: logs</span><br><span class="line">      mountPath: /usr/local/tomcat/logs</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: logs</span><br><span class="line">    emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/792129A318954414A785DF716F403E67clipboard.png" alt></p>
<p><img src="/images/B39AB402B525404DB60FF061FFE148D0clipboard.png" alt></p>
<p>方式二：使用emptyDir数据卷共享应用容器的日志让日志采集器容器能够采集到</p>
<p>vim tomcat.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: tomcat-web</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: tomcat</span><br><span class="line">    name: web</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: logs</span><br><span class="line">      mountPath: /usr/local/tomcat/logs</span><br><span class="line">  - image: busybox</span><br><span class="line">    name: <span class="built_in">test</span></span><br><span class="line">    <span class="built_in">command</span>: [/bin/sh,-c,<span class="string">&#x27;tail -f /tmp/localhost_access_log.2021-02-26.txt&#x27;</span>]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: logs</span><br><span class="line">      mountPath: /tmp</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: logs</span><br><span class="line">    emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/DCE9C4C11E3D48AFBD309303774D4515clipboard.png" alt></p>
<h2 id="Kubernetes应用日志收集">Kubernetes应用日志收集</h2>
<p><img src="/images/AD6A4A61D93642979FC4597F279971CEclipboard.png" alt></p>
<h2 id="ELK-Stack日志系统">ELK Stack日志系统</h2>
<p>ELK 是三个开源软件的缩写，提供一套完整的企业级日 志平台解决方案。</p>
<p>分别是：</p>
<ul>
<li>
<p>Elasticsearch：搜索、分析和存储数据</p>
</li>
<li>
<p>Logstash ：采集日志、格式化、过滤，最后将数据 推送到Elasticsearch存储</p>
</li>
<li>
<p>Kibana：数据可视化</p>
</li>
<li>
<p>Beats ：集合了多种单一用途数据采集器，用于实 现从边缘机器向 Logstash 和 Elasticsearch 发送数 据。里面应用最多的是Filebeat，是一个轻量级日 志采集器</p>
</li>
</ul>
<p><img src="/images/F17E6A5760E5440D935C1A2AE3DCC9CBclipboard.png" alt></p>
<p>部署nfs-pv自动供给</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装nfs安装包（每个k8s节点都要安装）</span></span><br><span class="line">yum install nfs-utils</span><br><span class="line"><span class="comment">#创建nfs共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/kubernetes</span><br><span class="line"><span class="comment">#修改nfs配置文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/nfs/kubernetes *(rw,no_root_squash)</span><br><span class="line"><span class="comment">#启动nfs并加入开机自启</span></span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署NFS实现自动创建PV插件：</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-incubator/external-storage </span><br><span class="line"><span class="built_in">cd</span> nfs-client/deploy </span><br><span class="line">kubectl apply -f rbac.yaml <span class="comment"># 授权访问apiserver </span></span><br><span class="line">kubectl apply -f deployment.yaml <span class="comment"># 部署插件，需修改里面NFS服务器地址与共享目录 </span></span><br><span class="line">kubectl apply -f class.yaml <span class="comment"># 创建存储类</span></span><br><span class="line">kubectl get sc  <span class="comment"># 查看存储类</span></span><br></pre></td></tr></table></figure>
<p><a href="/attachments/C51F66682474432DB8DEEF207364AA3Delk.zip">elk.zip</a></p>
<p>搭建日志系统：</p>
<ul>
<li>
<p>elasticsearch.yaml # ES数据库</p>
</li>
<li>
<p>kibana.yaml # 可视化展示</p>
</li>
</ul>
<p>日志收集：</p>
<ul>
<li>
<p>filebeat-kubernetes.yaml # 采集所有容器标准输出</p>
</li>
<li>
<p>app-log-stdout.yaml # 标准输出测试应用</p>
</li>
<li>
<p>app-log-logfile.yaml # 日志文件测试应用</p>
</li>
</ul>
<p>可视化展示日志：</p>
<ol>
<li>
<p>查看索引（日志记录集合）：Management -&gt; Stack Management -&gt; 索引管理</p>
</li>
<li>
<p>将索引关联到Kibana：索引模式 -&gt; 创建 -&gt; 匹配模式 -&gt; 选择时间戳</p>
</li>
<li>
<p>在Discover选择索引模式查看日志</p>
</li>
</ol>
<p><img src="/images/BBE56CA4DD2C4075B8E673533B732201clipboard.png" alt></p>
<p><img src="/images/6C71CC0FD2EC42A998135CB4485B01B2clipboard.png" alt></p>
<p><img src="/images/4CB047B4EFBC4538A62072AC9D70C419clipboard.png" alt></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>drf视图</title>
    <url>/2024/05/03/drf%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="DRF类视图介绍">DRF类视图介绍</h2>
<p>在DRF框架中提供了众多的通用视图基类与扩展类，以简化视图的编写。</p>
<ul>
<li>
<p>View：Django默认的视图基类，负责将视图连接到URL，HTTP请求方法的基本调度， 之前写类视图一般都用这个。</p>
</li>
<li>
<p>APIView：DRF提供的所有视图的基类，继承View并扩展，具备了身份认证、权限检查、 流量控制等功能。</p>
</li>
<li>
<p>GenericAPIView：对APIView更高层次的封装，例如增加分页、过滤器</p>
</li>
<li>
<p>GenericViewSet：继承GenericAPIView和ViewSet</p>
</li>
<li>
<p>ViewSet：继承APIView，并结合router自动映射路由</p>
</li>
<li>
<p>ModelViewSet：继承GenericAPIView和五个扩展类，封装好各种请求，更加完善， 业务逻辑基本不用自己写了。</p>
</li>
</ul>
<p><img src="/images/34C10B8A3DFE4A8C9A958F6615B2C640clipboard.png" alt></p>
<h2 id="APIView类">APIView类</h2>
<p>APIView：DRF提供的所有视图的基类，继承View并扩展，具备了身份认证、权限检查、 流量控制等功能。</p>
<p><img src="/images/C52BF9D1342C452DAEA6B56BA775788Eclipboard.png" alt></p>
<h2 id="Request与Response">Request与Response</h2>
<p>DRF传入视图的request对象不再是Django默认的HttpRequest对象，而是基于 HttpRequest类扩展后的Request类的对象。</p>
<p>Request对象的数据是自动根据前端发送的数据统一解析数据格式。</p>
<p>常用属性：</p>
<ul>
<li>
<p>request.data：返回POST提交的数据，与request.POST类似</p>
</li>
<li>
<p>request.query_params：返回GET URL参数，与request.GET类似</p>
</li>
</ul>
<p>DRF提供了一个响应类Reponse，响应的数据会自动转换符合前端的JSON数据格式。</p>
<p>导入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response </span><br></pre></td></tr></table></figure>
<p>格式：</p>
<p>Response(data, status=None, template_name=None, headers=None, content_type=None)</p>
<ul>
<li>
<p>data：响应序列化处理后的数据，传递python对象</p>
</li>
<li>
<p>status：状态码，默认200</p>
</li>
<li>
<p>template_name：模板名称</p>
</li>
<li>
<p>headers：用于响应头信息的字典</p>
</li>
<li>
<p>content_type：响应数据的类型</p>
</li>
</ul>
<p>使用方法：return Reponse(data=data, status=status.HTTP_404_NOT_FOUND)</p>
<p>为了方便设置状态码，rest_framework.status模块提供了所有HTTP状态码，以下是一些 常用的：</p>
<ul>
<li>
<p>HTTP_200_OK：请求成功</p>
</li>
<li>
<p>HTTP_301_MOVED_PERMANENTLY：永久重定向</p>
</li>
<li>
<p>HTTP_302_FOUND：临时重定向</p>
</li>
<li>
<p>HTTP_304_NOT_MODIFIED：请求的资源未修改</p>
</li>
<li>
<p>HTTP_403_FORBIDDEN：没有权限访问</p>
</li>
<li>
<p>HTTP_404_NOT_FOUND：页面没有发现</p>
</li>
<li>
<p>HTTP_500_INTERNAL_SERVER_ERROR：服务器内部错误</p>
</li>
<li>
<p>HTTP_502_BAD_GATEWAY：网关错误</p>
</li>
<li>
<p>HTTP_503_SERVICE_UNAVAILABLE：服务器不可达</p>
</li>
<li>
<p>HTTP_504_GATEWAY_TIMEOUT：网关超时</p>
</li>
</ul>
<h2 id="GenericAPIView类">GenericAPIView类</h2>
<p>GenericAPIView对APIView更高层次的封装，实现以下功能：</p>
<ul>
<li>
<p>增加queryset属性，指定操作的数据，不用再将数据传给序列化器，会自动实现。</p>
</li>
<li>
<p>增加serializer_class属性，直接指定使用的序列化器</p>
</li>
<li>
<p>增加过滤器属性：filter_backends • 增加分页属性：pagination_class</p>
</li>
<li>
<p>增加lookup_field属性和实现get_object()方法：用于获取单条数据，可自定义默认分组名（pk）</p>
</li>
</ul>
<p><img src="/images/3A7F0CEDB3C446F29F3636DAAD8E1FC0clipboard.png" alt></p>
<h2 id="ViewSet类">ViewSet类</h2>
<p>GenericAPIView已经完成了许多功能，但会有一个问题，获取所有用户列表和单个用户需 要分别定义两个视图和URL路由，使用ViewSet可以很好解决这个问题，并且实现了路由自 动映射。</p>
<p>ViewSet视图集不再实现get()、post()等方法，而是实现以下请求方法动作：</p>
<ul>
<li>
<p>list()：获取所有数据</p>
</li>
<li>
<p>retrieve()：获取单个数据</p>
</li>
<li>
<p>create()：创建数据</p>
</li>
<li>
<p>update()：更新数据</p>
</li>
<li>
<p>destory()：删除数据</p>
</li>
</ul>
<p><img src="/images/983F8AE5F10948CB8F04556E3086C446clipboard.png" alt></p>
<p>在路由这块定义与之前方式一样，每个API接口都要写一条URL路由，但实际上我们用ViewSet 后，就不用自己设计URL路由及绑定HTTP方法了，会自动处理URL路由映射。</p>
<p><img src="/images/580A7657BC5A4898A051ADF9692338C7clipboard.png" alt></p>
<p>然后访问<a href="http://ip/myapp_api/api">http://ip/myapp_api/api</a> 就可以看到自动生成的URL路由。</p>
<h2 id="ModelViewSet类">ModelViewSet类</h2>
<p>ModelViewSet继承GenericAPIView和五个扩展类，封装好各种请求，更加完善，业务逻 辑基本不用自己写了，只需要指定serializer_class和queryset，就可以直接进行增删改查。</p>
<p><img src="/images/A7378950AB0B4F5BB2D9E0FA42C971E9clipboard.png" alt></p>
<p><img src="/images/4C50BB8CF4AC460FA9F378B085265890clipboard.png" alt></p>
<p><img src="/images/1AE610A389994E188A4943764671F8FBclipboard.png" alt></p>
<p>由于ModelViewSet有较高的抽象，实现自动增删改查功能。对于增、改在很多场景无法 满足需求，这就需要重写对应方法了。</p>
<p><img src="/images/2D5D75FC1F9746129AE39594AE97CF5Fclipboard.png" alt></p>
]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title>es集群部署搭建</title>
    <url>/2021/07/01/es%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>需求背景：</p>
<p>• 业务发展越来越庞大，服务器越来越多</p>
<p>• 各种访问日志、应用日志、错误日志量越来越多</p>
<p>• 开发人员排查问题，需要到服务器上查日志，效率低、权限不好控制</p>
<p>• 运维需实时关注业务访问情况</p>
<p>ELK 介绍</p>
<p>ELK 是三个开源软件的缩写，提供一套完整的企业级日志平台解决方案。</p>
<p>分别是：</p>
<p>• Elasticsearch：搜索、分析和存储数据</p>
<p>• Logstash ：采集日志、格式化、过滤，最后将数据推送到Elasticsearch存储</p>
<p>• Kibana：数据可视化</p>
<p>• Beats ：集合了多种单一用途数据采集器，用于实现从边缘机器向 Logstash 和 Elasticsearch 发送数据。里面应用最多的是Filebeat，是一个轻量级日志采集器。</p>
<p>ELK 架构</p>
<p><img src="/images/309B516B5F4845EEA1276D3F81723F92clipboard.png" alt></p>
<p>Elasticsearch</p>
<p>Elasticsearch（简称ES）是一个分布式、RESTful 风格的搜索和数据分析引擎， 用于集中存储日志数据。</p>
<p>Elasticsearch术语：</p>
<p>• Index：索引是多个文档的集合</p>
<p>• Document：Index里每条记录称为Document，若干文档构建一个Index</p>
<p>• Type：一个Index可以定义一种或多种类型，将Document逻辑分组</p>
<p>• Field：ES存储的最小单元</p>
<p><img src="/images/925765D488F24475BB04C6B3469D54CEclipboard.png" alt></p>
<p>ES 部署</p>
<p>下载地址：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p>
<p>支持多种部署方式：</p>
<p>• 二进制包    • yum      • rpm     • docker</p>
<p>二进制部署（集群方式安装，3台节点一样）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt/elk</span><br><span class="line">tar -zxf elasticsearch-7.9.3-linux-x86_64.tar.gz </span><br><span class="line"><span class="built_in">mv</span> elasticsearch-7.9.3-linux-x86_64.tar.gz  /opt/elk/elasticsearch</span><br><span class="line">useradd es <span class="comment"># 出于安全考虑，默认不能用root账号启动 </span></span><br><span class="line"><span class="built_in">chown</span> -R es:es elasticsearch</span><br><span class="line"></span><br><span class="line">启动先决条件： </span><br><span class="line">• 调整进程最大打开文件数数量 </span><br><span class="line"><span class="comment"># 临时设置 ulimit -n 65535 </span></span><br><span class="line"><span class="comment"># 永久设置，重启生效 vi /etc/security/limits.conf </span></span><br><span class="line">* hard nofile 65535 </span><br><span class="line">* soft nofile 65535</span><br><span class="line"></span><br><span class="line">• 调整进程最大虚拟内存区域数量 </span><br><span class="line"><span class="comment"># 临时设置 sysctl -w vm.max_map_count=262144 </span></span><br><span class="line"><span class="comment"># 永久设置 echo &quot;vm.max_map_count=262144&quot; &gt;&gt; /etc/sysctl.conf </span></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改配置文件（集群方式）</p>
<p>节点1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim config/elasticsearch.yml </span></span><br><span class="line">cluster.name: elk-cluster <span class="comment"># 集群名称 </span></span><br><span class="line">node.name: node-1 <span class="comment"># 集群节点名称 </span></span><br><span class="line"><span class="comment">#path.data: /path/to/data # 数据目录 </span></span><br><span class="line"><span class="comment">#path.logs: /path/to/logs # 日志目录 </span></span><br><span class="line">network.host: 0.0.0.0 <span class="comment"># 监听地址 </span></span><br><span class="line">http.port: 9200 <span class="comment"># 监听端口 </span></span><br><span class="line"><span class="comment"># transport.tcp.port: 9300 #内部节点之间通信端口 </span></span><br><span class="line">discovery.seed_hosts: [<span class="string">&quot;192.168.0.11&quot;</span>, <span class="string">&quot;192.168.0.12&quot;</span>,<span class="string">&quot;192.168.0.13&quot;</span>]<span class="comment"># 集群节点列表 </span></span><br><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;node-1&quot;</span>] <span class="comment"># 首次启动指定的Master节点</span></span><br></pre></td></tr></table></figure>
<p>节点2，3配置注意：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#节点名称更改</span></span><br><span class="line">node.name: node-2 <span class="comment"># 集群节点名称 </span></span><br><span class="line">node.name: node-3 <span class="comment"># 集群节点名称 </span></span><br><span class="line"><span class="comment">#在节点2或节点3不启用cluster.initial_master_nodes参数，注释掉</span></span><br></pre></td></tr></table></figure>
<p>配置系统服务管理（3台节点一样）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/elasticsearch.service </span><br><span class="line">[Unit]</span><br><span class="line">Description=elasticsearch</span><br><span class="line">[Service]</span><br><span class="line">User=es</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line">ExecStart=/opt/elk/elasticsearch/bin/elasticsearch</span><br><span class="line">ExecReload=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看集群节点：</span><br><span class="line">curl -XGET <span class="string">&#x27;http://127.0.0.1:9200/_cat/nodes?pretty&#x27;</span> </span><br><span class="line">查询集群状态： </span><br><span class="line">curl -i -XGET http://127.0.0.1:9200/_cluster/health?pretty</span><br></pre></td></tr></table></figure>
<p>图形页面管理ES</p>
<p>管理ES的图形页面系统推荐：</p>
<p>• ElasticHD</p>
<p>• cerebro</p>
<p>部署ElasticHD（直接解压后台启动，端口是9800）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip elasticHD_linux_amd64.zip -d /opt/elk/</span><br><span class="line"><span class="built_in">cd</span> /opt/elk/</span><br><span class="line"><span class="built_in">nohup</span> ./ElasticHD &amp;</span><br><span class="line"><span class="built_in">tail</span> -f nohup.out </span><br></pre></td></tr></table></figure>
<p><img src="/images/F867066D7EF24F008064D1921424A05Fclipboard.png" alt></p>
<p>最后我想说的是，部署了3个节点，如果节点2和节点3的elasticsearch目录下的配置文件是从节点1（master节点）复制过来的，那么就要删除/opt/elk/elasticsearch/data目录下的nodes文件，之后重启节点2、3的es进程即可，否则只会显示一个master节点。</p>
<p>报错：搭建es集群，启动三个es节点，访问elasticsearch-head时只显示一个master</p>
<p>参考连接：</p>
<p><a href="https://blog.csdn.net/iot_learner/article/details/108640133">https://blog.csdn.net/iot_learner/article/details/108640133</a></p>
<p><a href="https://www.cnblogs.com/biehongli/p/11650045.html">https://www.cnblogs.com/biehongli/p/11650045.html</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK 系统架构优化</title>
    <url>/2021/07/11/elk%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>增加数据缓冲队列</p>
<p><img src="/images/D064ED61C4BA4889A67949829A8F405Bclipboard.png" alt></p>
<p>使用Redis作为消息队列，起到数据缓冲作用，也就是峰值处理能力。</p>
<p>filebeat相当于提供者，logstash相当于消费者。</p>
<p>当filebeat采集到日志，会把日志推送到redis中，redis就有数据了，紧接着logstash从redis拿到数据，经过处理推送到es，es通过kibana把日志展现出来。</p>
<p>1.找任意一台机器安装redis</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装redis</span></span><br><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install redis</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置文件</span></span><br><span class="line">vim /etc/redis.conf </span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0 </span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line">systemctl restart redis.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查redis是否有数据</span></span><br><span class="line">redis-cli -a 123456</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>
<p>2、filebeat配置输出到redis</p>
<p>vim /etc/filebeat/filebeat.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/test/product.log</span><br><span class="line">  tags: [<span class="string">&quot;nginx&quot;</span>]</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  fields:</span><br><span class="line">    project: microservice</span><br><span class="line">    app: product</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/test/gateway.log</span><br><span class="line">  tags: [<span class="string">&quot;nginx&quot;</span>]</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  fields:</span><br><span class="line">    project: microservice</span><br><span class="line">    app: gateway</span><br><span class="line">    </span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/nginx/access.log</span><br><span class="line">  tags: [<span class="string">&quot;nginx&quot;</span>]</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  fields:</span><br><span class="line">    project: microservice</span><br><span class="line">    app: nginx</span><br><span class="line">  multiline.pattern: <span class="string">&#x27;^\s&#x27;</span></span><br><span class="line">  multiline.negate: <span class="literal">false</span></span><br><span class="line">  multiline.match: after</span><br><span class="line"></span><br><span class="line"><span class="comment">#output.logstash:</span></span><br><span class="line"><span class="comment">#  hosts: [&quot;192.168.0.11:5044&quot;]</span></span><br><span class="line"></span><br><span class="line">output.redis:</span><br><span class="line">  hosts: [<span class="string">&quot;192.168.0.12:6379&quot;</span>]</span><br><span class="line">  password: <span class="string">&quot;123456&quot;</span></span><br><span class="line">  key: <span class="string">&quot;filebeat&quot;</span></span><br><span class="line">  db: 0</span><br><span class="line">  datatype: <span class="string">&quot;list&quot;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart filebeat.service </span><br></pre></td></tr></table></figure>
<p>3、检查redis是否有数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># redis-cli -a 123456</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;filebeat&quot;</span></span><br></pre></td></tr></table></figure>
<p>4 、logstash配置从redis 里 读</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    host =&gt; <span class="string">&quot;192.168.0.12&quot;</span></span><br><span class="line">    port =&gt; 6379</span><br><span class="line">    password =&gt; <span class="string">&quot;123456&quot;</span></span><br><span class="line">    key =&gt; <span class="string">&quot;filebeat&quot;</span></span><br><span class="line">    db =&gt; 0</span><br><span class="line">    data_type =&gt; <span class="string">&quot;list&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  json &#123;</span><br><span class="line">    <span class="built_in">source</span> =&gt; <span class="string">&quot;message&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [app] == <span class="string">&quot;product&quot;</span> and [project] == <span class="string">&quot;microservice&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;microservice-product-%&#123;+YYYY.MM&#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> [app] == <span class="string">&quot;gateway&quot;</span> and [project] == <span class="string">&quot;microservice&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;microservice-gateway-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> [app] == <span class="string">&quot;nginx&quot;</span> and [project] == <span class="string">&quot;microservice&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;microservice-nginx-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;unknown-%&#123;+YYYY&#125;&quot;</span></span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">  hosts =&gt; <span class="string">&quot;192.168.0.11:9200&quot;</span></span><br><span class="line">  index =&gt; <span class="string">&quot;%&#123;[@metadata][target_index]&#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>5 、验证访问</p>
<p>访问nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl 192.168.0.13</span><br></pre></td></tr></table></figure>
<p>在kibana页面上查看</p>
<p><img src="/images/E5BDE64D775A4A17ABE0993479991D2Aclipboard.png" alt></p>
<p>redis学习：</p>
<p><a href="https://www.runoob.com/redis/redis-pub-sub.html">https://www.runoob.com/redis/redis-pub-sub.html</a></p>
<p><a href="https://blog.csdn.net/liqingtx/article/details/60330555">https://blog.csdn.net/liqingtx/article/details/60330555</a></p>
<p>未来架构扩容思路</p>
<p>如果日志量每天100G以上，还需要增加更多的服务器支撑。</p>
<p>例如扩容：</p>
<p>• Logstash</p>
<p>• Elasticsearch</p>
<p><img src="/images/B1B44D0BB0C343EFAE148EABD7414162clipboard.png" alt></p>
<p>其他优化点</p>
<p>• 在预算充足情况下，服务器硬件配置尽量高</p>
<p>• 根据业务，规划好索引</p>
<p>• 不用的索引可以删除或者关闭</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭索引</span></span><br><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/microservice-gateway-2020.11*/_close?pretty&quot;</span> <span class="comment"># 开启用_open </span></span><br><span class="line"><span class="comment">#删除索引</span></span><br><span class="line">curl -XDELETE <span class="string">&quot;http://127.0.0.1:9200/microservice-gateway-2020.11*&quot;</span></span><br></pre></td></tr></table></figure>
<p>kafka学习：</p>
<p><a href="https://www.cnblogs.com/qingyunzong/p/9004509.html">https://www.cnblogs.com/qingyunzong/p/9004509.html</a></p>
<p><a href="https://www.cnblogs.com/bainianminguo/p/12247158.html">https://www.cnblogs.com/bainianminguo/p/12247158.html</a></p>
<p><a href="https://blog.csdn.net/u012129558/article/details/80065869">https://blog.csdn.net/u012129558/article/details/80065869</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>Filebeat日志采集器</title>
    <url>/2021/07/02/filebeat%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<p>Filebeat介绍</p>
<p>Filebeat是一个轻量级的日志采集器，将采集的数据推送到Logstash、ES存储。</p>
<p><img src="/images/C1902C66718F43198DE38A9046887E62clipboard.png" alt></p>
<p>Filebeat部署</p>
<p>采用RPM安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh filebeat-7.9.3-x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>配置文件详解：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /etc/filebeat/filebeat.yml</span></span><br><span class="line"><span class="comment"># 配置不同的输入</span></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 是否启用该输入配置</span></span><br><span class="line">enabled: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 采集的日志文件路径，可以通配</span></span><br><span class="line">paths:</span><br><span class="line">- /var/log/*.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 正则匹配要排除的行，这里以DBG开头的行都过滤掉</span></span><br><span class="line"><span class="comment">#exclude_lines: [&#x27;^DBG&#x27;]</span></span><br><span class="line"><span class="comment"># 正则匹配要采集的行，这里以ERR/WARN开头的行都采集</span></span><br><span class="line"><span class="comment">#include_lines: [&#x27;^ERR&#x27;, &#x27;^WARN&#x27;]</span></span><br><span class="line"><span class="comment"># 排除的文件，默认采集所有</span></span><br><span class="line"><span class="comment">#exclude_files: [&#x27;.gz$&#x27;]</span></span><br><span class="line"><span class="comment"># 添加标签</span></span><br><span class="line"><span class="comment">#tags: [&quot;nginx&quot;]</span></span><br><span class="line"><span class="comment"># 下面fields添加的字段默认是在fields.xxx，可以设置在顶级对象下</span></span><br><span class="line"><span class="comment"># fields_under_root: true</span></span><br><span class="line"><span class="comment"># 自定义添加的字段，一般用于标记日志来源</span></span><br><span class="line"><span class="comment">#fields:</span></span><br><span class="line"><span class="comment"># level: debug</span></span><br><span class="line"><span class="comment"># review: 1</span></span><br></pre></td></tr></table></figure>
<p>推送到Logstash或ES</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#推送到Logstash：</span></span><br><span class="line">output.logstash:</span><br><span class="line">hosts: [<span class="string">&quot;192.168.0.11:5044&quot;</span>]</span><br><span class="line"><span class="comment">#推送到ES：</span></span><br><span class="line">setup.ilm.enabled: <span class="literal">false</span></span><br><span class="line">setup.template.name: <span class="string">&quot;microservice-product&quot;</span></span><br><span class="line">setup.template.pattern: <span class="string">&quot;microservice-product-*&quot;</span></span><br><span class="line">output.elasticsearch:</span><br><span class="line">hosts: [<span class="string">&quot;localhost:9200&quot;</span>]</span><br><span class="line">index: <span class="string">&quot;microservice-product-%&#123;+yyyy.MM.dd&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>配置采集指定日志，修改配置文件(适用于一个服务器上采集多个服务日志）</p>
<p>vim /etc/filebeat/filebeat.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/test/product.log</span><br><span class="line">  tags: [<span class="string">&quot;nginx&quot;</span>]</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  fields:</span><br><span class="line">    project: microservice</span><br><span class="line">    app: product</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/test/gateway.log</span><br><span class="line">  tags: [<span class="string">&quot;nginx&quot;</span>]</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  fields:</span><br><span class="line">    project: microservice</span><br><span class="line">    app: gateway</span><br><span class="line">    </span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">&quot;192.168.0.11:5044&quot;</span>]</span><br><span class="line">                               </span><br></pre></td></tr></table></figure>
<p>启动filebeat服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start filebeat.service </span><br><span class="line">ps -ef |grep filebeat</span><br></pre></td></tr></table></figure>
<p>logstash配置</p>
<p>修改logstash 配置文件</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">   host =&gt; <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">   port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  <span class="keyword">if</span> [app] == <span class="string">&quot;product&quot;</span> and [project] == <span class="string">&quot;microservice&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;microservice-product-%&#123;+YYYY.MM&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> [app] == <span class="string">&quot;gateway&quot;</span> and [project] == <span class="string">&quot;microservice&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;microservice-gateway-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;unknown-%&#123;+YYYY&#125;&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">  hosts =&gt; <span class="string">&quot;192.168.0.11:9200&quot;</span></span><br><span class="line">  index =&gt; <span class="string">&quot;%&#123;[@metadata][target_index]&#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>filebeat（部署在要采集日志的机器上）：</p>
<p>模拟数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /var/log/test</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is product&quot;</span> &gt; /var/log/test/product.log</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is gateway&quot;</span> &gt; /var/log/test/gateway.log</span><br></pre></td></tr></table></figure>
<p>在kibana页面上查看</p>
<p><img src="/images/1DD12196C9F3459BB27ADCA2E2EC36B5clipboard.png" alt></p>
<p><img src="/images/EF64D80E945142DE99E38A56AEB01E7Eclipboard.png" alt></p>
<p><img src="/images/11ADF00035A34719AB7F46AE1D13E4A9clipboard.png" alt></p>
<p><img src="/images/203C52E768FF4A8FA9166EB3600AD94Fclipboard.png" alt></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>Harbor部署</title>
    <url>/2022/05/25/harbor%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>Harbor 概述</p>
<p>Harbor是由VMWare公司开源的容器镜像仓库。事实上，Harbor是在Docker Registry上进行了相应的企业级扩展， 从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访问控制 ，AD/LDAP集成以及 审计日志等，足以满足基本企业需求。</p>
<p>官方：<a href="https://goharbor.io/">https://goharbor.io/</a></p>
<p>Github：<a href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p>
<p>Harbor 部署先决条件</p>
<p>服务器硬件配置：</p>
<p>最低要求：CPU2核/内存4G/硬盘40GB</p>
<p>推荐：CPU4核/内存8G/硬盘160GB</p>
<p>软件：</p>
<p>Docker CE 17.06版本+</p>
<p>Docker Compose 1.18版本+</p>
<p>Harbor安装有2种方式：</p>
<p>在线安装：从Docker Hub下载Harbor相关镜像，因此安装软件包非常小</p>
<p>离线安装：安装包包含部署的相关镜像，因此安装包比较大</p>
<p>Harbor 部署HTTP</p>
<p>1、先安装Docker和Docker Compose</p>
<p><a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p>
<p>2、部署Harbor HTTP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> docker-compose-Linux-x86_64 /usr/bin/docker-compose</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line">tar zxvf harbor-offline-installer-v2.0.0.tgz </span><br><span class="line"><span class="built_in">cd</span> harbor </span><br><span class="line"><span class="built_in">cp</span> harbor.yml.tmpl harbor.yml </span><br><span class="line"></span><br><span class="line">vi harbor.yml </span><br><span class="line">hostname: reg.azhe.com </span><br><span class="line"><span class="comment">#https: # 先注释https相关配置 </span></span><br><span class="line">harbor_admin_password: Harbor12345 </span><br><span class="line">./prepare</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>3、访问harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://reg.azhe.com/</span><br></pre></td></tr></table></figure>
<p><img src="/images/65FF30622A314D5391BD5ACBBEC52776clipboard.png" alt></p>
<p>Harbor 基本使用</p>
<p>1、配置http镜像仓库可信任（默认是https访问的，上面配置的是http，这里需要配置可信任)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置http镜像仓库可信任</span></span><br><span class="line">vi /etc/docker/daemon.json </span><br><span class="line">&#123;<span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;reg.azhe.com&quot;</span>]&#125; </span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment">#查看是否有harbor容器退出，重新停止再拉起</span></span><br><span class="line">docker-compose ps</span><br><span class="line">docker-compose down</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>2.配置本地hosts文件解析</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">192.168.0.11 reg.azhe.com</span><br></pre></td></tr></table></figure>
<p>3.登录harbbor,打标签，上传，下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login reg.azhe.com</span><br><span class="line">Username: admin</span><br><span class="line">Password: Harbor12345</span><br><span class="line"></span><br><span class="line">docker /images</span><br><span class="line">docker tag mysql:5.7 reg.azhe.com/library/mysql:5.7</span><br><span class="line">docker push reg.azhe.com/library/mysql:5.7</span><br><span class="line">docker pull reg.azhe.com/library/mysql:5.7</span><br></pre></td></tr></table></figure>
<p><img src="/images/158D447BE1A84A4C96A9CC38A8FF762Dclipboard.png" alt></p>
<p>Harbor 部署HTTPS</p>
<p>1、生成SSL证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ssl</span><br><span class="line"><span class="built_in">cd</span> ssl</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">ca-config.json  ca-key.pem  cfssl.sh               reg.azhe.com-key.pem</span><br><span class="line">ca.csr          ca.pem      reg.azhe.com.csr       reg.azhe.com.pem</span><br><span class="line">ca-csr.json     certs.sh    reg.azhe.com-csr.json</span><br></pre></td></tr></table></figure>
<p>vim <a href="http://cfssl.sh">cfssl.sh</a> (证书生成工具）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line"><span class="built_in">chmod</span> +x cfssl*</span><br><span class="line"><span class="built_in">mv</span> cfssl_linux-amd64 /usr/bin/cfssl</span><br><span class="line"><span class="built_in">mv</span> cfssljson_linux-amd64 /usr/bin/cfssljson</span><br><span class="line"><span class="built_in">mv</span> cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br></pre></td></tr></table></figure>
<p>vim <a href="http://certs.sh">certs.sh</a>(证书生成脚本）</p>
<p>#注意里面的域名修改为自己的harbor域名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ca-config.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;signing&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;default&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;expiry&quot;: &quot;87600h&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;profiles&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;kubernetes&quot;: &#123;</span></span><br><span class="line"><span class="string">         &quot;expiry&quot;: &quot;87600h&quot;,</span></span><br><span class="line"><span class="string">         &quot;usages&quot;: [</span></span><br><span class="line"><span class="string">            &quot;signing&quot;,</span></span><br><span class="line"><span class="string">            &quot;key encipherment&quot;,</span></span><br><span class="line"><span class="string">            &quot;server auth&quot;,</span></span><br><span class="line"><span class="string">            &quot;client auth&quot;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; ca-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;CN&quot;: &quot;kubernetes&quot;,</span></span><br><span class="line"><span class="string">    &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">        &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;names&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">            &quot;L&quot;: &quot;Beijing&quot;,</span></span><br><span class="line"><span class="string">            &quot;ST&quot;: &quot;Beijing&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; reg.azhe.com-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;reg.azhe.com&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;BeiJing&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes reg.azhe.com-csr.json | cfssljson -bare reg.azhe.com </span><br></pre></td></tr></table></figure>
<p>2、Harbor启用HTTPS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi harbor.yml</span><br><span class="line">https:</span><br><span class="line">  port: 443</span><br><span class="line">   certificate: /root/ssl/reg.azhe.com.pem     <span class="comment">#指定你生成的数字证书</span></span><br><span class="line">   private_key: /root/ssl/reg.azhe.com-key.pem   <span class="comment">#指定key</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>3、重新配置并部署Harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./prepare </span><br><span class="line">docker-compose down </span><br><span class="line">docker-compose up –d</span><br></pre></td></tr></table></figure>
<p>4、修改Docker启动文件添加“–insecure-registry <a href="http://reg.azhe.com">reg.azhe.com</a>”并配置hosts文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service </span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry reg.azhe.com</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br><span class="line">vim /etc/hosts</span><br><span class="line">192.168.0.11 reg.azhe.com</span><br></pre></td></tr></table></figure>
<p>5、验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login reg.azhe.com</span><br><span class="line">Username: admin</span><br><span class="line">Password: Harbor12345</span><br><span class="line"></span><br><span class="line">docker /images</span><br><span class="line">docker pull reg.azhe.com/library/mysql:5.7</span><br></pre></td></tr></table></figure>
<p>以上harbor部署https方式的第4步骤，如果配置完成后，在docker主机登录harbor报证书错误，那么可以通过以下方式解决或参考链接：</p>
<p>4.将数字证书复制到Docker主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp reg.azhe.com.pem root@192.168.0.13:~   <span class="comment">#拷贝到要登录harbor的docker客户端</span></span><br><span class="line"><span class="built_in">mkdir</span> /etc/docker/certs.d/reg.azhe.com</span><br><span class="line"><span class="built_in">cp</span> reg.azhe.com.pem /etc/docker/certs.d/reg.azhe.com/reg.azhe.com.crt</span><br></pre></td></tr></table></figure>
<p>参考链接</p>
<p><a href="https://blog.csdn.net/chenglang0914/article/details/100833054">https://blog.csdn.net/chenglang0914/article/details/100833054</a></p>
<p>Harbor 主从复制</p>
<p><img src="/images/B77A284AA7994A2894263F4F287452E8clipboard.png" alt></p>
<p>主备模式</p>
<p>1.准备备机harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> docker-compose-Linux-x86_64 /usr/bin/docker-compose</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line">tar -zxf harbor-offline-installer-v2.0.0.tgz</span><br><span class="line"><span class="built_in">cd</span> harbor </span><br><span class="line"><span class="built_in">cp</span> harbor.yml.tmpl harbor.yml </span><br><span class="line"></span><br><span class="line">vi harbor.yml </span><br><span class="line">hostname: 192.168.0.12</span><br><span class="line"><span class="comment">#https: # 先注释https相关配置 </span></span><br><span class="line">harbor_admin_password: Harbor12345 </span><br><span class="line">./prepare</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>2.在主harbor页面配置主从复制和规则</p>
<p><img src="/images/2A099C79ECDB4C83B3D5917E0BDA3BE6clipboard.png" alt></p>
<p><img src="/images/2726A20B44774F2EABFB8A0F45DDC380clipboard.png" alt></p>
<p>3.客户端docker主机上传镜像到主harbor并验证是否复制到从harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login reg.azhe.com</span><br><span class="line">Username: admin</span><br><span class="line">Password: Harbor12345</span><br><span class="line"></span><br><span class="line">docker tag centos:7 reg.azhe.com/library/centos:7</span><br><span class="line">docker push reg.azhe.com/library/centos:7</span><br></pre></td></tr></table></figure>
<p><img src="/images/F29DE1853ED34C21961D7A4A2EEB9CADclipboard.png" alt></p>
<p><img src="/images/FF5C2BF9C43248F4AE5521F5F200F61Cclipboard.png" alt></p>
<p><img src="/images/71319B66EA1E4E36A28CDFA7BE80681Eclipboard.png" alt></p>
<p>Harbor 运维维护</p>
<p><img src="/images/4CBC3EA772514E54B38302F5409C461Aclipboard.png" alt></p>
<p>容器数据持久化目录：/data</p>
<p>日志文件目录：/var/log/harbor</p>
<p>PG数据库做好定期备份，里面存放用户数据文件。</p>
<p>主从复制，主harbor挂掉，启用备harbor，需要把pg数据导入到备harbor。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Grafana可视化展示</title>
    <url>/2021/09/12/grafana%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<p>Grafana是一个开源的度量分析和可视化系统。</p>
<p>官方文档：<a href="https://grafana.com/docs/grafana/latest/">https://grafana.com/docs/grafana/latest/</a></p>
<p>部署文档：<a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a></p>
<p>访问地址：<a href="http://IP:3000">http://IP:3000</a> 用户名/密码：admin/admin # 第一次需要重置密码</p>
<p><img src="/images/8147217BB90942D69846D00CACDCC61Bclipboard.png" alt></p>
<p>Grafana只用于展示数据，但这个数据从哪里来？ 需要你根据提供数据的服务选择，支持的数据源如下：</p>
<p><img src="/images/6F6204B182544C5B84C11A3C74B66ACFclipboard.png" alt></p>
<p>自定义仪表盘：设置导航栏</p>
<p><img src="/images/0D776FDD1869433BADD035BC6AD3A208clipboard.png" alt></p>
<p><img src="/images/2F5D00EB42EA4810B0665E58CF9630F4clipboard.png" alt></p>
<p><img src="/images/22841E0DE83F42D9B34390203D93B448clipboard.png" alt></p>
<p><img src="/images/57725349ECFE49B68B4D5EC4C5DAEC0Cclipboard.png" alt></p>
<p><img src="/images/782C171F3F8D4A4FBEF4B165C5FF3D46clipboard.png" alt></p>
<p><img src="/images/57FD99DC7CC345E78F7FB72516B2072Bclipboard.png" alt></p>
<p><img src="/images/54E87CC8B5844337BE512E3414860D1Cclipboard.png" alt></p>
<p><img src="/images/BFDB17230CEF4073A35299F4060C3AB7clipboard.png" alt></p>
<p>最终实现简单效果图</p>
<p><img src="/images/9F290CEB439346DAB84BA877C944F9E5clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>html标记语言</title>
    <url>/2024/03/20/html%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h2 id="HTML介绍">HTML介绍</h2>
<p>HTML：是一种用于创建网页的标记语言, 可以使用HTML创建网页，用浏览器打开会自动解析。 HTML是由标签和内容构成。</p>
<p>HTML代码结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>文档的标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    文档的内容...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="文本格式化标签">文本格式化标签</h2>
<p><img src="/images/BB54CDF5CBC54AD681152B95CBB714DFclipboard.png" alt></p>
<h2 id="列表标签">列表标签</h2>
<p><img src="/images/76B2F130801645C191AD275F774ADD27clipboard.png" alt></p>
<h2 id="超链接标签">超链接标签</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">超链接标签： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;网址&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/76DCD4E8E1004F0DB14758D987B0BEE2clipboard.png" alt></p>
<h2 id="图片标签">图片标签</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片文件路径&quot;</span><span class="attr">alt</span>=<span class="string">&quot;图片提示&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/1519A88B46774311AD5057A96644A2B3clipboard.png" alt></p>
<h2 id="表格标签">表格标签</h2>
<ul>
<li>
<p>table 表格标签</p>
</li>
<li>
<p>thead 表格标题</p>
</li>
<li>
<p>tr 行标签</p>
</li>
<li>
<p>th 列名</p>
</li>
<li>
<p>tbody 表格内容</p>
</li>
<li>
<p>tr 列标签</p>
</li>
<li>
<p>td 列内容</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>主机名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>IP<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作系统<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>www.baidu.com<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>192.168.1.10<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>CentOS7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="表单标签">表单标签</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">表单标签：<span class="tag">&lt;<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/8035D25E91604F92AEE6CA3BECDD16AAclipboard.png" alt></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">表单项标签：<span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/0BF3EF399930475F863524B33917ED33clipboard.png" alt></p>
<h2 id="列表标签-2">列表标签</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">下拉列表标签：<span class="tag">&lt;<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/7685FD83BBAC45B494C1A0489ECC95BAclipboard.png" alt></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">下拉列表选项标签：<span class="tag">&lt;<span class="name">option</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/1543C2289E4D45C9A1F9749D9C79F0F2clipboard.png" alt></p>
<h2 id="按钮标签">按钮标签</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">按钮标签：<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>type可选值：</p>
<ul>
<li>
<p>button：普通</p>
</li>
<li>
<p>submit：提交</p>
</li>
<li>
<p>reset：重置</p>
</li>
</ul>
<h2 id="div标签">div标签</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>标签用于在HTML文档中定义一个区块。常用于将标签集中起来，然后用样式对它们进行统一排版。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript库-jQuery简化编程</title>
    <url>/2024/03/23/javascript%E5%BA%93-jQuery%E7%AE%80%E5%8C%96%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="jQuery介绍">jQuery介绍</h2>
<p>jQuery 是一个 JavaScript 库。极大地简化了 JavaScript 编程，例如JS原生代码几十行 实现的功能，jQuery可能一两行就可以实现，因此得到前端程序猿广泛应用。</p>
<p>官方网站： <a href="https://jquery.com">https://jquery.com</a></p>
<p>发展至今，主要有三个大版本：</p>
<ul>
<li>
<p>1.x：常用版本</p>
</li>
<li>
<p>2.x，3.x：除非特殊要求，一般用的少</p>
</li>
</ul>
<h2 id="基本使用">基本使用</h2>
<p>下载地址：</p>
<p><a href="https://cdn.bootcdn.net/ajax/libs/jquery/1.12.4/jquery.min.js">https://cdn.bootcdn.net/ajax/libs/jquery/1.12.4/jquery.min.js</a></p>
<p>jQuery代码编写位置与JS位置一样，但需要先head标签里引入jquery.min.js文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/1.12.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// jquery代码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>JQuery语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span>&gt;点我&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">$(<span class="string">&quot;#btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&#x27;亲，有什么可以帮助你的？&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>基础语法是：$(selector).action()</p>
<ul>
<li>
<p>$：代表jQuery本身</p>
</li>
<li>
<p>(selector)：选择器，查找HTML元素</p>
</li>
<li>
<p>action()：对元素的操作</p>
</li>
</ul>
<p>JS语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span>&gt;点我&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    x.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&#x27;亲，有什么可以帮助你的？&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="选择器">选择器</h2>
<p><img src="/images/7B8A45E0982946A4A7A8CEEFFAAE6EB4clipboard.png" alt></p>
<h2 id="操作HTML">操作HTML</h2>
<p>隐藏和显示元素：</p>
<ul>
<li>
<p>hide() ：隐藏某个元素</p>
</li>
<li>
<p>show() ：显示某个元素</p>
</li>
<li>
<p>toggle() ：hide()和show()方法之间切换</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;demo&quot;</span>&gt;这是一个段落。&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;hide&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>显示<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;toggle&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>切换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $(<span class="string">&quot;#hide&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $(<span class="string">&quot;p&quot;</span>).<span class="title function_">hide</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $(<span class="string">&quot;#show&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $(<span class="string">&quot;p&quot;</span>).<span class="title function_">show</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $(<span class="string">&quot;#toggle&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $(<span class="string">&quot;p&quot;</span>).<span class="title function_">toggle</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>获取与设置内容：</p>
<ul>
<li>
<p>text() 设置或返回所选元素的文本内容</p>
</li>
<li>
<p>html() 设置或返回所选元素的HTML内容</p>
</li>
<li>
<p>val() 设置或返回表单字段的值</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;txt&quot;</span>&gt;这是一个&lt;b&gt;段落&lt;<span class="regexp">/b&gt;。&lt;/</span>p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>显示文本<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>显示HTML<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $(<span class="string">&quot;#btn1&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        x = $(<span class="string">&quot;#txt&quot;</span>).<span class="title function_">text</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $(<span class="string">&quot;#demo&quot;</span>).<span class="title function_">text</span>(x).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>)   <span class="comment">//不会解析b标签</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $(<span class="string">&quot;#btn2&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        x = $(<span class="string">&quot;#txt&quot;</span>).<span class="title function_">html</span>();   <span class="comment">//获取</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $(<span class="string">&quot;#demo&quot;</span>).<span class="title function_">html</span>(x).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>)   <span class="comment">//会解析b标签，.html()设置</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;欢迎访问运维管理系统&lt;/h1&gt;</span><br><span class="line">用户名：&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;uname&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">密码：&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;pwd&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;&lt;br&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>显示输入内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>   </span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $(<span class="string">&quot;#btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        x = $(<span class="string">&quot;#uname&quot;</span>).<span class="title function_">val</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        y = $(<span class="string">&quot;#pwd&quot;</span>).<span class="title function_">val</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $(<span class="string">&quot;#demo&quot;</span>).<span class="title function_">text</span>(x + <span class="string">&#x27;，&#x27;</span> + y).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>)  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>设置CSS样式：</p>
<ul>
<li>
<p>css() 设置或返回样式属性（键值）</p>
</li>
<li>
<p>addClass() 向被选元素添加一个或多个类样式</p>
</li>
<li>
<p>removeClass() 从被选元素中删除一个或多个类样式</p>
</li>
<li>
<p>toggleClass() 对被选元素进行添加/删除类样式的切换操作</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>添加样式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $(<span class="string">&quot;#btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $(<span class="string">&quot;#demo p&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// $(&quot;#demo p&quot;).css(&#123;&quot;color&quot;:&quot;red&quot;,&quot;font-size&quot;: &quot;30px&quot;&#125;)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// $(&quot;#demo&quot;).addClass(&quot;cls&quot;)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// $(&quot;#demo&quot;).removeClass(&quot;cls&quot;)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Ajax-前后端数据交互">Ajax 前后端数据交互</h2>
<p>Ajax（Asynchronous JavaScript And XML，异步JavaScript和XML），AJAX 是一种在无需重新加载 整个网页的情况下，能够更新部分网页的技术。例如在不刷新页面的情况下查询数据、登录验证等</p>
<p>无刷新的好处：</p>
<ul>
<li>
<p>减少带宽、服务器负载</p>
</li>
<li>
<p>提高用户体验</p>
</li>
</ul>
<p><img src="/images/8C2DCF76B0494FBD948D190A3617084Eclipboard.png" alt></p>
<p>jQuery Ajax主要使用$.ajax()方法实现，用于向服务端发送HTTP请求。</p>
<p>语法：$.ajax([settings]);</p>
<p>settings 是$.ajax ( )方法的参数列表，用于配置 Ajax 请求的键值对集合，参数如下：</p>
<p><img src="/images/96F68165A7EA483EA35369F3D73B3B7Fclipboard.png" alt></p>
<p>Ajax使用案例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&#x27;demo&#x27;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;notice&#x27;</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $.<span class="title function_">ajax</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">type</span>: <span class="string">&quot;GET&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">url</span>: <span class="string">&quot;http://www.baidu.cn/test-table/user.json&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">result</span>) &#123;   <span class="comment">// result是API返回的JSON数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span>(result.<span class="property">code</span> == <span class="number">200</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">for</span> (i <span class="keyword">in</span> result.<span class="property">data</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                $(<span class="string">&#x27;#demo ul&#x27;</span>).<span class="title function_">append</span>(<span class="string">&quot;&lt;li&gt;&quot;</span> + result.<span class="property">data</span>[i][<span class="string">&#x27;username&#x27;</span>] + <span class="string">&quot;&lt;/li&gt;&quot;</span>); <span class="comment">// 将li标签追加到ul标签</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            $(<span class="string">&#x27;#notice&#x27;</span>).<span class="title function_">text</span>(<span class="string">&#x27;数据获取失败！&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $(<span class="string">&#x27;#notice&#x27;</span>).<span class="title function_">text</span>(<span class="string">&#x27;连接服务器失败，请稍后再试！&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>回调函数：参数引用一个函数，并将数据作为参数传递给该函数。</p>
<p><img src="/images/6891E606464148ECA6DAC9F7C92EF61Dclipboard.png" alt></p>
<p>jqXHR：一个XMLHttpRequest对象</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript客户端脚本语言</title>
    <url>/2024/03/22/javascript%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h2 id="JavaScript介绍，基本使用">JavaScript介绍，基本使用</h2>
<p><img src="/images/033CAC4185C845C6A0E9DCD3638C0883clipboard.png" alt></p>
<p>JavaScript（简称JS）：是一种轻量级客户端脚本语言，通常被直接嵌入 HTML 页面，在浏览器上执行。</p>
<p>JavaScript的主要用途：</p>
<ul>
<li>
<p>使网页具有交互性，例如响应用户点击，给用户提供更好的体验</p>
</li>
<li>
<p>处理表单，检验用户输入，并及时反馈提醒</p>
</li>
<li>
<p>浏览器与服务端进行数据通信，主要使用Ajax异步传输</p>
</li>
<li>
<p>在网页中添加标签，添加样式，改变标签属性等</p>
</li>
</ul>
<p>1、内部方式（内嵌样式），在body标签中使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    javaScript语言</span><br><span class="line">    --&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2、外部导入方式（推荐），在head标签中使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;my.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="title function_">alert</span>(name); <span class="comment">// 警告框方法，浏览器提示消息</span></span><br><span class="line">    <span class="comment">/* alert(&quot;你好&quot;) */</span>  <span class="comment">// 单行与多行注释  </span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="事件">事件</h2>
<p>事件：指的是当HTML中发生某些事件时所调用的方法（处理程序）。</p>
<p>例如点击按钮，点击后做相应操作，例如弹出一句话</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;亲，有什么可以帮助你的？&#x27;)&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>onclick：是一个常用CSS事件属性，当元素有鼠标点击时触发JS脚本。</p>
</li>
<li>
<p>alert()：是一个JS内置函数，在浏览器输出警告框。一般于代码测试，可判断脚本执行位置 或者输出变量值。</p>
</li>
</ul>
<h2 id="选择器">选择器</h2>
<p>想操作元素，必须先找到元素，主要通过以下三种方法：</p>
<ul>
<li>
<p>通过id（常用）</p>
</li>
<li>
<p>通过类名</p>
</li>
<li>
<p>通过标签名</p>
</li>
</ul>
<p>示例：通过id查找元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span>&gt;点我&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>); <span class="comment">//获取id为btn的元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    x.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;   <span class="comment">//绑定点击事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&#x27;亲，有什么可以帮助你的？&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>示例：通过标签名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;main&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world！1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world！2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world！3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;main&quot;</span>);  <span class="comment">//获取id为main的元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> y = x.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;p&quot;</span>);  <span class="comment">// 返回的是一个集合，下标获取</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;div中的第二段文本是：&quot;</span> + y[<span class="number">1</span>].<span class="property">innerHTML</span>);  <span class="comment">//向当前文档写入内容</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="JS操作HTML">JS操作HTML</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">插入内容：</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;p&gt;这是JS写入的段落&lt;/p&gt;&quot;</span>);  <span class="comment">//向文档写入HTML内容</span></span><br><span class="line">x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;demo&#x27;</span>); <span class="comment">//获取id为demo的元素</span></span><br><span class="line">x.<span class="property">innerHTML</span>=<span class="string">&quot;Hello&quot;</span>   <span class="comment">//向元素插入HTML内容</span></span><br><span class="line"></span><br><span class="line">改变标签属性：</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;image&quot;</span>).<span class="property">src</span>=<span class="string">&quot;b.jpg&quot;</span>   <span class="comment">//修改img标签src属性值</span></span><br><span class="line"></span><br><span class="line">改变标签样式：</span><br><span class="line">x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p&quot;</span>)  <span class="comment">//获取id为p的元素</span></span><br><span class="line">x.<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;blue&quot;</span>   <span class="comment">//字体颜色</span></span><br></pre></td></tr></table></figure>
<h2 id="数据类型：字符串、数组、对象">数据类型：字符串、数组、对象</h2>
<h3 id="数据类型：字符串">数据类型：字符串</h3>
<p>在JS中，数据类型有：字符串、数字、布尔、数组、对象、Null、Undefined</p>
<p>字符串处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">s.<span class="property">length</span>;  <span class="comment">// 字符串长度</span></span><br><span class="line">s[<span class="number">4</span>]   <span class="comment">//根据索引获取值</span></span><br><span class="line">s.<span class="title function_">replace</span>(<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;H&#x27;</span>);  <span class="comment">//替换某个字符</span></span><br><span class="line">s.<span class="title function_">split</span>(<span class="string">&quot;分隔符&quot;</span>)  <span class="comment">//分隔为数组</span></span><br><span class="line">s.<span class="title function_">match</span>(<span class="string">&quot;w&quot;</span>) <span class="comment">//找到返回匹配的字符，否则返回null</span></span><br></pre></td></tr></table></figure>
<p>字符串拼接：“+”</p>
<h3 id="数据类型：数组">数据类型：数组</h3>
<p>数组：是一个序列的数据结构。</p>
<p>定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> computer = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">或</span><br><span class="line"><span class="keyword">var</span> computer = [<span class="string">&quot;主机&quot;</span>,<span class="string">&quot;显示器&quot;</span>,<span class="string">&quot;键盘&quot;</span>,<span class="string">&quot;鼠标&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>向数组添加元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computer[<span class="number">0</span>]=<span class="string">&quot;主机&quot;</span>;</span><br><span class="line">computer[<span class="number">1</span>]=<span class="string">&quot;显示器&quot;</span>;</span><br><span class="line">computer[<span class="number">2</span>]=<span class="string">&quot;键盘&quot;</span>;</span><br><span class="line">或</span><br><span class="line">computer.<span class="title function_">push</span>(<span class="string">&quot;鼠标&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>通过索引获取元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computer[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3 id="数据类型：对象">数据类型：对象</h3>
<p>对象：是一个具有映射关系的数据结构。用于存储有一定关系的元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">格式：d = &#123;<span class="string">&#x27;key1&#x27;</span>:value1, <span class="string">&#x27;key2&#x27;</span>:value2, <span class="string">&#x27;key3&#x27;</span>:value3&#125;</span><br></pre></td></tr></table></figure>
<p>注意：对象通过key来访问value，因此字典中的key不允许重复。</p>
<p>定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;阿美&quot;</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="string">&quot;30&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过键查询值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">n = user.<span class="property">name</span>;</span><br><span class="line">或</span><br><span class="line">sex = user[<span class="string">&#x27;sex&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>增加或修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">user.<span class="property">height</span> = <span class="string">&quot;180cm&quot;</span></span><br><span class="line">user[<span class="string">&#x27;height&#x27;</span>] = <span class="string">&quot;180cm&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="操作符">操作符</h2>
<p>操作符：一个特定的符号，用它与其他数据 类型连接起来组成一个表达式。常用于条件 判断，根据表达式返回True/False采取动作。</p>
<p><img src="/images/35BE0A2A14EB445AA555EF06683E8F5Cclipboard.png" alt></p>
<h2 id="流程控制">流程控制</h2>
<h3 id="条件判断">条件判断</h3>
<p>if条件判断：判定给定的条件是否满足（True或False）， 根据判断的结果决定执行的语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">if</span> (表达式) &#123;</span><br><span class="line">    &lt;代码块&gt;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (表达式) &#123;</span><br><span class="line">    &lt;代码块&gt;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &lt;代码块&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/912A5B802DBE47FF8C7707289EB755D0clipboard.png" alt></p>
<p>示例：根据用户点击做不同操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img id=<span class="string">&quot;myimage&quot;</span> src=<span class="string">&quot;img/off.jpg&quot;</span> alt=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;changeImage(&#x27;on&#x27;)&quot;</span>&gt;</span>开灯<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;changeImage(&#x27;off&#x27;)&quot;</span>&gt;</span>关灯<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">changeImage</span>(<span class="params">status</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myimage&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (status == <span class="string">&#x27;on&#x27;</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            x.<span class="property">src</span> = <span class="string">&quot;img/on.jpg&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="string">&#x27;off&#x27;</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            x.<span class="property">src</span> = <span class="string">&quot;img/off.jpg&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/images/865ACBF92B7E4DA6864AB063CE239291clipboard.png" alt></p>
<h3 id="循环">循环</h3>
<p>for循环：一般用于遍历数据类型的元素进行处理，例如字符串、数组、对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">for</span> (&lt;变量&gt; <span class="keyword">in</span> &lt;序列&gt;) &#123;</span><br><span class="line">    &lt;代码块&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/ACE4A72B2A254D6EB98240F30B2DA3DCclipboard.png" alt></p>
<p>示例：遍历数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> computer = [<span class="string">&quot;主机&quot;</span>,<span class="string">&quot;显示器&quot;</span>,<span class="string">&quot;键盘&quot;</span>,<span class="string">&quot;鼠标&quot;</span>];</span><br><span class="line">方式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> computer) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(computer[i])  <span class="comment">// 使用索引获取值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方式<span class="number">2</span>：</span><br><span class="line">computer.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>示例：遍历对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;<span class="attr">name</span>:<span class="string">&quot;阿良&quot;</span>,<span class="attr">sex</span>:<span class="string">&quot;男&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;30&quot;</span>&#125;;</span><br><span class="line">方式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> user) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k + <span class="string">&quot;:&quot;</span> + user[k])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方式<span class="number">2</span>：</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(user).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">k</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k + <span class="string">&quot;:&quot;</span> + user[k]) </span><br><span class="line">&#125;)  </span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<h3 id="函数：定义与调用">函数：定义与调用</h3>
<p>函数：是指一段可以直接被另一段程序或代码引用的程序或代码。</p>
<p>在编写代码时，常将一些常用的功能模块编写成函数，放在函数库中供公共使用，可 减少重复编写程序段和简化代码结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">function</span> 函数名称(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...) &#123;</span><br><span class="line">    &lt;代码块&gt;</span><br><span class="line">    <span class="keyword">return</span> &lt;表达式&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span> onclick=<span class="string">&quot;hello()&quot;</span>&gt;你好&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数参数：接收参数">函数参数：接收参数</h3>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;myFunc(&#x27;阿强&#x27;, &#x27;30&#x27;)&quot;</span>&gt;点我&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params">name, age</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&quot;欢迎&quot;</span> + name + <span class="string">&quot;, 今年&quot;</span> + age);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="函数：匿名函数与箭头函数">函数：匿名函数与箭头函数</h3>
<p>匿名函数与箭头函数：没有名字的函数，一般仅用于单个表达式。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 普通函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sum1</span>(<span class="params">x,y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匿名函数</span></span><br><span class="line">    sum2 = <span class="keyword">function</span>(<span class="params">x,y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 箭头函数，相比匿名函数又简化了很多</span></span><br><span class="line">    sum3 = <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum1</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum2</span>(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum3</span>(<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Window对象：location属性">Window对象：location属性</h2>
<p>示例：刷新按钮</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;location.reload()&quot;</span>&gt;刷新当前页面&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;location.href=location.href&quot;</span>&gt;</span>重新请求当前页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;location.href=&#x27;http://www.baidu.com&#x27;&quot;</span>&gt;</span>请求别的页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Ingress最佳方式对外暴露应用</title>
    <url>/2022/07/10/ingress%E6%9C%80%E4%BD%B3%E6%96%B9%E5%BC%8F%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Ingress是什么">Ingress是什么</h2>
<p>NodePort存在的不足：</p>
<ul>
<li>
<p>一个端口只能一个服务使用，端口需提前规划</p>
</li>
<li>
<p>只支持4层负载均衡</p>
</li>
</ul>
<p>Ingress：Ingress公开了从集群外部到集群内服务的HTTP和HTTPS路由的规则集合，而具体实现流量路 由则是由Ingress Controller负责。</p>
<ul>
<li>
<p>Ingress：K8s中的一个抽象资源，给管理员 提供一个暴露应用的入口定义方法</p>
</li>
<li>
<p>Ingress Controller：根据Ingress生成具体 的路由规则，并对Pod负载均衡器</p>
</li>
</ul>
<p><img src="/images/A2C7CDD3D8F548A98C5BF3FF5833B996clipboard.png" alt></p>
<h2 id="Ingress-Controller">Ingress Controller</h2>
<p>Ingress Controller有很多实现，我们这里采用官方维护的Nginx控制器。</p>
<p>项目地址：<a href="https://github.com/kubernetes/ingress-nginx">https://github.com/kubernetes/ingress-nginx</a></p>
<p>部署：kubectl apply -f <a href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx0.30.0/deploy/static/mandatory.yaml">https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx0.30.0/deploy/static/mandatory.yaml</a></p>
<p>注意事项：</p>
<ul>
<li>
<p>镜像地址修改成国内的：lizhenliang/nginx-ingress-controller:0.30.0</p>
</li>
<li>
<p>将Ingress Controller暴露，一般使用宿主机网络（hostNetwork: true）或者使用NodePort</p>
</li>
</ul>
<p>其他控制器：<a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/</a></p>
<h2 id="Ingress">Ingress</h2>
<p>部署deployment与serivce</p>
<p>vim web1-deploy-svc.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web1</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web1</span><br><span class="line">        image: nginx:1.15</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web1</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">   <span class="comment"># nodePort: 30009    #nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web1-deploy-svc.yaml </span><br><span class="line">kubectl get svc</span><br><span class="line">curl 10.99.227.165</span><br></pre></td></tr></table></figure>
<p>部署ingress（基于域名方式访问）</p>
<p>vim ingress-web1.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: web1</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: web1.ctnrs.com        <span class="comment">#域名</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web1            <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 80          <span class="comment">#ClusterIP的端口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="http://xn--web1-z03g362j2w5b9jdn63a.ctnrs.com">浏览器访问web1.ctnrs.com</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ingress-web1.yaml </span><br><span class="line">kubectl get ingress</span><br></pre></td></tr></table></figure>
<p>测试：本地电脑绑定hosts记录对应ingress里面配置的域名</p>
<p>例： &lt;Ingress Controller Pod所在Node IP&gt; <a href="http://foo.bar.com">foo.bar.com</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n ingress-nginx -o wide</span><br></pre></td></tr></table></figure>
<h2 id="Ingress：基于URI路由多个服务">Ingress：基于URI路由多个服务</h2>
<p>vim web2-deploy-svc.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web2</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web2 <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.15</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web2</span><br><span class="line">  name: web2</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">   <span class="comment"># nodePort: 30009    #nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web2 <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim web22-deploy-svc.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web22</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web22</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web22 <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web22</span><br><span class="line">        image: lizhenliang/java-demo</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web22</span><br><span class="line">  name: web22</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 8080 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 8080 <span class="comment"># 容器端口</span></span><br><span class="line">   <span class="comment"># nodePort: 30009    #nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web22 <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim ingress-web2.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: web2</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /<span class="variable">$2</span></span><br><span class="line">    nginx.ingress.kubernetes.io/server-snippet: |</span><br><span class="line">      rewrite ^/css/(.*)$ /bar/css/<span class="variable">$1</span> redirect;</span><br><span class="line">      rewrite ^/images/(.*)$ /bar/images/<span class="variable">$1</span> redirect;</span><br><span class="line">      rewrite ^/js/(.*)$ /bar/js/<span class="variable">$1</span> redirect;</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: web2.ctnrs.com        <span class="comment">#域名</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /foo                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web2            <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 80          <span class="comment">#ClusterIP的端口</span></span><br><span class="line">      - path: /bar(/|$)(.*)                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web22            <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 8080          <span class="comment">#ClusterIP的端口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web2-deploy-svc.yaml </span><br><span class="line">kubectl apply -f web22-deploy-svc.yaml </span><br><span class="line">kubectl apply -f ingress-web2.yaml </span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl get svc</span><br><span class="line">kubectl get ingress</span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://web2.ctnrs.com/bar</span><br><span class="line">http://web2.ctnrs.com/foo</span><br></pre></td></tr></table></figure>
<h2 id="Ingress-：基于名称的虚拟主机">Ingress ：基于名称的虚拟主机</h2>
<p><img src="/images/F43B7E2488D24867918ACC44A42437CEclipboard.png" alt></p>
<p>vim web3-deploy-svc.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web3</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web-tomcat</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web-tomcat <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: java-demo</span><br><span class="line">        image: lizhenliang/java-demo</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web-tomcat</span><br><span class="line">  name: web3</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 88 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 8080 <span class="comment"># 容器端口</span></span><br><span class="line">   <span class="comment"># nodePort: 30009    #nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web-tomcat <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim ingress-web3.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: web3</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: web3-1.ctnrs.com        <span class="comment">#域名</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web1            <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 80          <span class="comment">#ClusterIP的端口</span></span><br><span class="line">  - host: web3-2.ctnrs.com        <span class="comment">#域名</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web3            <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 88          <span class="comment">#ClusterIP的端口</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web3-deploy-svc.yaml </span><br><span class="line">kubectl apply -f ingress-web3.yaml </span><br><span class="line">kubectl get ingress</span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">web3-1.ctnrs.com</span><br><span class="line">web3-2.ctnrs.com </span><br></pre></td></tr></table></figure>
<h2 id="Ingress：HTTPS">Ingress：HTTPS</h2>
<p>配置HTTPS步骤：</p>
<p>1、准备域名证书文件（来自：openssl/cfssl工具自签或者权威机构颁发）</p>
<p>vim <a href="http://cfssl.sh">cfssl.sh</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line"><span class="built_in">chmod</span> +x cfssl*</span><br><span class="line"><span class="built_in">mv</span> cfssl_linux-amd64 /usr/bin/cfssl</span><br><span class="line"><span class="built_in">mv</span> cfssljson_linux-amd64 /usr/bin/cfssljson</span><br><span class="line"><span class="built_in">mv</span> cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br></pre></td></tr></table></figure>
<p>vim <a href="http://certs.sh">certs.sh</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ca-config.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;signing&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;default&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;expiry&quot;: &quot;87600h&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;profiles&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;kubernetes&quot;: &#123;</span></span><br><span class="line"><span class="string">         &quot;expiry&quot;: &quot;87600h&quot;,</span></span><br><span class="line"><span class="string">         &quot;usages&quot;: [</span></span><br><span class="line"><span class="string">            &quot;signing&quot;,</span></span><br><span class="line"><span class="string">            &quot;key encipherment&quot;,</span></span><br><span class="line"><span class="string">            &quot;server auth&quot;,</span></span><br><span class="line"><span class="string">            &quot;client auth&quot;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; ca-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;CN&quot;: &quot;kubernetes&quot;,</span></span><br><span class="line"><span class="string">    &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">        &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;names&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">            &quot;L&quot;: &quot;Beijing&quot;,</span></span><br><span class="line"><span class="string">            &quot;ST&quot;: &quot;Beijing&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; web4.ctnrs.com-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;web4.ctnrs.com&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;BeiJing&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes web4.ctnrs.com-csr.json | cfssljson -bare web4.ctnrs.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash cfssl.sh</span><br><span class="line">bash certs.sh</span><br></pre></td></tr></table></figure>
<p>2、将证书文件保存到Secret</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret tls web4-ctnrs-com --cert=ssl/web4.ctnrs.com.pem --key=ssl/web4.ctnrs.com-key.pem</span><br><span class="line">kubectl get secrets </span><br></pre></td></tr></table></figure>
<p>3、Ingress规则配置tls</p>
<p>vim ingress-web4-https.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: web4</span><br><span class="line">spec:</span><br><span class="line">  tls:</span><br><span class="line">  - hosts:</span><br><span class="line">    - web4.ctnrs.com                 <span class="comment">#自签证书对应的域名</span></span><br><span class="line">    secretName: web4-ctnrs-com       <span class="comment">#Secret的名字</span></span><br><span class="line">  rules:</span><br><span class="line">  - host: web4.ctnrs.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web1</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ingress-web4-https.yaml </span><br><span class="line">kubectl get ingress</span><br></pre></td></tr></table></figure>
<p>配置本地hosts文件解析</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.1.12      web1.ctnrs.com  web4.ctnrs.com  </span><br><span class="line">192.168.1.13      web1.ctnrs.com  web4.ctnrs.com  </span><br></pre></td></tr></table></figure>
<p>访问</p>
<p><img src="/images/5BA66364BB194B94A5D1992F439DB35Aclipboard.png" alt></p>
<h2 id="Ingress：个性化配置">Ingress：个性化配置</h2>
<p>示例1：设置代理超时参数</p>
<p>vim ingress-annotations.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: annotations</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/ingress.class: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-connect-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-send-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-read-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: annotations.ctnrs.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web1</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ingress-annotations.yaml </span><br><span class="line">kubectl get ingress</span><br><span class="line">kubectl get pod -n ingress-nginx </span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx-ingress-controller-qj4vg bash -n ingress-nginx </span><br><span class="line"><span class="variable">$vi</span> /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>查看是否有代理的配置</p>
<p><img src="/images/7342077EDF3E4812AED83A5730609A01clipboard.png" alt></p>
<p>示例2：设置客户端上传文件大小</p>
<p>vim ingress-annotations.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: annotations</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/ingress.class: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-connect-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-send-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-read-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-body-size: <span class="string">&quot;10m&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: annotations.ctnrs.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web1</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ingress-annotations.yaml </span><br><span class="line">kubectl get pod -n ingress-nginx </span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx-ingress-controller-qj4vg bash -n ingress-nginx </span><br><span class="line"><span class="variable">$vi</span> /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>查看annotations.ctnrs.com域名下有没有相关的配置</p>
<p><img src="/images/2DF62D4954594D6DB5667A0BD8C86C6Eclipboard.png" alt></p>
<p>示例3：重定向</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/rewrite-target: https://www.baidu.com</span><br></pre></td></tr></table></figure>
<p>示例4：自定义规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/server-snippet: |</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* <span class="string">&#x27;(Android|iPhone)&#x27;</span>) &#123;</span><br><span class="line">    rewrite ^/(.*) http://m.baidu.com <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>vim web5-deploy-svc.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web5</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web5</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web5 <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web5-java-demo</span><br><span class="line">        image: lizhenliang/java-demo</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web5</span><br><span class="line">  name: web5</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 8888 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 8080 <span class="comment"># 容器端口</span></span><br><span class="line">   <span class="comment"># nodePort: 30009    #nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web5 <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim ingress-web5.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: web5</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/server-snippet: |</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* <span class="string">&#x27;(Android|iPhone)&#x27;</span>) &#123;</span><br><span class="line">        rewrite ^/(.*) http://m.baidu.com <span class="built_in">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: web5.ctnrs.com        <span class="comment">#域名</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web5        <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 8888          <span class="comment">#ClusterIP的端口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web5-deploy-svc.yaml </span><br><span class="line">kubectl apply -f ingress-web5.yaml </span><br><span class="line">kubectl get ingress</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>电脑端访问：<a href="http://web5.ctnrs.com/">http://web5.ctnrs.com/</a></p>
<p><img src="/images/04BC8BD141DD47EF9D3744B923B3C53Aclipboard.png" alt></p>
<p>使用电脑火狐浏览器模仿手机端访问跳转到百度页面</p>
<p><img src="/images/EC681CFC0F3C4BF7822277C1AFDB0999clipboard.png" alt></p>
<p>注：上面这些配置都是针对Nginx Server块生效</p>
<p>更多使用方法：<a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md">https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md</a></p>
<h2 id="Ingress-Controller-2">Ingress Controller</h2>
<p>Ingress Contronler怎么工作的？</p>
<p>Ingress Contronler通过与 Kubernetes API 交互，动态的去感知集群中 Ingress 规则变化，然后读取它， 按照自定义的规则，规则就是写明了哪个域名对应哪个service，生成一段 Nginx 配置，应用到管理的 Nginx服务，然后热加载生效。 以此来达到Nginx负载均衡器配置及动态更新的问题。</p>
<p>流程包流程：客户端 -&gt;Ingress Controller（nginx） -&gt; 分布在各节点Pod</p>
<h2 id="Ingress-Controller高可用方案">Ingress Controller高可用方案</h2>
<p>一般Ingress Controller会以DaemonSet+nodeSelector部署到几台特定 Node，然后将这几台挂载到公网负载均衡器对外提供服务。</p>
<p><img src="/images/9267ADA4F67F4FE9BDD1C7371BEA7534clipboard.png" alt></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA项目镜像构建：Tomcat</title>
    <url>/2022/05/23/java%E9%A1%B9%E7%9B%AE%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<p>JAVA项目镜像构建：Tomcat</p>
<p>tomcat目录文件：1.apache-tomcat-8.5.43.tar.gz  2.Dockerfile   3.Dockerfile2  4.ROOT.war</p>
<p>Dockerfile（环境镜像）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.ctnrs.com</span><br><span class="line"></span><br><span class="line">ENV VERSION=8.5.43</span><br><span class="line"></span><br><span class="line">RUN yum install java-1.8.0-openjdk wget curl unzip iproute net-tools -y &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span>.tar.gz /usr/local/</span><br><span class="line">RUN <span class="built_in">mv</span> /usr/local/apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span> /usr/local/tomcat &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">&#x27;1a JAVA_OPTS=&quot;-Djava.security.egd=file:/dev/./urandom&quot;&#x27;</span> /usr/local/tomcat/bin/catalina.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/tomcat/bin</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/local/tomcat</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [<span class="string">&quot;catalina.sh&quot;</span>, <span class="string">&quot;run&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Dockerfile2 (基于环境镜像打包的项目镜像）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM tomcat:v1</span><br><span class="line">RUN <span class="built_in">rm</span> -rf /usr/local/tomcat/webapps/*</span><br><span class="line">COPY ROOT.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure>
<p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> tomcat/</span><br><span class="line">docker build -t tomcat:v1 .</span><br><span class="line">docker build -t tomcat:v2 -f Dockerfile2 .</span><br><span class="line">docker run -d -p 8888:8080 --name tomcat tomcat:v2</span><br></pre></td></tr></table></figure>
<p>访问tomcat 8888端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://192.168.0.11:8888/</span><br></pre></td></tr></table></figure>
<p>JAVA微服务镜像构建：Jar</p>
<p>java目录文件:1.Dockerfile  2.hello.jar</p>
<p>Dockerfile(基于环境镜像打包的项目镜像）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM java:8-jdk-alpine</span><br><span class="line">LABEL maintainer www.ctnrs.com</span><br><span class="line">ENV JAVA_OPTS=<span class="string">&quot;<span class="variable">$JAVA_OPTS</span> -Dfile.encoding=UTF8 -Duser.timezone=GMT+08&quot;</span></span><br><span class="line">RUN sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories &amp;&amp; \</span><br><span class="line">    apk add -U tzdata &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">COPY hello.jar /</span><br><span class="line">EXPOSE 8888</span><br><span class="line">CMD [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -jar <span class="variable">$JAVA_OPTS</span> /hello.jar&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编写Dockerfile最佳实践</p>
<p>减少镜像层：一次RUN指令形成新的一层，尽量Shell命令都写在一行，减少镜像层。</p>
<p>优化镜像大小：一次RUN形成新的一层，如果没有在同一层删除，无论文件是否最后删除， 都会带到下一层，所以要在每一层清理对应的残留数据，减小镜像大小。</p>
<p>减少网络传输时间：例如软件包、mvn仓库等</p>
<p>多阶段构建：代码编译、部署在一个Dockerfile完成，只会保留部署阶段产生数据。</p>
<p>选择最小的基础镜像：例如alpine</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s安全控制</title>
    <url>/2022/07/14/k8s%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Kubernetes-安全框架">Kubernetes 安全框架</h2>
<p>K8S安全控制框架主要由下面3个阶段进行控制，每一个阶段都 支持插件方式，通过API Server配置来启用插件。</p>
<ol>
<li>
<p>Authentication（鉴权）</p>
</li>
<li>
<p>Authorization（授权）</p>
</li>
<li>
<p>Admission Control（准入控制）</p>
</li>
</ol>
<p>客户端要想访问K8s集群API Server，一般需要证书、Token或 者用户名+密码；如果Pod访问，需要ServiceAccount</p>
<p><img src="/images/BA1BA2242FE74CF5AF4D103D2CE779B6clipboard.png" alt></p>
<h2 id="鉴权（Authentication）">鉴权（Authentication）</h2>
<p>三种客户端身份认证：</p>
<ul>
<li>
<p>HTTPS 证书认证：基于CA证书签名的数字证书认证</p>
</li>
<li>
<p>HTTP Token认证：通过一个Token来识别用户</p>
</li>
<li>
<p>HTTP Base认证：用户名+密码的方式认证</p>
</li>
</ul>
<h2 id="授权（Authorization）">授权（Authorization）</h2>
<p>RBAC（Role-Based Access Control，基于角色的访问控制）：负责完成授权（Authorization）工作。</p>
<p>RBAC根据API请求属性，决定允许还是拒绝。</p>
<p>比较常见的授权维度：</p>
<ul>
<li>
<p>user：用户名</p>
</li>
<li>
<p>group：用户分组</p>
</li>
<li>
<p>资源，例如pod、deployment</p>
</li>
<li>
<p>资源操作方法：get，list，create，update，patch，watch，delete</p>
</li>
<li>
<p>命名空间</p>
</li>
<li>
<p>API组</p>
</li>
</ul>
<h2 id="准入控制（Admission-Control）">准入控制（Admission Control）</h2>
<p>Adminssion Control实际上是一个准入控制器插件列表，发送到API Server 的请求都需要经过这个列表中的每个准入控制器插件的检查，检查不通过， 则拒绝请求。</p>
<h2 id="基于角色的权限访问控制：RBAC">基于角色的权限访问控制：RBAC</h2>
<p>RBAC（Role-Based Access Control，基于角色的访问控 制），允许通过Kubernetes API动态配置策略。</p>
<p>角色</p>
<ul>
<li>
<p>Role：授权特定命名空间的访问权限</p>
</li>
<li>
<p>ClusterRole：授权所有命名空间的访问权限</p>
</li>
</ul>
<p>角色绑定</p>
<ul>
<li>
<p>RoleBinding：将角色绑定到主体（即subject）</p>
</li>
<li>
<p>ClusterRoleBinding：将集群角色绑定到主体</p>
</li>
</ul>
<p>主体（subject）</p>
<ul>
<li>
<p>User：用户</p>
</li>
<li>
<p>Group：用户组</p>
</li>
<li>
<p>ServiceAccount：服务账号</p>
</li>
</ul>
<p><img src="/images/00B32E081B29474B860179448537BA37clipboard.png" alt></p>
<h2 id="案例：为指定用户授权访问不同命名空间权限">案例：为指定用户授权访问不同命名空间权限</h2>
<p>示例：为azhe用户授权default命名空间Pod读取权限</p>
<ol>
<li>用K8S CA签发客户端证书</li>
</ol>
<p>安装cfssl工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim cfssl.sh</span></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line"><span class="built_in">chmod</span> +x cfssl*</span><br><span class="line"><span class="built_in">mv</span> cfssl_linux-amd64 /usr/bin/cfssl</span><br><span class="line"><span class="built_in">mv</span> cfssljson_linux-amd64 /usr/bin/cfssljson</span><br><span class="line"><span class="built_in">mv</span> cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br><span class="line"></span><br><span class="line"><span class="comment">#bash cfssl.sh</span></span><br></pre></td></tr></table></figure>
<p>生成证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim cert.sh </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; ca-config.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;signing&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;default&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;expiry&quot;: &quot;87600h&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;profiles&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;kubernetes&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;usages&quot;: [</span></span><br><span class="line"><span class="string">            &quot;signing&quot;,</span></span><br><span class="line"><span class="string">            &quot;key encipherment&quot;,</span></span><br><span class="line"><span class="string">            &quot;server auth&quot;,</span></span><br><span class="line"><span class="string">            &quot;client auth&quot;</span></span><br><span class="line"><span class="string">        ],</span></span><br><span class="line"><span class="string">        &quot;expiry&quot;: &quot;87600h&quot;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; azhe-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;azhe&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;O&quot;: &quot;k8s&quot;,</span></span><br><span class="line"><span class="string">      &quot;OU&quot;: &quot;System&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -ca=/etc/kubernetes/pki/ca.crt -ca-key=/etc/kubernetes/pki/ca.key -config=ca-config.json -profile=kubernetes azhe-csr.json | cfssljson -bare azhe</span><br><span class="line"></span><br><span class="line"><span class="comment">#bash cert.sh </span></span><br></pre></td></tr></table></figure>
<p>数字证书和key</p>
<p><img src="/images/0A9228A856504E6EB4AF08FF1961AEE3clipboard.png" alt></p>
<ol start="2">
<li>生成kubeconfig授权文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成kubeconfig授权文件：</span></span><br><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">--certificate-authority=/etc/kubernetes/pki/ca.crt \</span><br><span class="line">--embed-certs=<span class="literal">true</span> \</span><br><span class="line">--server=https://192.168.1.11:6443 \</span><br><span class="line">--kubeconfig=azhe.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置客户端认证</span></span><br><span class="line">kubectl config set-credentials azhe \</span><br><span class="line">--client-key=azhe-key.pem \</span><br><span class="line">--client-certificate=azhe.pem \</span><br><span class="line">--embed-certs=<span class="literal">true</span> \</span><br><span class="line">--kubeconfig=azhe.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认上下文</span></span><br><span class="line">kubectl config set-context kubernetes \</span><br><span class="line">--cluster=kubernetes \</span><br><span class="line">--user=azhe \</span><br><span class="line">--kubeconfig=azhe.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前使用配置</span></span><br><span class="line">kubectl config use-context kubernetes --kubeconfig=azhe.kubeconfig</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建RBAC权限策略</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim rbac.yaml</span></span><br><span class="line"></span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: default</span><br><span class="line">  name: pod-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  resources: [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: read-pods</span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: azhe</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f rbac.yaml </span><br><span class="line"><span class="comment">#指定kubeconfig文件测试：</span></span><br><span class="line">kubectl get pod --kubeconfig=./azhe.kubeconfig </span><br></pre></td></tr></table></figure>
<p>查看deployment和service（修改rbac文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim rbac.yaml </span></span><br><span class="line"></span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: default</span><br><span class="line">  name: pod-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [<span class="string">&quot;&quot;</span>,<span class="string">&quot;apps&quot;</span>]</span><br><span class="line">  resources: [<span class="string">&quot;pods&quot;</span>,<span class="string">&quot;deployments&quot;</span>,<span class="string">&quot;services&quot;</span>]  <span class="comment">#资源类型权限</span></span><br><span class="line">  verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: read-pods</span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: azhe</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f rbac.yaml </span><br><span class="line">kubectl get deployments.apps --kubeconfig=./azhe.kubeconfig </span><br><span class="line">kubectl get services --kubeconfig=./azhe.kubeconfig </span><br><span class="line">kubectl api-versions <span class="comment">#查看k8s资源组</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/861B72416FB74D8892A146DE804610C7clipboard.png" alt></p>
<p>当客户端使用kubectl时，它会向APIserver发送请求，它会根据你客户端的身份，比如数字认证方式，它会提取证书里面cn字段，cn字段作为你的用户名，会先验证你的身份是不是可信任的，或者证书是不是ca颁发的，验证没问题后会检查有没有给你授权，还有准入控制器插件列表检查，如果通过后你查看就会返回成功。</p>
<p>客户端要想访问k8s集群，需要拿着kubeconfig授权文件去访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拷贝kubeconfig授权文件到客户端</span></span><br><span class="line">scp azhe.kubeconfig root@192.168.0.13:~</span><br><span class="line"><span class="comment">#客户端指定授权文件访问</span></span><br><span class="line">kubectl get services --kubeconfig=azhe.kubeconfig </span><br><span class="line"><span class="comment">#如果不想指定授权文件访问，可以将授权文件移动到kube目录下，这时就不需要指定了</span></span><br><span class="line"><span class="built_in">mkdir</span> .kube/</span><br><span class="line"><span class="built_in">mv</span> azhe.kubeconfig  .kube/config</span><br></pre></td></tr></table></figure>
<p>ServiceAccount：服务账号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get sa -n kubernetes-dashboard</span><br><span class="line">kubectl describe sa -n kubernetes-dashboard </span><br><span class="line">kubectl get secrets -n kubernetes-dashboard </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ui——&gt;token（保存至secret中）——&gt;apiserver——&gt;rbac（ServiceAccount）</p>
<p>User和Group是针对用户授权访问APIserver的，ServiceAccount是针对程序访问APIserver的。</p>
<p>例如：ui程序在pod yaml配置文件里面指定ServiceAccount，在创建pod时引用ServiceAccount创建的token，token是保存在secret里面的，这样你的程序就带着token去访问apiserver，然后rbac是对ServiceAccount进行授权的。</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins备份与恢复</title>
    <url>/2021/05/23/jenkins%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p>备份两种方式:</p>
<p>• 备份数据目录（/opt/jenkins_home）—&gt;docker 部署</p>
<p>• Thinbackup插件</p>
<p>系统管理</p>
<p><img src="/images/C5C48942E3D9492A82F144934907E4DEclipboard.png" alt></p>
<p>设置：    #备份的目录 （/var/jenkins_home/backup）</p>
<p>#多长时间备份一次（两三天）</p>
<p>#备份插件</p>
<p><img src="/images/BF5D1D29EC724D94BBB773BBCE003B1Cclipboard.png" alt></p>
<p><img src="/images/6D024EDC1D8A4B6287EA26EB7F544175clipboard.png" alt></p>
<p>恢复：</p>
<p>模拟删除项目进行恢复，恢复完成在系统管理点击读取设置加载，相当于重启Jenkins服务。</p>
<p><img src="/images/0FBE4339FBD640E495277A1897112F9Dclipboard.png" alt></p>
<p><img src="/images/F97A9D0C8EEC4118B3D6B04EE97452AAclipboard.png" alt></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s集群网络上</title>
    <url>/2023/10/11/k8s%E9%9B%86%E7%BE%A4%E7%BD%91%E7%BB%9C%E4%B8%8A/</url>
    <content><![CDATA[<h2 id="服务器网络架构">服务器网络架构</h2>
<p><img src="/images/E636CCF6CF2B42F1A101A9C61AC4878Fclipboard.png" alt></p>
<ul>
<li>
<p>路由器：网络出口</p>
</li>
<li>
<p>核心层：主要完成数据高效转发、链路备份等</p>
</li>
<li>
<p>汇聚层：网络策略、安全、工作站交换机的接 入、VLAN之间通信等功能</p>
</li>
<li>
<p>接入层：工作站的接入</p>
</li>
</ul>
<h2 id="交换技术">交换技术</h2>
<p><img src="/images/50EFC14312B844A28E30D709A9AE9BE7clipboard.png" alt></p>
<p>交换机工作在OSI参考模型的第二层，即数据链路层。交换机拥有一条高带宽的背部总线 交换矩阵，在同一时间可进行多个端口对之间的数据传输。</p>
<p>交换技术分为2层和3层：</p>
<ul>
<li>
<p>2层：主要用于小型局域网，仅支持在数据链路层转发数据，对工作站接入。</p>
</li>
<li>
<p>3层：三层交换技术诞生，最初是为了解决广播域的问题，多年发展，三层交换机已经 成为构建中大型网络的主要力量</p>
</li>
</ul>
<p>广播域</p>
<p>交换机在转发数据时会先进行广播，这个广播可以发送的区域就是一个广播域。交换机之间对广播帧是透明的，所以 交换机之间组成的网络是一个广播域。路由器的一个接口下的网络是一个广播域，所以路由器可以隔离广播域。</p>
<p>ARP（地址解析协议）</p>
<p>发送这个广播帧是由ARP协议实现，ARP是通过IP地址获取物理地址的一个TCP/IP协议。</p>
<p>三层交换机</p>
<p>前面讲的二层交换机只工作在数据链路层，路由器则工作在网络层。而功能强大的三层交换机可同时工作在数据链路 层和网络层，并根据 MAC地址或IP地址转发数据包。</p>
<p>VLAN（Virtual Local Area Network）：虚拟局域网</p>
<p>VLAN是一种将局域网设备从逻辑上划分成一个个网段。一个VLAN就是一个广播域，VLAN之间的通信是通过第3层 的路由器来完成的。VLAN应用非常广泛，基本上大部分网络项目都会划分vlan。</p>
<p>VLAN的主要好处：</p>
<ul>
<li>
<p>分割广播域，减少广播风暴影响范围。</p>
</li>
<li>
<p>提高网络安全性，根据不同的部门、用途、应用划分不同网段。</p>
</li>
</ul>
<h2 id="路由技术">路由技术</h2>
<p>路由器主要分为两个端口类型：LAN口和WAN口</p>
<p>WAN口：配置公网IP，接入到互联网，转发来自LAN口的IP数据包。</p>
<p>LAN口：配置内网IP（网关），连接内部交换机。</p>
<p>路由器是连接两个或多个网络的硬件设备，将从端口上接收的数据包，根据数据包的 目的地址智能转发出去。</p>
<p>路由器的功能：</p>
<ul>
<li>
<p>路由</p>
</li>
<li>
<p>转发</p>
</li>
<li>
<p>隔离子网</p>
</li>
<li>
<p>隔离广播域</p>
</li>
</ul>
<p>路由器是互联网的枢纽，是连接互联网中各个局域网、广域网的设备，相比交换机来说，路由器的数据转发很复杂， 它会根据目的地址给出一条最优的路径。那么路径信息的来源有两种：</p>
<p>静态路由：指人工手动指定到目标主机的地址然后记录在路由表中，如果其中某个节点不可用则需要重新指定。</p>
<p>动态路由：则是路由器根据动态路由协议自动计算出路径永久可用，能实时地适应网络结构的变化。</p>
<p>常用的动态路由协议：</p>
<ul>
<li>
<p>RIP（ Routing Information Protocol ，路由信息协议）</p>
</li>
<li>
<p>OSPF（Open Shortest Path First，开放式最短路径优先）</p>
</li>
<li>
<p>BGP（Border Gateway Protocol，边界网关协议）</p>
</li>
</ul>
<h2 id="OSI七层模型">OSI七层模型</h2>
<p>OSI（Open System Interconnection）是国际标准化组织（ISO）制定的一个 用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。</p>
<p><img src="/images/ADF327DE95DB4C5084D0F3FCAFD2C253clipboard.png" alt></p>
<p><img src="/images/26D0547A8B474E39B4D5916D7FEF47F2clipboard.png" alt></p>
<p>TCP（Transmission Control Protocol，传输控制协议），面向连接协议，双方先建立可靠的连接， 再发送数据。适用于传输数据量大，可靠性要求高的应用场景。</p>
<p>UDP（User Data Protocol，用户数据报协议），面向非连接协议，不与对方建立连接，直接将数 据包发送给对方。适用于一次只传输少量的数据，可靠性要求低的应用场景。相对TCP传输速度快。</p>
<h2 id="K8s网络模型：-回看Docker容器网络模型">K8s网络模型： 回看Docker容器网络模型</h2>
<p><img src="/images/CA8CDD48CDFC49049408825D2227E9FEclipboard.png" alt></p>
<p>Docker网络模型涉及的名词：</p>
<ul>
<li>
<p>网络的命名空间：Linux在网络栈中引入网络命名空间，将独立的网络协议栈隔离到不同的命名空间中，彼此间无法通信； Docker利用这一特性，实现不同容器间的网络隔离。</p>
</li>
<li>
<p>Veth设备对：Veth设备对的引入是为了实现在不同网络命名空间的通信。</p>
</li>
<li>
<p>Iptables/Netfilter：Docker使用Netfilter实现容器网络转发。</p>
</li>
<li>
<p>网桥：网桥是一个二层网络设备，通过网桥可以将Linux支持的不同的端口连接起来，并实现类似交换机那样的多对多的通信。</p>
</li>
<li>
<p>路由：Linux系统包含一个完整的路由功能，当IP层在处理数据发送或转发的时候，会使用路由表来决定发往哪里。</p>
</li>
</ul>
<h2 id="K8s网络模型：Pod网络">K8s网络模型：Pod网络</h2>
<p><img src="/images/949A3B8EAAB5429BB82ACE90062F3E35clipboard.png" alt></p>
<p>Pod是K8s最小调度单元，一个Pod由一个容器或多个容器组成，当多个容器时，怎么都用这一个Pod IP？</p>
<p>实现：k8s会在每个Pod里先启动一个infra container小容器，然后让其他的容器连接进来这个网络命名空间，然后其 他容器看到的网络试图就完全一样了。即网络设备、IP地址、Mac地址等。在Pod的IP地址就是infra container的IP地 址。</p>
<p>在 Kubernetes 中，每一个 Pod 都有一个真实的 IP 地址，并且每一个 Pod 都可以使用此 IP 地址与 其他 Pod 通信。</p>
<p>Pod之间通信会有两种情况：</p>
<ul>
<li>
<p>两个Pod在同一个Node上</p>
</li>
<li>
<p>两个Pod在不同Node上</p>
</li>
</ul>
<p>第一种情况：两个Pod在同一个Node上</p>
<p>同节点Pod之间通信道理与Docker网络一样的，如下图：</p>
<p><img src="/images/C9E89486F7CA4EE9BE204C905BF5AA73clipboard.png" alt></p>
<p>1.对 Pod1 来说，eth0 通过虚拟以太网设备 （veth0）连接到 root namespace；</p>
<p>2.网桥 cbr0 中为 veth0 配置了一个网段。一旦 数据包到达网桥，网桥使用ARP 协议解析出其 正确的目标网段 veth1；</p>
<p>3.网桥 cbr0 将数据包发送到 veth1；</p>
<p>4.数据包到达 veth1 时，被直接转发到 Pod2 的 network namespace 中的 eth0 网络设备。</p>
<p>第二种情况：两个Pod在不同Node上</p>
<p><img src="/images/8F915E645EB54EEA98D52BE2042CFA1Eclipboard.png" alt></p>
<p>相比同节点Pod通信，这里源Pod发出的数据包需 要传递到目标节点，但是源Pod并不知道目标Pod 在哪个节点上？</p>
<p>因此，为了实现容器跨主机通信需求，就需要部署网络组件，这些网络组件都必 须满足如下要求：</p>
<ul>
<li>
<p>一个Pod一个IP</p>
</li>
<li>
<p>所有的 Pod 可以与任何其他 Pod 直接通信</p>
</li>
<li>
<p>所有节点可以与所有 Pod 直接通信</p>
</li>
<li>
<p>Pod 内部获取到的 IP 地址与其他 Pod 或节点与其通信时的 IP 地址是同一个</p>
</li>
</ul>
<p>目前支持的一些K8s网络组件：</p>
<p><img src="/images/762CAE4691BD42B5A10116EF472228D1clipboard.png" alt></p>
<p>网络组件说明：<a href="https://kubernetes.io/docs/concepts/cluster-administration/networking/">https://kubernetes.io/docs/concepts/cluster-administration/networking/</a></p>
<h2 id="K8s网络模型：-CNI（容器网络接口）">K8s网络模型： CNI（容器网络接口）</h2>
<p>CNI（Container Network Interface，容器网络接口)：是一个容器网络规范，Kubernetes网络采用的就是这个CNI规 范，负责初始化infra容器的网络设备。</p>
<p>CNI二进制程序默认路径：/opt/cni/bin/</p>
<p>项目地址：<a href="https://github.com/containernetworking/cni">https://github.com/containernetworking/cni</a></p>
<p>以Flannel网络组件为例，当部署Flanneld后，会在每台宿主机上生成它对应的CNI配置文件（它其实是一个 ConfigMap），从而告诉Kubernetes要使用 Flannel 作为容器网络方案。</p>
<p>CNI配置文件默认路径：/etc/cni/net.d</p>
<p>当 kubelet 组件需要创建 Pod 的时候，先调用dockershim它先创建一个 Infra 容器。然后调用 CNI 插件为 Infra 容器 配置网络。</p>
<p>这两个路径可在kubelet启动参数中定义：</p>
<p>–network-plugin=cni</p>
<p>–cni-conf-dir=/etc/cni/net.d</p>
<p>–cni-bin-dir=/opt/cni/bin</p>
<h2 id="K8s网络组件之Flannel">K8s网络组件之Flannel</h2>
<p>Flannel是CoreOS维护的一个网络组件，Flannel为每个Pod提供全局唯一的IP，Flannel使用ETCD来存储Pod子网与 Node IP之间的关系。flanneld守护进程在每台主机上运行，并负责维护ETCD信息和路由数据包。</p>
<p>项目地址：<a href="https://github.com/coreos/flannel">https://github.com/coreos/flannel</a></p>
<p>YAML地址：<a href="https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml">https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</a></p>
<h2 id="K8s网络组件之Flannel：部署">K8s网络组件之Flannel：部署</h2>
<p>部署前有两处可能需要调整：</p>
<p>kube-flannel.yml</p>
<p><img src="/images/F247FFA929434234902653C0DADDF996clipboard.png" alt></p>
<p>Network：指定Pod IP分配的网段，与controller-manager配置的保持一样。</p>
<ul>
<li>
<p>–allocate-node-cidrs=true</p>
</li>
<li>
<p>–cluster-cidr=10.244.0.0/16</p>
</li>
<li>
<p>kubeadm部署：/etc/kubernetes/manifests/kube-controller-manager.yaml</p>
</li>
<li>
<p>二进制部署：/opt/kubernetes/cfg/kube-controller-manager.conf</p>
</li>
</ul>
<p>Backend：指定工作模式</p>
<h2 id="K8s网络组件之Flannel：工作模式">K8s网络组件之Flannel：工作模式</h2>
<p>Flannel支持多种工作模式：</p>
<ul>
<li>
<p>UDP：最早支持的一种方式，由于性能最差，目前已经弃用。</p>
</li>
<li>
<p>VXLAN：Overlay Network方案，源数据包封装在另一种网络包里面进行路由转发和通信</p>
</li>
<li>
<p>Host-GW：Flannel通过在各个节点上的Agent进程，将容器网络的路由信息写到主机的路由表上，这样一来所有 的主机都有整个容器网络的路由数据了。</p>
</li>
<li>
<p>Directrouting：同时支持VXLAN和Host-GW工作模式</p>
</li>
<li>
<p>公有云VPC：ALIYUN，AWS</p>
</li>
</ul>
<h2 id="K8s网络组件之Flannel：VXLAN模式">K8s网络组件之Flannel：VXLAN模式</h2>
<p>VXLAN介绍</p>
<p>VXLAN，即 Virtual Extensible LAN（虚拟可扩展局域网），是 Linux 内核本身就支持的一种网络 虚似化技术。VXLAN 可以完全在内核态实现上述封装和解封装的工作，从而通过与前面相似的“隧 道”机制，构建出覆盖网络（Overlay Network）。</p>
<p>VXLAN的覆盖网络设计思想：在现有的三层网络之上，覆盖一个二层网络，使得连接在这个VXLAN 二层网络上的主机之间，可以像在同一局域网里通信。</p>
<p>为了能够在二层网络上打通“隧道” ，VXLAN 会在宿主机上设置一个特殊的网络设备作为“隧道” 的两端。这个设备就叫作 VTEP，即：VXLAN Tunnel End Point（虚拟隧道端点）。</p>
<p>VTEP设备进行封装和解封装的对象是二层数据帧，这个工作是在Linux内核中完成的。</p>
<p>Flannel工作逻辑图如下：</p>
<p><img src="/images/78BFAAAF1E504AA1ADAC3BA1D40ED482clipboard.png" alt></p>
<p>如果Pod 1访问Pod 2，源地址10.244.1.10，目的地址10.244.2.10 ，数据包传输流程如下：</p>
<p>1.容器路由：容器根据路由表，将数据包发送下一跳10.244.1.1，从eth0网卡出。可以使用ip route命令查看路由表</p>
<p><img src="/images/CDCC5B1CD9DF416B8992A7AA90D5410Bclipboard.png" alt></p>
<p>2.主机路由：数据包进入到宿主机虚拟网卡cni0，根据路由表转发到flannel.1虚拟网卡，也就是来到了隧道的入口。 10.244.2.0/24 via 10.244.2.0 dev flannel.1 onlink # 凡是发往10.244.2.0/24网段的数据包，都需要经过flannel.1设备发出，并且下一跳是10.244.2.0， 即Node2 VTEP设备flannel.1。</p>
<p><img src="/images/DF7FE5B950AA4556867A3EFE53782999clipboard.png" alt></p>
<p><img src="/images/943B2A691FFD4AA68C1ED405E264A507clipboard.png" alt></p>
<p>3.VXLAN封装：而这些VTEP设备之间组成一个二层网络，但是二层网络必须要知道目的MAC地址，那这个MAC地址从哪获取到呢？其实在flanneld进 程启动后，就会自动添加其他节点ARP记录，可以通过ip neigh show dev flannel.1命令查看。</p>
<p><img src="/images/589E4F3D29B9452F8BB2ABA112DF9C1Aclipboard.png" alt></p>
<p>4.二次封包：知道了目的MAC地址，Linux内核就可以进行二层封包了。但是，对于宿主机网络来说这个二层帧并不能在宿主机二层网络里传输。所以接 下来，Linux内核还要把这个数据帧进一步封装成为宿主机网络的一个普通数据帧，好让它载着内部数据帧，通过宿主机的ens33网卡进行传输。 数据格式如下图：</p>
<p><img src="/images/C067F3160882498A90BC1C6B50FEEE54clipboard.png" alt></p>
<p>5.封装到UDP包发出去：在封装成宿主机网络可传输的数据帧时，还缺少目标宿主机MAC地址，也就是说这个UDP包该发给哪台宿主机呢？ flanneld进程也维护着一个叫做FDB的转发数据库，可以通过bridge fdb show dev flannel.1命令查看。可以看到，上面用的对方flannel.1的MAC地址 对应宿主机IP，也就是UDP要发往的目的地。所以使用这个目的IP与MAC地址进行封装。</p>
<p><img src="/images/E1CC9578BB0D46389B0E1BA236732BA1clipboard.png" alt></p>
<p>6.数据包到达目的宿主机：接下来，就是宿主机与宿主机之间通信了，数据包从Node1的ens33网卡发出去，Node2接收到数据包，解封装发现是VXLAN 数据包，把它交给flannel.1设备。flannel.1设备则会进一步拆包，取出原始IP包（源容器IP和目标容器IP），通过cni0网桥二层转发给容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#抓包分析</span></span><br><span class="line">tcpdump -i flannel.1 -nn  <span class="comment">#-i 的作用是指定监听哪个网卡</span></span><br><span class="line">tcpdump udp  -i ens33 -nn   <span class="comment">#-nn 不进行端口名称的转换</span></span><br></pre></td></tr></table></figure>
<p>Tcpdump抓包指南之关键字的使用</p>
<p>1.类型关键字：  host，net，port</p>
<p>2.传输关键字：src，dst</p>
<p>3.协议关键字：tcp,udp,http,arp,ftp</p>
<p><img src="/images/D9885550172242E19DB576B68EE98223clipboard.png" alt></p>
<h2 id="K8s网络组件之Flannel：HOST-GW模式">K8s网络组件之Flannel：HOST-GW模式</h2>
<p>host-gw模式相比vxlan简单了许多，直接添加路由，将目的主机当做网关，直接路由原始封包。</p>
<p><img src="/images/7ED7AC6E90B8450DBD7D700ED9B7E23Bclipboard.png" alt></p>
<p>修改配置文件：</p>
<p>kube-flannel.yml</p>
<p><img src="/images/7A61D71570864075886347EE1BE20CABclipboard.png" alt></p>
<p>当你设置flannel使用host-gw模式，flanneld会在宿主机上创建节点的路由表：</p>
<p><img src="/images/F5367A99B1774053B1DC2D1B5E6635D4clipboard.png" alt></p>
<p>目的 IP 地址属于 10.244.2.0/24 网段的 IP 包，应该经过本机的 eth33 设备发出去（即：dev ens33）；并且，它下一跳地址是 192.168.0.13（即：via 192.168.0.13）。</p>
<p>一旦配置了下一跳地址，那么接下来，当 IP 包从网络层进入链路层封装成帧的时候，ens33 设备就会使用下一跳地址对应的 MAC 地址，作为该数据帧的目的 MAC 地址。</p>
<p><img src="/images/259307CC1DDA432BB2E44D87AC13D024clipboard.png" alt></p>
<p>而 Node 2 的内核网络栈从二层数据帧里拿到 IP 包后，会“看到”这个 IP 包的目的 IP 地址是 10.244.2.10，即 container-2 的 IP 地址。这时候，根据 Node 2 上的路由表，该目的地址会匹配到第五条路由规则（也就是 10.244.2.0 对应的路由规则），从而 进入 cni0 网桥，进而进入到 container-2 当中。</p>
<p><img src="/images/D0F71BED5D54494D81D9FA3BDEDB6702clipboard.png" alt></p>
<p>可见，数据包是封装成帧发送出去的，会使用路由表的下一跳来设置目的MAC地址，会经过二层网络到达目的节点，因此，hostgw模式必须要求集群宿主机之间二层连通。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#抓包分析</span></span><br><span class="line">tracepath 10.244.1.3</span><br><span class="line">tcpdump -i ens33 -nn dst 10.244.2.4</span><br></pre></td></tr></table></figure>
<p><img src="/images/11FFDE2820754EC0AC00FF78C33FF2DDclipboard.png" alt></p>
<h2 id="K8s网络组件之Flannel：小结">K8s网络组件之Flannel：小结</h2>
<p>VXLAN特点：</p>
<ul>
<li>
<p>先进行二层帧封装，再通过宿主机网络封装，解封装也一样，所以增加性能开销</p>
</li>
<li>
<p>对宿主机网络要求低，只要三层网络可达</p>
</li>
</ul>
<p>Host-GW特点：</p>
<ul>
<li>
<p>直接路由转发，性能损失很小</p>
</li>
<li>
<p>对宿主机网络要求二层可达</p>
</li>
</ul>
<p>卸载flnnel</p>
<p><a href="https://blog.csdn.net/weixin_34409741/article/details/92513036">https://blog.csdn.net/weixin_34409741/article/details/92513036</a></p>
<p>学习：<a href="https://edu.51cto.com/center/course/lesson/index?id=532871">https://edu.51cto.com/center/course/lesson/index?id=532871</a></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>kubectl命令行管理工具</title>
    <url>/2022/06/12/kubectl%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="kubeconfig配置文件">kubeconfig配置文件</h2>
<p>kube-apiserver两个端口：</p>
<ul>
<li>
<p>localhost:8080  非安全端口，是kubectl默认先连接8080，如果你配置kubeconfig（.kube/config）就直接走这个配置连接的安全端口</p>
</li>
<li>
<p>masterip:6443   安全端口</p>
</li>
</ul>
<p>命令行指定配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get node --kubeconfig=admin.conf</span><br></pre></td></tr></table></figure>
<p>拷贝认证文件到其他节点的（.kube/config）下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp .kube/config root@192.168.0.12:.kube/</span><br></pre></td></tr></table></figure>
<p>kubectl使用kubeconfig认证文件连接K8s集群， 使用kubectl config指令生成kubeconfig文件。</p>
<p><img src="/images/44B7D7962FFC4A6084E5B03245B92B45clipboard.png" alt></p>
<h2 id="kubectl管理命令概要">kubectl管理命令概要</h2>
<p><img src="/images/B5A0EFF109924D819F7F247722B89244clipboard.png" alt></p>
<p>官方文档参考地址：<a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/">https://kubernetes.io/zh/docs/reference/kubectl/overview/</a></p>
<p><img src="/images/FE0CA664ABC643C6AC7DF7A84860042Cclipboard.png" alt></p>
<h2 id="牛刀小试，快速部署一个网站">牛刀小试，快速部署一个网站</h2>
<p>使用Deployment控制器部署镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment web --image=lizhenliang/java-demo </span><br><span class="line">kubectl get deploy,pods</span><br></pre></td></tr></table></figure>
<p>使用Service将Pod暴露出去：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment web --port=80 --target-port=8080 --<span class="built_in">type</span>=NodePort </span><br><span class="line">kubectl get service</span><br></pre></td></tr></table></figure>
<p>访问应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://NodeIP:Port <span class="comment"># 端口随机生成，通过get svc获取</span></span><br></pre></td></tr></table></figure>
<h2 id="基本资源概念">基本资源概念</h2>
<ul>
<li>
<p>Pod：K8s最小部署单元，一组容器的集合</p>
</li>
<li>
<p>Deployment：最常见的控制器，用于更高级别部署和管理Pod</p>
</li>
<li>
<p>Service：为一组Pod提供负载均衡，对外提供统一访问入口</p>
</li>
<li>
<p>Label ：标签，附加到某个资源上，用于关联对象、查询和筛选</p>
</li>
<li>
<p>Namespaces ：命名空间，将对象逻辑上隔离，也利于权限控制</p>
</li>
</ul>
<h2 id="命名空间">命名空间</h2>
<p>命名空间（Namespace）：Kubernetes将资源对象逻辑上隔离，从而形成多个虚拟集群。</p>
<p>应用场景：</p>
<ul>
<li>
<p>根据不同团队划分命名空间</p>
</li>
<li>
<p>根据项目划分命名空间</p>
</li>
</ul>
<p>kubectl get namespace</p>
<ul>
<li>
<p>default：默认命名空间</p>
</li>
<li>
<p>kube-system：K8s系统方面的命名空间</p>
</li>
<li>
<p>kube-public：公开的命名空间，谁都可以访问，</p>
</li>
<li>
<p>kube-node-lease：K8s内部命名空间</p>
</li>
</ul>
<p>两种方法指定资源命名空间：</p>
<ul>
<li>
<p>命令行加 -n</p>
</li>
<li>
<p>yaml资源元数据里指定namespace字段</p>
</li>
</ul>
<p>1、使用kubeadm搭建一个K8s集群</p>
<p>2、新建命名空间，在该命名空间中创建一个pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create namespace azhe</span><br></pre></td></tr></table></figure>
<p>3、创建一个deployment并暴露Service，可以在浏览器访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment java-demo --image=lizhenliang/java-demo -n azhe </span><br><span class="line">kubectl expose deployment java-demo --port 80 --target-port=8080 --<span class="built_in">type</span>=NodePort  -n azhe </span><br></pre></td></tr></table></figure>
<p>4、列出命名空间下指定标签pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n azhe --show-labels</span><br><span class="line">kubectl get pod -l app=java-demo -n azhe </span><br><span class="line">kubectl get pod,svc,deploy -o wide -n azhe  <span class="comment">#查看azhe命名空间下的pod，svc,deploy资源</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/4D8950519EAC4C08B9D400C984FD4308clipboard.png" alt></p>
<p>注：自由发挥，实现需求即可</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s应用包管理器Helm初探</title>
    <url>/2022/07/15/k8s%E5%BA%94%E7%94%A8%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8helm%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="为什么需要Helm">为什么需要Helm</h2>
<p><img src="/images/18AA965627B942638BC076553CD7789Cclipboard.png" alt></p>
<p>由于Kubernetes缺少对发布的应用版本管理和控制，使得部署的应 用维护和更新等面临诸多的挑战，主要面临以下问题：</p>
<ul>
<li>
<p>如何将这些服务作为一个整体管理？</p>
</li>
<li>
<p>这些资源文件如何高效复用？</p>
</li>
<li>
<p>不支持应用级别的版本管理</p>
</li>
</ul>
<h2 id="Helm介绍">Helm介绍</h2>
<p>Helm是一个Kubernetes的包管理工具，就像Linux下的包管理器，如yum/apt等，可以很方便的将之前 打包好的yaml文件部署到kubernetes上。</p>
<p>Helm有3个重要概念：</p>
<ul>
<li>
<p>helm：一个命令行客户端工具，主要用于Kubernetes应用chart的创建、打包、发布和管理。</p>
</li>
<li>
<p>Chart：应用描述，一系列用于描述 k8s 资源相关文件的集合。</p>
</li>
<li>
<p>Release：基于Chart的部署实体，一个 chart 被 Helm 运行后将会生成对应的一个 release；将在 k8s中创建出真实运行的资源对象。</p>
</li>
</ul>
<p>Helm目前有两个大版本：v2和v3</p>
<p>2019年11月Helm团队发布v3版本，相比v2版本最 大变化是将Tiller删除，并将大部分代码重构。</p>
<p><img src="/images/3821E58785BB4DCAAB4341A7EB2A7B98clipboard.png" alt></p>
<h2 id="Helm客户端">Helm客户端</h2>
<p>使用helm很简单，你只需要下载一个二进制客户端包即可，会通过kubeconfig配置（通常 $HOME/.kube/config）来连接Kubernetes。</p>
<p>下载Helm客户端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://get.helm.sh/helm-v3.2.4-linux-amd64.tar.gz</span><br><span class="line">tar zxvf helm-v3.2.4-linux-amd64.tar.gz </span><br><span class="line"><span class="built_in">mv</span> linux-amd64/helm /usr/bin/</span><br></pre></td></tr></table></figure>
<p><img src="/images/370E0ADEBC8049AA957517226C3D7E38clipboard.png" alt></p>
<h2 id="Helm基本使用">Helm基本使用</h2>
<p>Helm管理应用生命周期：</p>
<ul>
<li>
<p>helm create 制作Chart</p>
</li>
<li>
<p>helm install 部署</p>
</li>
<li>
<p>helm upgrade 更新</p>
</li>
<li>
<p>helm rollback 回滚</p>
</li>
<li>
<p>helm uninstall 卸载</p>
</li>
</ul>
<h2 id="Helm基本使用：制作Chart">Helm基本使用：制作Chart</h2>
<p>创建chart：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm create mychart </span><br></pre></td></tr></table></figure>
<p>打包chart：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm package mychart</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Chart.yaml：用于描述这个 Chart的基本信息，包括名字、描述信息以及 版本等。</p>
</li>
<li>
<p>values.yaml ：用于存储 templates 目录中模板文件中用到变量的值。</p>
</li>
<li>
<p>Templates： 目录里面存放所有yaml模板文件。</p>
</li>
<li>
<p>charts：目录里存放这个chart依赖的所有子chart。</p>
</li>
<li>
<p>NOTES.txt ：用于介绍Chart帮助信息， helm install 部署后展示给用户。 例如：如何使用这个 Chart、列出缺省的设置等。</p>
</li>
<li>
<p>_helpers.tpl：放置模板的地方，可以在整个 chart 中重复使用。</p>
</li>
</ul>
<h2 id="Helm基本使用：部署">Helm基本使用：部署</h2>
<p>Helm核心是模板，即模板化K8s YAML文件。</p>
<p>部署多个应用时，将需要改动的字段进行模板 化，可动态传入。</p>
<p><img src="/images/C2E4292AE5C64932B9400425D070613Eclipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> mychart/templates/</span><br><span class="line"><span class="comment">#部署deployment</span></span><br><span class="line">vim deployment.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicas &#125;&#125; <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web1</span><br><span class="line">        image: &#123;&#123; .Values.image &#125;&#125;:&#123;&#123; .Values.imageTag &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署service</span></span><br><span class="line">vim service.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-service</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">    nodePort: 30009    <span class="comment">#nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> mychart/</span><br><span class="line"><span class="comment">#渲染变量</span></span><br><span class="line">vim values.yaml</span><br><span class="line">replicas: 3</span><br><span class="line">image: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">imageTag: <span class="string">&quot;1.17&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#部署Chart：</span></span><br><span class="line">helm install web mychart/</span><br><span class="line"><span class="comment">#查看Release：</span></span><br><span class="line">helm list -n default</span><br><span class="line"><span class="comment">#查看部署的Pod：</span></span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure>
<p><img src="/images/8AEE0351668B4BA986921D2584E58C14clipboard.png" alt></p>
<h2 id="Helm基本使用：升级">Helm基本使用：升级</h2>
<p>为了实现Chart复用，可动态传参修改values.yaml中的 变量值，有两种方式：</p>
<ul>
<li>
<p>–values，-f</p>
</li>
<li>
<p>–set</p>
</li>
</ul>
<p>例如将升级应用版本和副本数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm upgrade --<span class="built_in">set</span> imageTag=1.18,replicas=1 web mychart/</span><br><span class="line">helm list </span><br><span class="line">helm <span class="built_in">history</span> web   <span class="comment">#查看历史版本</span></span><br><span class="line">kubectl get pod -o wdie</span><br><span class="line">curl -I 10.244.36.67  <span class="comment">#访问验证是否升级到指定版本  </span></span><br></pre></td></tr></table></figure>
<p><img src="/images/FA77FD2C2FBB45C58F9290D439233EF1clipboard.png" alt></p>
<h2 id="Helm基本使用：回滚、卸载">Helm基本使用：回滚、卸载</h2>
<p>回滚到上一个版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm rollback web</span><br></pre></td></tr></table></figure>
<p>查看历史版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm <span class="built_in">history</span> web</span><br></pre></td></tr></table></figure>
<p>回滚到指定版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm rollback web 1</span><br></pre></td></tr></table></figure>
<p>卸载应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm uninstall web</span><br></pre></td></tr></table></figure>
<h2 id="Helm基本使用：工作流程">Helm基本使用：工作流程</h2>
<p><img src="/images/B139AB7AC42745A4A3F2E5687D96D0B6clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web mychart/ --dry-run   <span class="comment">#尝试运行但不执行，调式</span></span><br><span class="line">helm install web mychart/</span><br><span class="line">helm get manifest web   <span class="comment">#显示web的清单</span></span><br></pre></td></tr></table></figure>
<h2 id="公共Chart仓库">公共Chart仓库</h2>
<p>国内Chart仓库，可直接使用它们制作好的包：</p>
<ul>
<li>
<p>微软仓库（<a href="http://mirror.azure.cn/kubernetes/charts/%EF%BC%89">http://mirror.azure.cn/kubernetes/charts/）</a></p>
</li>
<li>
<p>阿里云仓库（<a href="https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts">https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</a> ）</p>
</li>
<li>
<p>官方仓库（<a href="https://hub.kubeapps.com/charts/incubator%EF%BC%89">https://hub.kubeapps.com/charts/incubator）</a></p>
</li>
</ul>
<p>添加仓库方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add azure http://mirror.azure.cn/kubernetes/charts/</span><br><span class="line">helm repo add aliyun https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts </span><br><span class="line">helm repo update                       <span class="comment">#更新</span></span><br><span class="line">helm repo list                         <span class="comment">#列出当前的仓库</span></span><br><span class="line">helm search repo mysql                 <span class="comment">#搜索MySQL的chart包</span></span><br><span class="line">helm install mysql aliyun/mysql        <span class="comment">#安装</span></span><br><span class="line">helm pull aliyun/mysql --untar         <span class="comment">#从远程仓库中下载chart并解压到本地</span></span><br><span class="line">helm package mychart/                  <span class="comment">#打包自己的chart</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes应用包管理器helm上</title>
    <url>/2023/09/17/kubernetes%E5%BA%94%E7%94%A8%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8helm%E4%B8%8A/</url>
    <content><![CDATA[<h2 id="为什么需要Helm">为什么需要Helm</h2>
<p><img src="/images/A12312C206C948C188E0EBF96B6C6030clipboard.png" alt></p>
<p>由于Kubernetes缺少对发布的应用版本管理和控制，使得部署的应 用维护和更新等面临诸多的挑战，主要面临以下问题：</p>
<ul>
<li>
<p>如何将这些服务作为一个整体管理？</p>
</li>
<li>
<p>这些资源文件如何高效复用？</p>
</li>
<li>
<p>不支持应用级别的版本管理</p>
</li>
</ul>
<h2 id="Helm介绍">Helm介绍</h2>
<p>Helm是一个Kubernetes的包管理工具，就像Linux下的包管理器，如yum/apt等，可以很方便的将之前 打包好的yaml文件部署到kubernetes上。</p>
<p>Helm有3个重要概念：</p>
<ul>
<li>
<p>helm：一个命令行客户端工具，主要用于Kubernetes应用chart的创建、打包、发布和管理。</p>
</li>
<li>
<p>Chart：应用描述，一系列用于描述 k8s 资源相关文件的集合。</p>
</li>
<li>
<p>Release：基于Chart的部署实体，一个 chart 被 Helm 运行后将会生成对应的一个 release；将在 k8s中创建出真实运行的资源对象。</p>
</li>
</ul>
<p>Helm目前有两个大版本：v2和v3</p>
<p>2019年11月Helm团队发布v3版本，相比v2版本最 大变化是将Tiller删除，并大部分代码重构。</p>
<p><img src="/images/9D82D97288634F279D7D6F76D850B518clipboard.png" alt></p>
<h2 id="Helm客户端">Helm客户端</h2>
<p>使用helm很简单，你只需要下载一个二进制客户端包即可，会通过kubeconfig配置（通常 $HOME/.kube/config）来连接Kubernetes。</p>
<p>项目地址：<a href="https://github.com/helm/helm">https://github.com/helm/helm</a></p>
<p>下载Helm客户端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://get.helm.sh/helm-v3.4.2-linux-amd64.tar.gz</span><br><span class="line">tar zxvf helm-v3.4.2-linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">mv</span> linux-amd64/helm /usr/bin/</span><br></pre></td></tr></table></figure>
<p><img src="/images/DA830ABCA12E4BCFAEBA76D1D92979A5clipboard.png" alt></p>
<h2 id="Helm基本使用">Helm基本使用</h2>
<p>Helm管理应用生命周期：</p>
<ul>
<li>
<p>helm create 创建Chart示例</p>
</li>
<li>
<p>helm install 部署</p>
</li>
<li>
<p>helm upgrade 更新</p>
</li>
<li>
<p>helm rollback 回滚</p>
</li>
<li>
<p>helm uninstall 卸载</p>
</li>
</ul>
<h2 id="Helm基本使用：创建Chart示例">Helm基本使用：创建Chart示例</h2>
<p>创建chart：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm create mychart <span class="comment"># 默认示例中部署的是一个nginx服务 </span></span><br></pre></td></tr></table></figure>
<p>打包chart：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm package mychart</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>charts：目录里存放这个chart依赖的所有子chart。</p>
</li>
<li>
<p>Chart.yaml：用于描述这个 Chart的基本信息，包括名字、描述信息以及版本等。</p>
</li>
<li>
<p>values.yaml ：用于存储 templates 目录中模板文件中用到变量的值。</p>
</li>
<li>
<p>Templates： 目录里面存放所有yaml模板文件。</p>
</li>
<li>
<p>NOTES.txt ：用于介绍Chart帮助信息， helm install 部署后展示给用户。例如： 如何使用这个 Chart、列出缺省的设置等。</p>
</li>
<li>
<p>_helpers.tpl：放置模板的地方，可以在整个 chart 中重复使用。</p>
</li>
</ul>
<h2 id="Helm基本使用：部署">Helm基本使用：部署</h2>
<p>部署Chart：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web mychart </span><br></pre></td></tr></table></figure>
<p>查看Release：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm list -n default </span><br></pre></td></tr></table></figure>
<p>查看部署的Pod：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods,svc</span><br></pre></td></tr></table></figure>
<h2 id="Helm基本使用：升级">Helm基本使用：升级</h2>
<p>使用Chart升级应用有两种方法：</p>
<ul>
<li>
<p>–values，-f：指定YAML文件覆盖值</p>
</li>
<li>
<p>–set：在命令行上指定覆盖值</p>
</li>
</ul>
<p>注：如果一起使用，–set优先级高</p>
<p><img src="/images/7C87C5C001B2466EA359EB0666718F9Aclipboard.png" alt></p>
<p>例如将nginx服务升级到1.17版本：</p>
<p>第一种方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi values.yaml #任意路径</span></span><br><span class="line">image:</span><br><span class="line">    tag: <span class="string">&quot;1.17&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#helm upgrade -f values.yaml web mychart    </span></span><br></pre></td></tr></table></figure>
<p>第二种方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm upgrade --<span class="built_in">set</span> image.tag=1.17 web mychart</span><br></pre></td></tr></table></figure>
<h2 id="Helm基本使用：回滚、卸载">Helm基本使用：回滚、卸载</h2>
<p>回滚到上一个版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm rollback web </span><br></pre></td></tr></table></figure>
<p>查看历史版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm <span class="built_in">history</span> web</span><br></pre></td></tr></table></figure>
<p>回滚到指定版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm rollback web 1</span><br></pre></td></tr></table></figure>
<p><img src="/images/C735AA6FB9AB4C53A3E4666CF79B1ECFclipboard.png" alt></p>
<p>基于一个chart部署多个release版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web2 mychart/</span><br><span class="line">helm install --<span class="built_in">set</span> image.tag=1.17 web3 mychart/</span><br><span class="line">helm list </span><br></pre></td></tr></table></figure>
<p><img src="/images/E56FA451D8884EA281058266613607DBclipboard.png" alt></p>
<p>获取helm渲染后yaml文件模板</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm get all web     <span class="comment">#获取web这个chart所有的yaml模板</span></span><br><span class="line">helm get all web --revision 3     <span class="comment">#获取web这个chart指定版本yaml模板</span></span><br></pre></td></tr></table></figure>
<p>卸载应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm uninstall web</span><br></pre></td></tr></table></figure>
<h2 id="Helm基本使用：工作流程">Helm基本使用：工作流程</h2>
<p><img src="/images/8210A797B51E40F2B0809840241B4CB7clipboard.png" alt></p>
<h2 id="Chart模板">Chart模板</h2>
<p>Helm核心是模板，即模板化K8s YAML文件。</p>
<p>通过模板实现Chart高效复用，当部署多个应用时，可以将差异化的字段进行模板化，在部署时使用-f或 者–set动态覆盖默认值，从而适配多个应用。</p>
<p><img src="/images/4461E8B0CAC54A90ADC9323F528C0EFEclipboard.png" alt></p>
<h2 id="Chart模板：内置对象">Chart模板：内置对象</h2>
<p>在上面示例中，模板文件中.Release、.Values是Helm内置对象，顶级开头写。</p>
<p>Release对象：获取发布记录信息</p>
<p><img src="/images/4E796CF368E2410E8B885D71D2425651clipboard.png" alt></p>
<p>Values对象：为Chart模板提供值，这个对象的值有3个来源：</p>
<ul>
<li>
<p>chart包中的values.yaml文件</p>
</li>
<li>
<p>helm install或者helm upgrade的-f或者–values参数传入的自定义yaml文件</p>
</li>
<li>
<p>–set参数传入值</p>
</li>
</ul>
<p>Chart对象：可以通过Chart对象访问Chart.yaml文件的内容</p>
<h2 id="Chart模板：调试">Chart模板：调试</h2>
<p>使用helm install提供了–dry-run和–debug调试参数，帮助你验证模板正确性，并把渲染后的模板打印出来，而 不会真正的去部署。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install --dry-run web mychart    <span class="comment">#不创建查看模板渲染清单</span></span><br><span class="line">helm get manifest web mychart         <span class="comment">#创建后查看模板渲染清单</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">描述你的操作提示，方便后期查看</span><br><span class="line">helm install web mychart --description <span class="string">&quot;install nginx1.19&quot;</span> -n <span class="built_in">test</span></span><br><span class="line">helm <span class="built_in">history</span> web -n <span class="built_in">test</span>  <span class="comment">#查看描述的信息</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s集群网络下</title>
    <url>/2023/10/21/k8s%E9%9B%86%E7%BE%A4%E7%BD%91%E7%BB%9C%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="K8s网络组件之Calico">K8s网络组件之Calico</h2>
<p>Calico是一个纯三层的数据中心网络方案，Calico支持广泛的平台，包括Kubernetes、OpenStack等。 Calico 在每一个计算节点利用 Linux Kernel 实现了一个高效的虚拟路由器（ vRouter） 来负责数据转发， 而每个 vRouter 通过 BGP 协议负责把自己上运行的 workload 的路由信息向整个 Calico 网络内传播。 此外，Calico 项目还实现了 Kubernetes 网络策略，提供ACL功能。</p>
<p>实际上，Calico项目提供的网络解决方案，与Flannel的host-gw模式几乎一样。也就是说，Calico也是基于 路由表实现容器数据包转发，但不同于Flannel使用flanneld进程来维护路由信息的做法，而Calico项目使用 BGP协议来自动维护整个集群的路由信息。</p>
<p>BGP英文全称是Border Gateway Protocol，即边界网关协议，它是一种自治系统间的动态路由发现协议， 与其他 BGP 系统交换网络可达信息。</p>
<h2 id="K8s网络组件之Calico：BGP介绍">K8s网络组件之Calico：BGP介绍</h2>
<p><img src="/images/B827CF15481445E89E1D1034D29041CDclipboard.png" alt></p>
<p>在这个图中，有两个自治系统（autonomous system，简称为AS）：AS 1 和 AS 2。</p>
<p>在互联网中，一个自治系统(AS)是一个有权自主地决定在本系统中应采用何种路由协议的小型单位。这 个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它 是一个单独的可管理的网络单元（例如一所大学，一个企业或者一个公司个体）。一个自治系统有时也 被称为是一个路由选择域（routing domain）。一个自治系统将会分配一个全局的唯一的16位号码， 有时我们把这个号码叫做自治系统号（ASN）。</p>
<p>在正常情况下，自治系统之间不会有任何来往。如果两个自治系统里的主机，要通过 IP 地址直接进行通 信，我们就必须使用路由器把这两个自治系统连接起来。BGP协议就是让他们互联的一种方式。</p>
<p><img src="/images/7C6041A0731C48E8871D77AE1A19C384clipboard.png" alt></p>
<p>在了解了 BGP 之后，Calico 项目的架构就非常容易理解了，</p>
<p>Calico主要由三个部分组成：</p>
<ul>
<li>
<p>Felix：以DaemonSet方式部署，运行在每一个Node节点上， 主要负责维护宿主机上路由规则以及ACL规则。</p>
</li>
<li>
<p>BGP Client（BIRD）：主要负责把 Felix 写入 Kernel 的路 由信息分发到集群 Calico 网络。</p>
</li>
<li>
<p>Etcd：分布式键值存储，保存Calico的策略和网络配置状态。</p>
</li>
<li>
<p>calicoctl：命令行管理Calico。</p>
</li>
</ul>
<h2 id="K8s网络组件之Calico：部署">K8s网络组件之Calico：部署</h2>
<p>Calico存储有两种方式：</p>
<ul>
<li>数据存储在etcd</li>
</ul>
<p><a href="https://docs.projectcalico.org/v3.9/manifests/calico-etcd.yaml">https://docs.projectcalico.org/v3.9/manifests/calico-etcd.yaml</a></p>
<ul>
<li>数据存储在Kubernetes API Datastore服务中</li>
</ul>
<p><a href="https://docs.projectcalico.org/manifests/calico.yaml">https://docs.projectcalico.org/manifests/calico.yaml</a></p>
<p>数据存储在etcd中还需要修改yaml：</p>
<ul>
<li>配置连接etcd地址，如果使用https，还需要配置证书。（ConfigMap和Secret位置）</li>
</ul>
<p><img src="/images/58A4C504154C42139DB62DBB35DC626Aclipboard.png" alt></p>
<p><img src="/images/4C6D98958A53495A8A2C599B4FCEE2A7clipboard.png" alt></p>
<p>根据实际网络规划修改Pod CIDR（CALICOIPV4POOLCIDR）（两种方式都需要修改）</p>
<p>部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl apply -f calico.yaml</span></span><br><span class="line"><span class="comment"># kubectl get pods -n kube-system</span></span><br></pre></td></tr></table></figure>
<h2 id="K8s网络组件之Calico：管理工具">K8s网络组件之Calico：管理工具</h2>
<p>calicoctl工具用于管理calico，可通过命令行读取、创建、更新和删除 Calico 的存储对象。</p>
<p>项目地址：<a href="https://github.com/projectcalico/calicoctl">https://github.com/projectcalico/calicoctl</a></p>
<p>calicoctl 在使用过程中，需要从配置文件中读取 Calico 对象存储地址等信息。默认配置文件路 径 /etc/calico/calicoctl.cfg</p>
<p>方式1（基于ectd存储）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用calicoctl命令</span></span><br><span class="line"><span class="built_in">chmod</span> +x calicoctl </span><br><span class="line"><span class="built_in">mv</span> calicoctl /usr/bin/</span><br><span class="line"><span class="comment">#配置calicoctl配置文件</span></span><br><span class="line"><span class="built_in">mkdir</span> /etc/calico</span><br><span class="line"><span class="comment">#vi /etc/calico/calicoctl.cfg</span></span><br><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">kind: CalicoAPIConfig</span><br><span class="line">metadata:</span><br><span class="line">spec:</span><br><span class="line">  datastoreType: <span class="string">&quot;etcdv3&quot;</span></span><br><span class="line">  etcdEndpoints:</span><br><span class="line">  <span class="string">&quot;https://192.168.0.11:2379,https://192.168.0.12:2379,https://192.168.0.13:2379&quot;</span></span><br><span class="line">  etcdKeyFile: <span class="string">&quot;/opt/etcd/ssl/server-key.pem&quot;</span></span><br><span class="line">  etcdCertFile: <span class="string">&quot;/opt/etcd/ssl/server.pem&quot;</span></span><br><span class="line">  etcdCACertFile: <span class="string">&quot;/opt/etcd/ssl/ca.pem&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方式2（基于kubernetes API Datastore存储）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置calicoctl配置文件</span></span><br><span class="line"><span class="built_in">mkdir</span> /etc/calico</span><br><span class="line"><span class="comment">#vi /etc/calico/calicoctl.cfg</span></span><br><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">kind: CalicoAPIConfig</span><br><span class="line">metadata:</span><br><span class="line">spec:</span><br><span class="line">  datastoreType: <span class="string">&quot;kubernetes&quot;</span>     <span class="comment">#数据存储类型</span></span><br><span class="line">  kubeconfig: <span class="string">&quot;/root/.kube/config&quot;</span>   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看Calico状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">calicoctl node status</span><br><span class="line">calicoctl get node</span><br><span class="line">calicoctl get ippool -o wide</span><br></pre></td></tr></table></figure>
<p><img src="/images/E8B277C4EF1843DA8D20EAFF4D60A844clipboard.png" alt></p>
<h2 id="K8s网络组件之Calico：工作模式">K8s网络组件之Calico：工作模式</h2>
<p>Calico工作模式：</p>
<ul>
<li>
<p>IPIP：Overlay Network方案，源数据包封装在宿主机网络包里进行转发和通信。（默认）</p>
</li>
<li>
<p>BGP：基于路由转发，每个节点通过BGP协议同步路由表，写到宿主机。 （值设置Never）</p>
</li>
<li>
<p>CrossSubnet：同时支持BGP和IPIP，即根据子网选择转发方式。</p>
</li>
</ul>
<p>通过调整参数改变工作模式：</p>
<ul>
<li>
<p>name: CALICO_IPV4POOL_IPIP</p>
<p>value: “Always”</p>
</li>
</ul>
<h2 id="K8s网络组件之Calico：IPIP工作模式">K8s网络组件之Calico：IPIP工作模式</h2>
<p>IPIP模式：采用Linux IPIP隧道技术实现的数据包封装与转发。</p>
<p>IP 隧道（IP tunneling）是将一个IP报文封装在另一个IP报文的技术，Linux系统内核实现的</p>
<p>IP隧道技术主要有三种：IPIP、GRE、SIT。</p>
<p><img src="/images/5A9BDD04F43240559B4915A1115A732Dclipboard.png" alt></p>
<p>Pod 1 访问 Pod 2 大致流程如下：</p>
<ol>
<li>
<p>数据包（原始数据包）从容器出去到达宿主机，宿主机根据路由表发送到tunl0设备（IP隧道设备）</p>
</li>
<li>
<p>Linux内核IPIP驱动将原始数据包封装在宿主机网络的IP包中（新的IP包目的地之是原IP包的下一跳地 址，即192.168.31.63）。</p>
</li>
<li>
<p>数据包根据宿主机网络到达Node2；</p>
</li>
<li>
<p>Node2收到数据包后，使用IPIP驱动进行解包，从中拿到原始数据包；</p>
</li>
<li>
<p>然后根据路由规则，根据路由规则将数据包转发给cali设备，从而到达容器2。</p>
</li>
</ol>
<h2 id="K8s网络组件之Calico：BGP工作模式">K8s网络组件之Calico：BGP工作模式</h2>
<p>BGP模式：基于路由转发，每个节点通过BGP协议同步路由 表，将每个宿主机当做路由器，实现数据包转发。</p>
<p>calicoctl工具修改为BGP模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">calicoctl get ippool -o yaml &gt;ippool.yaml</span><br><span class="line">vi ippool.yaml </span><br></pre></td></tr></table></figure>
<p><img src="/images/BE93E537DA2644D08C62BA6ADE103640clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">calicoctl apply -f ippool.yaml </span><br><span class="line">calicoctl get ippool -o wide</span><br></pre></td></tr></table></figure>
<p><img src="/images/6713FFDDE2824151A31B4C4AB3D27349clipboard.png" alt></p>
<p><img src="/images/713BC2D00F444CF1B0A30B74B6D6ADF0clipboard.png" alt></p>
<p>Pod 1 访问 Pod 2 大致流程如下：</p>
<ol>
<li>
<p>数据包从容器出去到达宿主机；</p>
</li>
<li>
<p>宿主机根据路由规则，将数据包转发给下一跳（网关）；</p>
</li>
<li>
<p>到达Node2，根据路由规则将数据包转发给cali设备，从而到达容器2。</p>
</li>
</ol>
<h2 id="K8s网络组件之Calico：Route-Reflector-模式（RR）">K8s网络组件之Calico：Route Reflector 模式（RR）</h2>
<p>Calico 维护的网络在默认是（Node-to-Node Mesh）全互联模式，Calico集群中的节点之间都会相互建立连接，用于路由 交换。但是随着集群规模的扩大，mesh模式将形成一个巨大服务网格，连接数成倍增加，就会产生性能问题。</p>
<p>这时就需要使用 Route Reflector（路由器反射）模式解决这个问题。</p>
<p><img src="/images/9944A097E9DA43589BB46BAA9FDE8705clipboard.png" alt></p>
<p><img src="/images/ADAFF9FA70284DD0B24FD4106D012B12clipboard.png" alt></p>
<p>确定一个或多个Calico节点充当路由反射器，集中分发路由，让其 他节点从这个RR节点获取路由信息。</p>
<p>具体步骤如下：</p>
<p>1、关闭 node-to-node模式</p>
<p>添加 default BGP配置，调整 nodeToNodeMeshEnabled和asNumber：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ASN号可以通过获取</span></span><br><span class="line">calicoctl get nodes --output=wide</span><br><span class="line"></span><br><span class="line"><span class="comment">#vi bgpconfig.yaml</span></span><br><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">kind: BGPConfiguration</span><br><span class="line">metadata:</span><br><span class="line">  name: default</span><br><span class="line">spec:</span><br><span class="line">  logSeverityScreen: Info</span><br><span class="line">  nodeToNodeMeshEnabled: <span class="literal">false</span></span><br><span class="line">  asNumber: 64512</span><br><span class="line"></span><br><span class="line"><span class="comment">#应用配置</span></span><br><span class="line">calicoctl apply -f bgpconfig.yaml </span><br><span class="line">calicoctl get bgpconfig</span><br></pre></td></tr></table></figure>
<p>2、配置指定节点充当路由反射器</p>
<p>为方便让BGPPeer轻松选择节点，通过标签选择器匹配。 给路由器反射器节点打标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#kubectl label node k8s-node2 route-reflector=true</span></span><br></pre></td></tr></table></figure>
<p>然后配置路由器反射器节点routeReflectorClusterID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#calicoctl get node k8s-node2 -o yaml &gt; rr-node.yaml</span></span><br><span class="line"><span class="comment">#vi rr-node.yaml </span></span><br><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    projectcalico.org/kube-labels: <span class="string">&#x27;&#123;&quot;beta.kubernetes.io/arch&quot;:&quot;amd64&quot;,&quot;beta.kubernetes.io/os&quot;:&quot;linux&quot;,&quot;kubernetes.io/arch&quot;:&quot;amd64&quot;,&quot;kubernetes.io/hostname&quot;:&quot;k8s-node2&quot;,&quot;kubernetes.io/os&quot;:&quot;linux&quot;,&quot;route-reflector&quot;:&quot;true&quot;&#125;&#x27;</span></span><br><span class="line">  creationTimestamp: 2021-03-08T03:28:34Z</span><br><span class="line">  labels:</span><br><span class="line">    beta.kubernetes.io/arch: amd64</span><br><span class="line">    beta.kubernetes.io/os: linux</span><br><span class="line">    kubernetes.io/arch: amd64</span><br><span class="line">    kubernetes.io/hostname: k8s-node2</span><br><span class="line">    kubernetes.io/os: linux</span><br><span class="line">    route-reflector: <span class="string">&quot;true&quot;</span></span><br><span class="line">  name: k8s-node2</span><br><span class="line">  resourceVersion: <span class="string">&quot;53597&quot;</span></span><br><span class="line">  uid: ffc15f57-d624-4003-a3bc-77cb78232f6a</span><br><span class="line">spec:</span><br><span class="line">  bgp:</span><br><span class="line">    ipv4Address: 192.168.1.13/24</span><br><span class="line">    routeReflectorClusterID: 244.0.0.1 <span class="comment"># 添加集群ID 要唯一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#calicoctl apply -f rr-node.yaml </span></span><br></pre></td></tr></table></figure>
<p>3、使用标签选择器将路由反射器节点与其他非路由反射器节点配置为对等</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi bgppeer.yaml</span></span><br><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">kind: BGPPeer</span><br><span class="line">metadata:</span><br><span class="line">  name: peer-with-route-reflectors</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector: all()</span><br><span class="line">  peerSelector: route-reflector == <span class="string">&#x27;true&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#calicoctl apply -f bgppeer.yaml </span></span><br><span class="line"><span class="comment">#calicoctl node status   查看节点的BGP连接状态：</span></span><br><span class="line"><span class="comment">#calicoctl get bgppeer</span></span><br><span class="line"><span class="comment">#ss -anpt |grep EST |grep 179</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/B22931364F2B416D996CA61EBCEA7013clipboard.png" alt></p>
<p>配置多个节点充当路由反射器</p>
<p>1.给路由器反射器节点打标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label node k8s-node1 route-reflector=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>然后配置路由器反射器节点routeReflectorClusterID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">calicoctl get node k8s-node1 -o yaml &gt; rr-node.yaml</span><br><span class="line"><span class="comment">#vi rr-node.yaml</span></span><br><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    projectcalico.org/kube-labels: <span class="string">&#x27;&#123;&quot;beta.kubernetes.io/arch&quot;:&quot;amd64&quot;,&quot;beta.kubernetes.io/os&quot;:&quot;linux&quot;,&quot;kubernetes.io/arch&quot;:&quot;amd64&quot;,&quot;kubernetes.io/hostname&quot;:&quot;k8s-node1&quot;,&quot;kubernetes.io/os&quot;:&quot;linux&quot;,&quot;route-reflector&quot;:&quot;true&quot;&#125;&#x27;</span></span><br><span class="line">  creationTimestamp: 2021-03-08T03:28:33Z</span><br><span class="line">  labels:</span><br><span class="line">    beta.kubernetes.io/arch: amd64</span><br><span class="line">    beta.kubernetes.io/os: linux</span><br><span class="line">    kubernetes.io/arch: amd64</span><br><span class="line">    kubernetes.io/hostname: k8s-node1</span><br><span class="line">    kubernetes.io/os: linux</span><br><span class="line">    route-reflector: <span class="string">&quot;true&quot;</span></span><br><span class="line">  name: k8s-node1</span><br><span class="line">  resourceVersion: <span class="string">&quot;60365&quot;</span></span><br><span class="line">  uid: 47632c58-5dac-44d0-941d-abf772048cc4</span><br><span class="line">spec:</span><br><span class="line">  bgp:</span><br><span class="line">    ipv4Address: 192.168.1.12/24</span><br><span class="line">    routeReflectorClusterID: 244.0.0.2  <span class="comment"># 添加集群ID，要唯一</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># calicoctl apply -f rr-node.yam</span></span><br></pre></td></tr></table></figure>
<p>2.重新应用bgppeer.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">calicoctl delete -f bgppeer.yaml </span><br><span class="line">calicoctl apply -f bgppeer.yaml</span><br><span class="line">calicoctl node status</span><br></pre></td></tr></table></figure>
<p><img src="/images/0885EF19E4D24FE5998D0FCD2F90A0A0clipboard.png" alt></p>
<p><img src="/images/C220687577084968908D41C5CD8E9F3Fclipboard.png" alt></p>
<h2 id="小结">小结</h2>
<p><img src="/images/676EE94556D9494C85C7765856BE3E7Bclipboard.png" alt></p>
<p>网络性能：首选路由方案  flannel组件的hostGW和calico的BGP</p>
<p>集群规划：100+建议calico</p>
<p>网络限制：不能跑BGP</p>
<p>是否需要网络策略？</p>
<p>VXLAN和IPIP模式：</p>
<p>优势：只要你的集群节点之间互相能通信就行，不管你宿主机走的是二层还是三层。</p>
<p>缺点：先进行二层帧封装，再通过宿主机网络封装，解封装也一样，所以增加性能开销</p>
<p>HostGW和BGP模式：</p>
<p>优势：由于走的是宿主机网络路由，性能开销小</p>
<p>缺点：对宿主机网络要求二层可达，想要实现宿主机之前跨网段通信，需要同步宿主机路由信息到上层路由器。flannel需要手动同步，calico使用BGP动态路由发现协议自动同步，只要上层路由支持BGP协议。</p>
<h2 id="办公网络与K8s网络互通方案">办公网络与K8s网络互通方案</h2>
<p>网络需求：</p>
<ul>
<li>
<p>办公网络与Pod网络不通。在微服务架构下，开发人员希望在办公电脑能 直接连接K8s中注册中心调试；</p>
</li>
<li>
<p>办公网络与Service网络不通。在测试环境运行的mysql、redis等需要通过 nodeport暴露，维护成本大；</p>
</li>
<li>
<p>现有虚拟机业务访问K8s上的业务。</p>
</li>
</ul>
<p>解决方案：打通办公网络与K8s网络</p>
<p><img src="/images/0E59C28B367A4A76921B50CA20B67F59clipboard.png" alt></p>
<p>方案一：在办公室网络上层路由器添加一条静态路由条目，目标网段是容器网络（10.244.0.0）下一跳地址设置为某个node节点IP，从路由器的一个接口出，到达node节点上后，配置iptables规则源网段是办公室网段IP（192.168.0.0）转发到pod网段IP（10.244.0.0），还有源网段是办公室网段IP转发到service网段IP（10.96.0.0/12）。</p>
<p>方案二：服务器的上层核心交换机和k8s集群的上层路由反射器通过BGP协议相互学习对方的路由，从而实现路由的互通。</p>
<h2 id="网络策略概述">网络策略概述</h2>
<p>网络策略（Network Policy），用于限制Pod出入流量，提供Pod级别和Namespace级别网络访问控制。 一些应用场景：</p>
<ul>
<li>
<p>应用程序间的访问控制。例如微服务A允许访问微服务B，微服务C不能访问微服务A</p>
</li>
<li>
<p>开发环境命名空间不能访问测试环境命名空间Pod</p>
</li>
<li>
<p>当Pod暴露到外部时，需要做Pod白名单</p>
</li>
<li>
<p>多租户网络环境隔离</p>
</li>
</ul>
<p>Pod网络入口方向隔离：</p>
<ul>
<li>
<p>基于Pod级网络隔离：只允许特定对象访问Pod（使用标签定义），允许白名单上的IP地址或者IP段访问Pod</p>
</li>
<li>
<p>基于Namespace级网络隔离：多个命名空间，A和B命名空间Pod完全隔离。</p>
</li>
</ul>
<p>Pod网络出口方向隔离：</p>
<ul>
<li>
<p>拒绝某个Namespace上所有Pod访问外部</p>
</li>
<li>
<p>基于目的IP的网络隔离：只允许Pod访问白名单上的IP地址或者IP段</p>
</li>
<li>
<p>基于目标端口的网络隔离：只允许Pod访问白名单上的端口</p>
</li>
</ul>
<p><img src="/images/D45782348B0D40C39F526C0B7297606Fclipboard.png" alt></p>
<p>podSelector：目标Pod，根据标签选择</p>
<p>policyTypes：策略类型，指定策略用于入站、出站流量。</p>
<p>Ingress：from是可以访问的白名单，可以来自于IP段、命名空间、 Pod标签等，ports是可以访问的端口。</p>
<p>Egress：这个Pod组可以访问外部的IP段和端口。</p>
<h2 id="案例：对项目Pod出入流量访问控制">案例：对项目Pod出入流量访问控制</h2>
<p>需求1：将default命名空间携带app=web标签的Pod隔离，只允 许default命名空间携带run=client1标签的Pod访问80端口。</p>
<p>准备测试环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment web --image=nginx</span><br><span class="line">kubectl run client1 --image=busybox -- <span class="built_in">sleep</span> 36000</span><br><span class="line">kubectl run client2 --image=busybox -- <span class="built_in">sleep</span> 36000</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi np.yaml</span></span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: test-network-policy</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br><span class="line">  ingress:</span><br><span class="line">  - from:</span><br><span class="line">    - podSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          run: client1</span><br><span class="line">    ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line"></span><br><span class="line"><span class="comment">#kubectl apply -f np.yaml </span></span><br></pre></td></tr></table></figure>
<p>验证结果：client1pod可以下载web的首页，client2pod不可以下载web的首页</p>
<p>需求2：default命名空间下所有pod可以互相访问，也可以访问其 他命名空间Pod，但其他命名空间不能访问default命名空间Pod。</p>
<ul>
<li>
<p>podSelector: {}：如果未配置，默认所有Pod</p>
</li>
<li>
<p>from.podSelector: {} : 如果未配置，默认不允许</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run client3 --image=busybox -n azhe -- <span class="built_in">sleep</span> 36000</span><br><span class="line"><span class="comment">#vi np2.yaml </span></span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: deny-from-other-namespaces</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br><span class="line">  ingress:</span><br><span class="line">  - from:</span><br><span class="line">    - podSelector: &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#kubectl apply -f np2.yaml</span></span><br></pre></td></tr></table></figure>
<p>验证结果：azhe命名空间下的client3pod不可以访问default命名空间下的pod，但default命名空间下的pod可以访问azhe命名空间下的pod。</p>
<h2 id="网络策略实现流程">网络策略实现流程</h2>
<p><img src="/images/D06CDA70F2FC4AF984902BCCA9DC0D48clipboard.png" alt></p>
<p>当我们创建一个网络策略，也就是apply 一个yaml文件，它会提交到apiserver，policy controller控制器（calico-kube-controllers）里面的进程会实时监听apiserver上的网络策略，拿到之后会通知它的agent（也就是运行在每个节点上calico pod（calico-node）来取我拿到的网络策略，然后在本地运行，calico-node利用iptables创建相应的网络规则。</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Kibana 部署</title>
    <url>/2021/07/09/kibana%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>Kibana 部署</p>
<p>Kibana 是一个图形页面系统，用于对 Elasticsearch 数据可视化。</p>
<p>二进制方式部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf kibana-7.9.3-linux-x86_64.tar.gz </span><br><span class="line"><span class="built_in">mv</span> kibana-7.9.3-linux-x86_64 /opt/elk/kibana</span><br></pre></td></tr></table></figure>
<p>修改配置文件</p>
<p>vim /opt/elk/kibana/config/kibana.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server.port: 5601        </span><br><span class="line">server.host: <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">elasticsearch.hosts: [<span class="string">&quot;http://192.168.0.11:9200&quot;</span>]</span><br><span class="line">i18n.locale: <span class="string">&quot;zh-CN&quot;</span></span><br></pre></td></tr></table></figure>
<p>配置系统服务管理：</p>
<p>vim /usr/lib/systemd/system/kibana.service</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=kibana</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/opt/elk/kibana/bin/kibana --allow-root</span><br><span class="line">ExecReload=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kibana</span><br><span class="line">systemctl <span class="built_in">enable</span> kibana</span><br></pre></td></tr></table></figure>
<p>索引模式</p>
<p>索引模式：将ES索引关联到Kibana，然后就可以再Discover菜单查看</p>
<p><img src="/images/065F9E2FD8744FCEAA2199E597346DD9clipboard.png" alt></p>
<p>数据搜索</p>
<p><img src="/images/1108C89919064899828B48BF8A6F55C8clipboard.png" alt></p>
<p>基本查询：</p>
<p>• 查询URL（精确查询使用双引号）</p>
<p>request:“/index.html”</p>
<p>• 查询状态码200</p>
<p>response: 200</p>
<p>• 在消息字段中含有error</p>
<p>message: error</p>
<p>逻辑组合查询：</p>
<p>• 查询状态码200或者301</p>
<p>response: 200 or response: 301</p>
<p>• 查询状态码200并且URL是&quot;/index.html“</p>
<p>response: 200 and request: &quot;/index.html“</p>
<p>复合查询：</p>
<p>• 查询状态码200并且URL是/index.html或者/login.html</p>
<p>response:200 and (request: “/index.html” or request: “/login.html”)</p>
<p>• 查询状态码200或者301</p>
<p>response:(200 or 301)</p>
<p>结果取反查询：</p>
<p>• 匹配状态码不是200：</p>
<p>not response: 200</p>
<p>范围查询：支持&gt;，&gt;=，&lt;，和&lt;=</p>
<p>• 查询持续时间大于1</p>
<p>duration: &lt;=1</p>
<p>通配符：</p>
<p>• 查询以win开头</p>
<p>machine.os: win</p>
<p>Kibana可视化和仪表盘</p>
<p>Kibana可视化（Visualize）：基于ES查询，通过一系列聚合来提取 和处理数据，将结果进行图表展示。 另外，在创建图表需选择一个索引模式。</p>
<p>比较常用图表：</p>
<p>• 指标</p>
<p>• 折线图</p>
<p>• 饼图</p>
<p>• 数据表</p>
<p><img src="/images/DB9344F4CBA7455CB07426099F473DFFclipboard.png" alt></p>
<p>Kibana 可视化和仪表盘</p>
<p>Kibana仪表盘：显示可视化和搜索的集合，统一展示。 可以随意排列，调整大小和编辑仪表盘内容等，非常灵活。</p>
<p>• 指标</p>
<p><img src="/images/125D410930AE44EEAFC37FD9F810DC64clipboard.png" alt></p>
<p>• 折线图</p>
<p><img src="/images/9044181C3C264B2B878F66FBD3AC3AD7clipboard.png" alt></p>
<p>• 饼图</p>
<p><img src="/images/69CB388D24F14B118BBED57A3CEFD636clipboard.png" alt></p>
<p>• 数据表</p>
<p><img src="/images/345A3C11118741288622248AA4CB4BD1clipboard.png" alt></p>
<p><img src="/images/99596528ADD543B88558C4ADC85E7EBFclipboard.png" alt></p>
<p>制作成仪表盘</p>
<p><img src="/images/8938338ABCF04BFFB3D6DB01284C8875clipboard.png" alt></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes应用包管理器helm下</title>
    <url>/2023/09/25/kubernetes%E5%BA%94%E7%94%A8%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8helm%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="Chart模板：函数与管道">Chart模板：函数与管道</h2>
<p>常用函数：</p>
<ul>
<li>
<p>quote：将值转换为字符串，即加双引号</p>
</li>
<li>
<p>default：设置默认值，如果获取的值为空则为默认值</p>
</li>
<li>
<p>indent和nindent：缩进字符串</p>
</li>
<li>
<p>toYaml：引用一块YAML内容</p>
</li>
<li>
<p>其他函数：upper、title等</p>
<pre><code>        upper:  将值修改为大写

        title:  将值首字母修改为大写
</code></pre>
</li>
</ul>
<p>quote：将值转换为字符串，即加双引号</p>
<p>示例：nodeSelector标签的值用了true正常使用会报错，这是因为它是关键字，需要加引号才可以。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/values.yaml </span></span><br><span class="line">replicaCount: 1</span><br><span class="line">image:</span><br><span class="line">  repository: nginx</span><br><span class="line">  tag: <span class="string">&quot;latest&quot;</span></span><br><span class="line">selectorLabels: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">nodeSelector:</span><br><span class="line">  gpu: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/deploy.yaml </span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web2</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicaCount &#125;&#125;</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        gpu: &#123;&#123; quote .Values.nodeSelector.gpu &#125;&#125;</span><br><span class="line">      containers:</span><br><span class="line">      - image: &#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag &#125;&#125;</span><br><span class="line">        name: nginx</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web2</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>验证部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web2 --dry-run mychart/</span><br><span class="line">helm install web2 mychart/</span><br></pre></td></tr></table></figure>
<p><img src="/images/28FFC6E76CF74B7998177B37E38B8CC3clipboard.png" alt></p>
<p><img src="/images/E526BCB26C124AAA827A01F7FC7F8B15clipboard.png" alt></p>
<p>default：设置默认值，如果获取的值为空则为默认值</p>
<p>示例：以防止忘记定义而导致模板文件缺少字段无法创建资源，这时可以为字段定义一个默认值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/values.yaml </span></span><br><span class="line">replicaCount: 1</span><br><span class="line">image:</span><br><span class="line">  repository: nginx</span><br><span class="line">  tag: <span class="string">&quot;latest&quot;</span></span><br><span class="line">selectorLabels: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">nodeSelector:</span><br><span class="line">  gpu: <span class="literal">true</span></span><br><span class="line">labels:</span><br><span class="line">  app: <span class="string">&quot;&quot;</span>   </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/deploy.yaml </span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: &#123;&#123; .Values.labels.app | default <span class="string">&quot;web2&quot;</span> &#125;&#125;</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicaCount &#125;&#125;</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        gpu: &#123;&#123; quote .Values.nodeSelector.gpu &#125;&#125;</span><br><span class="line">      containers:</span><br><span class="line">      - image: &#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag &#125;&#125;</span><br><span class="line">        name: nginx</span><br></pre></td></tr></table></figure>
<p>验证部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web3 --dry-run mychart/</span><br><span class="line">helm install web3  mychart/</span><br></pre></td></tr></table></figure>
<p>这里用到了管道符“|”，前面的值传递后函数验证是否为空。</p>
<p><img src="/images/F8B6883F8C284B8C8F143E4F7A6A925Cclipboard.png" alt></p>
<p><img src="/images/85B6BA3875574C0586DE3DD18222F147clipboard.png" alt></p>
<p>indent和nindent函数都是缩进字符串，主要区别在于nindent会在缩进前多添加一个换行符。</p>
<p>示例：</p>
<p><img src="/images/720B9DE3ADAD410FAADA60EAB790C6C8clipboard.png" alt></p>
<p><img src="/images/329F3745C6FB4031AEDFE1B8C66B888Bclipboard.png" alt></p>
<p>toYaml：引用一块YAML内容</p>
<p>示例：在values.yaml里写结构化数据，引用内容块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/values.yaml </span></span><br><span class="line">replicaCount: 1</span><br><span class="line">image:</span><br><span class="line">  repository: nginx</span><br><span class="line">  tag: <span class="string">&quot;latest&quot;</span></span><br><span class="line">selectorLabels: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">nodeSelector:</span><br><span class="line">  gpu: <span class="literal">true</span></span><br><span class="line">labels:</span><br><span class="line">  app: <span class="string">&quot;&quot;</span></span><br><span class="line">resources:</span><br><span class="line">  limits:</span><br><span class="line">    cpu: 100m</span><br><span class="line">    memory: 128Mi</span><br><span class="line">  requests:</span><br><span class="line">    cpu: 100m</span><br><span class="line">    memory: 128Mi</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/deploy.yaml </span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: &#123;&#123; .Values.labels.app | default <span class="string">&quot;web2&quot;</span> &#125;&#125;</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicaCount &#125;&#125;</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        gpu: &#123;&#123; quote .Values.nodeSelector.gpu &#125;&#125;</span><br><span class="line">      containers:</span><br><span class="line">      - image: &#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag &#125;&#125;</span><br><span class="line">        name: nginx</span><br><span class="line">        resources:</span><br><span class="line">          &#123;&#123; toYaml .Values.resources | nindent 10 &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm  install web4 --dry-run /root/mychart/</span><br></pre></td></tr></table></figure>
<p><img src="/images/024B2666B3EF4516B6F40DF20E9B263Eclipboard.png" alt></p>
<p><img src="/images/A1F53D9FA80847F69B3AA20BD5217807clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web4 --<span class="built_in">set</span> resources.limits.cpu=<span class="string">&quot;200m&quot;</span> --dry-run /root/mychart/</span><br></pre></td></tr></table></figure>
<p><img src="/images/8A84C888BEED4239B65702E7ECA2BE33clipboard.png" alt></p>
<h2 id="Chart模板：流程控制">Chart模板：流程控制</h2>
<p>Helm模板语言提供以下流程控制语句：</p>
<ul>
<li>
<p>if/else：条件判断</p>
</li>
<li>
<p>range：循环</p>
</li>
<li>
<p>with：指定变量作用域</p>
</li>
</ul>
<h2 id="Chart模板：流程控制之if-else">Chart模板：流程控制之if/else</h2>
<p><img src="/images/BC30FBD40ABE48568CB60D65681CFFCDclipboard.png" alt></p>
<p>条件判断：根据不同的条件做不同的行为</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;&#123; <span class="keyword">if</span> &lt;表达式&gt; &#125;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 做某事 </span></span><br><span class="line"></span><br><span class="line">&#123;&#123; <span class="keyword">else</span> <span class="keyword">if</span> &lt;表达式&gt; &#125;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 做某事 </span></span><br><span class="line"></span><br><span class="line">&#123;&#123; <span class="keyword">else</span> &#125;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认 </span></span><br><span class="line"></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>示例：部署一个应用，在没明确启用ingress时，默认情况下不启用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># values.yaml</span></span><br><span class="line">ingress:</span><br><span class="line">  enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/ingress.yaml </span></span><br><span class="line">&#123;&#123; <span class="keyword">if</span> .Values.ingress.enabled &#125;&#125;</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: minimal-ingress</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /testpath</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: <span class="built_in">test</span></span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web1 --<span class="built_in">set</span> ingress.enabled=<span class="literal">true</span> --dry-run /root/mychart/</span><br></pre></td></tr></table></figure>
<p><img src="/images/432F32C7016A472E8515A5A99A7467FAclipboard.png" alt></p>
<p><img src="/images/8673BFB65C27405BAA5F82E4C77E932Bclipboard.png" alt></p>
<p>如果值为以下几种情况则为false：</p>
<ul>
<li>
<p>一个布尔类型 false</p>
</li>
<li>
<p>一个数字 0</p>
</li>
<li>
<p>一个空的字符串</p>
</li>
<li>
<p>一个 nil（空或 null）</p>
</li>
<li>
<p>一个空的集合（ map、 slice、 tuple、 dict、 array）</p>
</li>
</ul>
<p>条件表达式也支持操作符：</p>
<ul>
<li>
<p>eq 等于</p>
</li>
<li>
<p>ne 不等于</p>
</li>
<li>
<p>lt 小于</p>
</li>
<li>
<p>gt 大于</p>
</li>
<li>
<p>and 逻辑与</p>
</li>
<li>
<p>or 逻辑或</p>
</li>
</ul>
<p>示例：如果是一个空的集合则不启用资源配额</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/values.yaml </span></span><br><span class="line">replicaCount: 1</span><br><span class="line">image:</span><br><span class="line">  repository: nginx</span><br><span class="line">  tag: <span class="string">&quot;latest&quot;</span></span><br><span class="line">selectorLabels: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">nodeSelector:</span><br><span class="line">  gpu: <span class="literal">true</span></span><br><span class="line">labels:</span><br><span class="line">  app: <span class="string">&quot;&quot;</span></span><br><span class="line">resources: &#123;&#125;</span><br><span class="line"><span class="comment">#  limits:</span></span><br><span class="line"><span class="comment">#    cpu: 100m</span></span><br><span class="line"><span class="comment">#    memory: 128Mi</span></span><br><span class="line"><span class="comment">#  requests:</span></span><br><span class="line"><span class="comment">#    cpu: 100m</span></span><br><span class="line"><span class="comment">#    memory: 128Mi</span></span><br><span class="line">ingress:</span><br><span class="line">  enabled: <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/deploy.yaml </span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: &#123;&#123; .Values.labels.app | default <span class="string">&quot;web2&quot;</span> &#125;&#125;</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicaCount &#125;&#125;</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        gpu: &#123;&#123; quote .Values.nodeSelector.gpu &#125;&#125;</span><br><span class="line">      containers:</span><br><span class="line">      - image: &#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag &#125;&#125;</span><br><span class="line">        name: nginx</span><br><span class="line">        &#123;&#123;- <span class="keyword">if</span> .Values.resources &#125;&#125;</span><br><span class="line">        resources:</span><br><span class="line">          &#123;&#123;- toYaml .Values.resources | nindent 10 &#125;&#125;</span><br><span class="line">        &#123;&#123;- end &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证渲染结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm  install <span class="built_in">test</span> --dry-run mychart/</span><br></pre></td></tr></table></figure>
<p><img src="/images/8DA9181865E14D00A8FAE00FD7DEA8BCclipboard.png" alt></p>
<p><img src="/images/C88EA42C67E944AEA3FCC873006AD32Aclipboard.png" alt></p>
<p>渲染结果会发现有多余的空行，这是因为模板渲染时会将 指令删除，所以原有的位置就空白了。可以使用横杠“-” 消除空</p>
<h2 id="Chart模板：流程控制之range">Chart模板：流程控制之range</h2>
<p><img src="/images/C09FB32391AF46C9B68D6F7E1D2B1B5Dclipboard.png" alt></p>
<p>循环：一般用于遍历序列结构的数据。例如序列、键值</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;&#123; range &lt;值&gt; &#125;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 引用内容 </span></span><br><span class="line"></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>示例：遍历数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/values.yaml </span></span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line"> - 1</span><br><span class="line"> - 2</span><br><span class="line"> - 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/configmap.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">data:</span><br><span class="line">  <span class="built_in">test</span>: |</span><br><span class="line">  &#123;&#123;- range.Values.<span class="built_in">test</span> &#125;&#125;</span><br><span class="line">    &#123;&#123; . &#125;&#125;     <span class="comment"># 引用当前元素</span></span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证渲染结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web1 --dry-run mychart/</span><br></pre></td></tr></table></figure>
<p><img src="/images/4966CE8B45B34D61BBE81B9D34F0CD78clipboard.png" alt></p>
<p><img src="/images/BF43CE3AE01B400EB0D563D60A43462Aclipboard.png" alt></p>
<h2 id="Chart模板：流程控制之with">Chart模板：流程控制之with</h2>
<p>with：指定变量作用域</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;&#123; with &lt;值&gt; &#125;&#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment"># 限制范围 </span></span><br><span class="line"></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>with语句可以允许将当前范围 . 设置为特定的对象，比如我们前面一直使用 的 .Values.nodeSelecotr，我们可以使用 with来将 . 范围指向 .Values.nodeSelecotr：</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/values.yaml </span></span><br><span class="line">labels:</span><br><span class="line">  project: <span class="string">&quot;ms&quot;</span></span><br><span class="line">  app: <span class="string">&quot;gateway&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/deploy.yaml </span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    &#123;&#123;- with .Values.labels &#125;&#125;</span><br><span class="line">    project: &#123;&#123; .project &#125;&#125;</span><br><span class="line">    app: &#123;&#123; .app &#125;&#125;</span><br><span class="line">    &#123;&#123;- end &#125;&#125;</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicaCount &#125;&#125;</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        gpu: &#123;&#123; quote .Values.nodeSelector.gpu &#125;&#125;</span><br><span class="line">      containers:</span><br><span class="line">      - image: &#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag &#125;&#125;</span><br><span class="line">        name: nginx</span><br><span class="line">        &#123;&#123;- <span class="keyword">if</span> .Values.resources &#125;&#125;</span><br><span class="line">        resources:</span><br><span class="line">          &#123;&#123;- toYaml .Values.resources | nindent 10 &#125;&#125;</span><br><span class="line">        &#123;&#123;- end &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证渲染结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web1 --dry-run mychart/</span><br></pre></td></tr></table></figure>
<p><img src="/images/21779EEC6FA14E3BB33B062E0260B6AAclipboard.png" alt></p>
<p><img src="/images/A8443F325B964323B52B235D31702C73clipboard.png" alt></p>
<p>with块限制了变量作用域，也就是无法直接引用模板对象，例 如.Values、.Release，如果还想使用，可以定义变量来解决该问题。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/deploy.yaml </span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    &#123;&#123;- <span class="variable">$rs</span> := .Values.replicaCount &#125;&#125;</span><br><span class="line">    &#123;&#123;- with .Values.labels &#125;&#125;</span><br><span class="line">    project: &#123;&#123; .project &#125;&#125;</span><br><span class="line">    app: &#123;&#123; .app &#125;&#125;&#123;&#123; <span class="variable">$rs</span> &#125;&#125;</span><br><span class="line"> <span class="comment">#   test: &#123;&#123; $rs &#125;&#125;</span></span><br><span class="line">    &#123;&#123;- end &#125;&#125;</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web1 --dry-run mychart/</span><br></pre></td></tr></table></figure>
<p><img src="/images/1383868802C447B69BDD70FD2259B833clipboard.png" alt></p>
<p><img src="/images/FD1F081CEEDC4B03AE47FC06CC91C7B8clipboard.png" alt></p>
<p>或者</p>
<p><img src="/images/152EFB492576489F915684E9C07FAA2Eclipboard.png" alt></p>
<h2 id="Chart模板：变量">Chart模板：变量</h2>
<p>变量是实际应用中不多，但有时候结合with、range能更好处理数据。</p>
<p>示例：k8s变量是键值，可以range遍历生成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/values.yaml </span></span><br><span class="line"><span class="built_in">env</span>:</span><br><span class="line">  NAME: <span class="string">&quot;gateway&quot;</span></span><br><span class="line">  JAVA_OPTS: <span class="string">&quot;-Xmx1G&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/deploy.yaml </span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    &#123;&#123;- <span class="variable">$rs</span> := .Values.replicaCount &#125;&#125;</span><br><span class="line">    &#123;&#123;- with .Values.labels &#125;&#125;</span><br><span class="line">    project: &#123;&#123; .project &#125;&#125;</span><br><span class="line">    app: &#123;&#123; .app &#125;&#125;&#123;&#123; $.Values.replicaCount &#125;&#125;</span><br><span class="line"> <span class="comment">#   test: &#123;&#123; $rs &#125;&#125;</span></span><br><span class="line">    &#123;&#123;- end &#125;&#125;</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicaCount &#125;&#125;</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: &#123;&#123; .Values.selectorLabels &#125;&#125;</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        gpu: &#123;&#123; quote .Values.nodeSelector.gpu &#125;&#125;</span><br><span class="line">      containers:</span><br><span class="line">      - image: &#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag &#125;&#125;</span><br><span class="line">        name: nginx</span><br><span class="line">        &#123;&#123;- <span class="keyword">if</span> .Values.resources &#125;&#125;</span><br><span class="line">        resources:</span><br><span class="line">          &#123;&#123;- toYaml .Values.resources | nindent 10 &#125;&#125;</span><br><span class="line">        &#123;&#123;- end &#125;&#125;</span><br><span class="line">        <span class="built_in">env</span>:</span><br><span class="line">        &#123;&#123;- range <span class="variable">$k</span>,<span class="variable">$v</span> := .Values.<span class="built_in">env</span> &#125;&#125;</span><br><span class="line">        - name: &#123;&#123; <span class="variable">$k</span> &#125;&#125;</span><br><span class="line">          value: &#123;&#123; quote <span class="variable">$v</span> &#125;&#125;</span><br><span class="line">        &#123;&#123;- end &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证渲染结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web1 --dry-run mychart/</span><br></pre></td></tr></table></figure>
<p><img src="/images/B72C8E5F6D944A7DB06EE9293FB2E740clipboard.png" alt></p>
<p><img src="/images/8FEACF78569D490B89E18A61471B971Fclipboard.png" alt></p>
<h2 id="Chart模板：命名模板">Chart模板：命名模板</h2>
<p>命名模板类似于开发语言中的函数。指一段可以直接被另一段程序或代码引用的程序或代码。 在编写chart时，可以将一些重复使用的内容写在命名模板文件中供公共使用，这样可减少重 复编写程序段和简化代码结构。</p>
<p>命名模块使用define定义，template或include引入，在templates目录中默认下划线开头的 文件为公共模板（helpers.tpl）。</p>
<p>示例：资源名称生成指令放到公共模板文件，作为所有资源名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/_helpers.tpl </span></span><br><span class="line">&#123;&#123;- define <span class="string">&quot;fullname&quot;</span> -&#125;&#125;</span><br><span class="line">&#123;&#123;- .Chart.Name -&#125;&#125;-&#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/deploy.yaml </span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    &#123;&#123;- <span class="variable">$rs</span> := .Values.replicaCount &#125;&#125;</span><br><span class="line">    &#123;&#123;- with .Values.labels &#125;&#125;</span><br><span class="line">    project: &#123;&#123; .project &#125;&#125;</span><br><span class="line">    app: &#123;&#123; .app &#125;&#125;&#123;&#123; $.Values.replicaCount &#125;&#125;</span><br><span class="line"> <span class="comment">#   test: &#123;&#123; $rs &#125;&#125;</span></span><br><span class="line">    &#123;&#123;- end &#125;&#125;</span><br><span class="line">  name: &#123;&#123; template <span class="string">&quot;fullname&quot;</span> . &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证渲染结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web1 --dry-run mychart/</span><br></pre></td></tr></table></figure>
<p><img src="/images/004FB4DA579D42B7B655B62B2D5C5EF9clipboard.png" alt></p>
<p><img src="/images/DD4111BC15A7435B8705604525DD8D3Fclipboard.png" alt></p>
<p>template指令是将一个模板包含在另一个模板中的方法。但是，template函 数不能用于Go模板管道。为了解决该问题，引入include指令。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/_helpers.tpl </span></span><br><span class="line">&#123;&#123;- define <span class="string">&quot;labels&quot;</span> -&#125;&#125;</span><br><span class="line">project: &#123;&#123; .Values.labels.project &#125;&#125;</span><br><span class="line">app: &#123;&#123; .Values.labels.app &#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi mychart/templates/deploy.yaml </span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    &#123;&#123;- include <span class="string">&quot;labels&quot;</span> .| nindent 4 &#125;&#125;</span><br><span class="line">  name: &#123;&#123; template <span class="string">&quot;fullname&quot;</span> . &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证渲染结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web1 --dry-run mychart/</span><br></pre></td></tr></table></figure>
<p><img src="/images/AFC74B98D3B94D7BB2A2AEB879B9CD7Cclipboard.png" alt></p>
<p><img src="/images/50895149528F4150B032CB05B050795Dclipboard.png" alt></p>
<h2 id="带你写一个通用的Chart">带你写一个通用的Chart</h2>
<ol>
<li>
<p>先创建模板示例 helm create demo</p>
</li>
<li>
<p>修改Chart.yaml，Values.yaml，参考示例预留变动的字段值</p>
</li>
<li>
<p>在templates目录下准备部署应用所需的yaml文件，并添加指令引用 Values.yaml字段</p>
</li>
<li>
<p>将重复使用的内容作为命名模板</p>
</li>
<li>
<p>使用Chart结合参数部署多个同类服务</p>
</li>
</ol>
<p><a href="/attachments/D1634A79483D4B0F8BAF5730F9A04D5Ademo-0.1.0.tgz">demo-0.1.0.tgz</a></p>
<h2 id="使用Harbor作为Chart仓库">使用Harbor作为Chart仓库</h2>
<p>Harbor是一个主流的镜像仓库系统，在 v1.6 版本以后的 harbor 中新增加了 helm charts 的管理功能，可以存储Chart文件。</p>
<p>使用步骤：</p>
<p>1、启用Harbor的Chart仓库服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./install.sh --with-chartmuseum</span></span><br></pre></td></tr></table></figure>
<p>启用后，默认创建的项目就带有helm charts功能了。</p>
<p>2、安装push插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm plugin install https://github.com/chartmuseum/helm-push</span><br><span class="line"><span class="built_in">ls</span> /root/.local/share/helm/plugins/helm-push/  <span class="comment">#家目录</span></span><br></pre></td></tr></table></figure>
<p>3、推送</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># helm push demo-0.1.0.tgz --username=admin --password=Harbor12345 http://192.168.0.13/chartrepo/library</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/D0A47CBD70C147A4A0FEAE1FA00CFF70clipboard.png" alt></p>
<p>4、添加repo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add myrepo --username=admin --password=Harbor12345 http://192.168.0.13:/chartrepo/library</span><br><span class="line">helm repo update</span><br><span class="line">helm repo list</span><br></pre></td></tr></table></figure>
<p>5、部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># helm install web --version 0.1.0 myrepo/demo   #--version指定chart版本，如果未指定，使用最新版本</span></span><br><span class="line">helm install web1 --<span class="built_in">set</span> service.type=NodePort --<span class="built_in">set</span> service.nodeport=30010 myrepo/demo </span><br></pre></td></tr></table></figure>
<h2 id="公共Chart仓库">公共Chart仓库</h2>
<p>国内Chart仓库，可直接使用它们制作好的包：</p>
<ul>
<li>
<p>微软仓库（<a href="http://mirror.azure.cn/kubernetes/charts/%EF%BC%89">http://mirror.azure.cn/kubernetes/charts/）</a></p>
</li>
<li>
<p>阿里云仓库（<a href="https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts">https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</a> ）</p>
</li>
<li>
<p>官方仓库（<a href="https://hub.kubeapps.com/charts/incubator%EF%BC%89">https://hub.kubeapps.com/charts/incubator）</a></p>
</li>
</ul>
<p>添加仓库方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add stable http://mirror.azure.cn/kubernetes/charts </span><br><span class="line">helm repo add aliyun https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts </span><br><span class="line">helm repo update </span><br><span class="line">helm repo list</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 弹性伸缩</title>
    <url>/2023/08/20/kubernetes%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/</url>
    <content><![CDATA[<h2 id="弹性伸缩概述">弹性伸缩概述</h2>
<p>从传统意义上，弹性伸缩主要解决的问题是容量规划与实际负载的矛盾。</p>
<p>蓝色水位线表示集群资源容量随着负载的增加不断扩容，红色曲线表示集群资源实际负载变化。</p>
<p>弹性伸缩就是要解决当实际负载增大，而集群资源容量没来得及反应的问题。</p>
<p><img src="/images/BB1A0303527447A88DC9326D3AA0D49Cclipboard.png" alt></p>
<h2 id="Kubernetes弹性伸缩布局">Kubernetes弹性伸缩布局</h2>
<p>在Kubernetes平台中，资源分为两个维度：</p>
<ul>
<li>
<p>Node级别：K8s将多台服务器抽象一个集群资源池，每个Node提供这些资源</p>
</li>
<li>
<p>Pod级别：Pod是K8s最小部署单元，运行实际的应用程序，使用request和limit为Pod配额</p>
</li>
</ul>
<p>因此，K8s实现弹性伸缩也是这两个级别，当Node资源充裕情况下，Pod可任意弹性，当不足情况下需要弹性增加节 点来扩容资源池。</p>
<p>针对Pod负载：当Pod资源不足时，使用HPA（Horizontal Pod Autoscaler）自动增加Pod副本数量</p>
<p>针对Node负载：当集群资源池不足时，使用CA（Cluster Autoscaler）自动增加Node</p>
<h2 id="Node自动扩容-缩容">Node自动扩容/缩容</h2>
<p>Node弹性伸缩有两种方案：</p>
<ul>
<li>Cluster Autoscaler：是一个自动调整Kubernetes集群大小的组件，需要与公有云一起使用，例如AWS、Azure、Aliyun</li>
</ul>
<p>项目地址： <a href="https://github.com/kubernetes/autoscaler">https://github.com/kubernetes/autoscaler</a></p>
<ul>
<li>自研发：根据Node监控指标或者Pod调度状态判断是否增加Node，需要一定开发成本</li>
</ul>
<h2 id="Node自动扩容-缩容：实现思路">Node自动扩容/缩容：实现思路</h2>
<p><img src="/images/30B60E47CD814092B76494C3BDB798ECclipboard.png" alt></p>
<h2 id="Node自动扩容-缩容：-Cluster-Autoscaler">Node自动扩容/缩容： Cluster Autoscaler</h2>
<p>Cluster Autoscaler支持的云提供商：</p>
<ul>
<li>
<p>阿里云：<a href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/alicloud/README.md">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/alicloud/README.md</a></p>
</li>
<li>
<p>AWS：<a href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md</a></p>
</li>
<li>
<p>Azure：<a href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/azure/README.md">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/azure/README.md</a></p>
</li>
<li>
<p>GCE：<a href="https://kubernetes.io/docs/concepts/cluster-administration/cluster-management/">https://kubernetes.io/docs/concepts/cluster-administration/cluster-management/</a></p>
</li>
<li>
<p>GKE：<a href="https://cloud.google.com/container-engine/docs/cluster-autoscaler">https://cloud.google.com/container-engine/docs/cluster-autoscaler</a></p>
</li>
</ul>
<h2 id="Node自动扩容-缩容：-自研发">Node自动扩容/缩容： 自研发</h2>
<p>当集群资源不足时，触发新增Node大概思路：</p>
<ol>
<li>
<p>申请一台服务器</p>
</li>
<li>
<p>调用Ansible脚本部署Node组件并自动加入集群</p>
</li>
<li>
<p>检查服务是否可用，加入监控</p>
</li>
<li>
<p>完成Node扩容，接收新Pod</p>
</li>
</ol>
<p><img src="/images/CB1FCD583CEB442281E88BE448982FA2clipboard.png" alt></p>
<p>自动增加Node：<a href="https://gitee.com/lucky_liuzhe/ansible-install-k8s-v1.20">https://gitee.com/lucky_liuzhe/ansible-install-k8s-v1.20</a></p>
<p>自动减少Node：</p>
<p>如果你想从Kubernetes集群中删除节点，正确流程如下：</p>
<p>1、获取节点列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure>
<p>2、设置不可调度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl cordon k8s-node3</span><br></pre></td></tr></table></figure>
<p><img src="/images/FFFAEE57CF3F44C6A1C5F7212C52C438clipboard.png" alt></p>
<p>3、驱逐节点上的Pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl drain k8s-node3 --ignore-daemonsets </span><br></pre></td></tr></table></figure>
<p><img src="/images/FF9E2B69D83F4F0FB47B6300C49E24A6clipboard.png" alt></p>
<p>4、移除节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete nodes k8s-node3</span><br></pre></td></tr></table></figure>
<p><img src="/images/16117269F4D44E79A1418F0E78971E2Fclipboard.png" alt></p>
<h2 id="Pod自动扩容-缩容：HPA介绍">Pod自动扩容/缩容：HPA介绍</h2>
<p>Horizontal Pod Autoscaler（HPA，Pod水平自动伸缩）：根据资源利用率或者自定义指 标自动调整Deployment的Pod副本数量，提供应用并发。HPA不适于无法缩放的对象，例 如DaemonSet。</p>
<p><img src="/images/D5F24F5FED2A423F996908F125DED50Aclipboard.png" alt></p>
<h2 id="Pod自动扩容-缩容：HPA基本工作原理">Pod自动扩容/缩容：HPA基本工作原理</h2>
<p>Kubernetes 中的 Metrics Server 持续采集所有 Pod 副本的指标数据。HPA 控制器通过 Metrics Server 的 API（聚合 API）获取这些数据，基于用户定义的扩缩容规则进行计算，得到目标 Pod 副本 数量。当目标 Pod 副本数量与当前副本数量不同时，HPA 控制器就向 Pod 的Deployment控制器发起 scale 操作，调整 Pod 的副本数量，完成扩缩容操作。</p>
<p><img src="/images/60E86E6523694505B69AF566B7F07302clipboard.png" alt></p>
<h2 id="Pod自动扩容-缩容：使用HPA前提条件">Pod自动扩容/缩容：使用HPA前提条件</h2>
<p>使用HPA，确保满足以下条件：</p>
<p>启用Kubernetes API聚合层</p>
<p>相应的API已注册：</p>
<ul>
<li>
<p>对于资源指标（例如CPU、内存），<a href="http://xn--metrics-oc6k644gls6c.k8s.io">将使用metrics.k8s.io</a> API，一般由metrics-server提供。</p>
</li>
<li>
<p>对于自定义指标（例如QPS），<a href="http://xn--custom-vt9i986frw5c.metrics.k8s.io">将使用custom.metrics.k8s.io</a> API，由相关适配器（Adapter）服务提供。</p>
</li>
</ul>
<p>已知适配器列表：<a href="https://github.com/kubernetes/metrics/blob/master/IMPLEMENTATIONS.md#custom-metrics-api">https://github.com/kubernetes/metrics/blob/master/IMPLEMENTATIONS.md#custom-metrics-api</a></p>
<p>Kubernetes API聚合层：</p>
<p>在 Kubernetes 1.7 版本引入了聚合层，允许第三方应用程序通过将自己注册到 kube-apiserver上，仍然通过 API Server 的 HTTP URL 对新的 API 进行访问和 操作。为了实现这个机制，Kubernetes 在 kube-apiserver 服务中引入了一个 API 聚合层（API Aggregation Layer），用于将扩展 API 的访问请求转发到用 户服务的功能。</p>
<p><img src="/images/9718B972CAF34241AD0F965085648A7Eclipboard.png" alt></p>
<p>启用聚合层：</p>
<p>如果你使用kubeadm部署的，默认已开启。</p>
<p>如果 你使用二进制方式部署的话，需要在kubeAPIServer中添加启动参数，增加以下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi /opt/kubernetes/cfg/kube-apiserver.conf</span></span><br><span class="line">...</span><br><span class="line">--requestheader-client-ca-file=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">--proxy-client-cert-file=/opt/kubernetes/ssl/server.pem \</span><br><span class="line">--proxy-client-key-file=/opt/kubernetes/ssl/server-key.pem \</span><br><span class="line">--requestheader-allowed-names=kubernetes \</span><br><span class="line">--requestheader-extra-headers-prefix=X-Remote-Extra- \</span><br><span class="line">--requestheader-group-headers=X-Remote-Group \</span><br><span class="line">--requestheader-username-headers=X-Remote-User \</span><br><span class="line">--enable-aggregator-routing=<span class="literal">true</span> \</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/642AB396EAB54FB7B1354114EAF2EC5Bclipboard.png" alt></p>
<h2 id="Pod自动扩容-缩容：基于资源指标">Pod自动扩容/缩容：基于资源指标</h2>
<p>Metrics Server：是一个数据聚合器，从kubelet收集资源指标，并通 过Metrics API在Kubernetes apiserver暴露，以供HPA使用。</p>
<p>项目地址：<a href="https://github.com/kubernetes-sigs/metrics-server">https://github.com/kubernetes-sigs/metrics-server</a></p>
<p>Metrics Server部署：</p>
<p>wget <a href="https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml">https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi components.yaml </span></span><br><span class="line">...</span><br><span class="line">      containers:</span><br><span class="line">      - args:</span><br><span class="line">        - --cert-dir=/tmp</span><br><span class="line">        - --secure-port=4443</span><br><span class="line">        - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span><br><span class="line">        - --kubelet-use-node-status-port</span><br><span class="line">        - --kubelet-insecure-tls</span><br><span class="line">        image: lizhenliang/metrics-server:v0.4.1</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>kubelet-insecure-tls：不验证kubelet提供的https证书</p>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get apiservices |grep metrics</span><br><span class="line">kubectl get --raw /apis/metrics.k8s.io/v1beta1/nodes</span><br><span class="line">kubectl get --raw /apis/metrics.k8s.io/v1beta1/pods</span><br></pre></td></tr></table></figure>
<p>也可以使用kubectl top访问Metrics API：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl top node <span class="comment">#查看Node资源消耗</span></span><br><span class="line">kubectl top pod <span class="comment">#查看Pod资源消耗</span></span><br></pre></td></tr></table></figure>
<p>如果能正常显示资源消耗说明Metrics Server服务工作正常。</p>
<p>kubectl top ——&gt;apiserver——&gt;metrics-server——&gt;kubelet(cadivosr)——&gt;pod</p>
<p>1、部署应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment web --image=nginx --dry-run=client -o yaml &gt; deployment.yaml</span><br><span class="line">kubectl expose deployment web --port=80 --target-port=80 --dry-run=client -o yaml &gt; service.yaml</span><br></pre></td></tr></table></figure>
<p>注意：修改yaml，增加resources.requests.cpu</p>
<p>2、创建HPA</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl autoscale deployment web --min=2 --max=10 --cpu-percent=80</span><br><span class="line">kubectl get hpa</span><br></pre></td></tr></table></figure>
<p>说明：为名为web的deployment创建一个HPA对象，目标CPU使用率为80%，副本数量配置为2到10之间。</p>
<p><img src="/images/029910BC61E7421F83E9C9FC86A91439clipboard.png" alt></p>
<p>3、压测</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install httpd-tools</span><br><span class="line">ab -n 300000 -c 1000 http://10.0.0.236/index.html  <span class="comment"># 总30w请求，并发1000</span></span><br></pre></td></tr></table></figure>
<p>4、观察扩容状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get hpa</span><br><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure>
<p><img src="/images/975D6546371D43BF9540211C04A9F1EEclipboard.png" alt></p>
<h2 id="Pod自动扩容-缩容：冷却周期">Pod自动扩容/缩容：冷却周期</h2>
<p>在弹性伸缩中，冷却周期是不能逃避的一个话题， 由于评估的度量标准是动态特性，副本的数量可能会不断波动， 造成丢失流量，所以不应该在任意时间扩容和缩容。</p>
<p>在 HPA 中，为缓解该问题，默认有一定控制：</p>
<ul>
<li>
<p>–horizontal-pod-autoscaler-downscale-delay ：当前操作完成后等待多次时间才能执行缩容操作，默认5分钟</p>
</li>
<li>
<p>–horizontal-pod-autoscaler-upscale-delay ：当前操作完成后等待多长时间才能执行扩容操作，默认3分钟</p>
</li>
</ul>
<p>可以通过调整kube-controller-manager组件启动参数调整。</p>
<h2 id="Pod自动扩容-缩容：基于自定义指标">Pod自动扩容/缩容：基于自定义指标</h2>
<p>为满足更多的需求，HPA也支持自定义指标，例如QPS、5xx错误状态码等，实现自定义指标由autoscaling/v2版本提供，而 v2版本又分为beta1和beta2两个版本。</p>
<p>这两个版本的区别是 autoscaling/v1beta1支持了 ：</p>
<ul>
<li>
<p>Resource Metrics（资源指标）</p>
</li>
<li>
<p>Custom Metrics（自定义指标）</p>
</li>
</ul>
<p>而在 autoscaling/v2beta2的版本中额外增加了External Metrics（扩展指标）的支持。</p>
<p>对于自定义指标（例如QPS），<a href="http://xn--custom-vt9i986frw5c.metrics.k8s.io">将使用custom.metrics.k8s.io</a> API，由相关适配器（Adapter）服务提供。</p>
<p>已知适配器列表：<a href="https://github.com/kubernetes/metrics/blob/master/IMPLEMENTATIONS.md#custom-metrics-api">https://github.com/kubernetes/metrics/blob/master/IMPLEMENTATIONS.md#custom-metrics-api</a></p>
<p><img src="/images/4354F6CA800D467C96B6FE51DF0EA02Cclipboard.png" alt></p>
<p>假设我们有一个网站，想基于每秒接收到的HTTP请求对其Pod进行 自动缩放，实现HPA大概步骤：</p>
<p>1、部署Prometheus</p>
<p>2、对应用暴露指标，部署应用，并让Prometheus采集暴露的指标</p>
<p>3、部署Prometheus Adapter</p>
<p>4、为指定HPA配置Prometheus Adapter</p>
<p>5、创建HPA</p>
<p>6、压测、验证</p>
<p>Prometheus（普罗米修斯）是一个开源的监控系统，在Kubernetes平台得到广泛应用。</p>
<p><img src="/images/076AE4A02CD644FE8C97441AA06AFE02clipboard.png" alt></p>
<p>1、部署Prometheus</p>
<p><a href="/attachments/B7E7DFAB30904CC8BFF8A51848CC571Aprometheus.zip">prometheus.zip</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f .</span><br><span class="line">prometheus-deployment.yaml <span class="comment"># 部署Prometheus</span></span><br><span class="line">prometheus-configmap.yaml <span class="comment"># Prometheus配置文件，主要配置基于Kubernetes服务发现</span></span><br><span class="line">prometheus-rules.yaml <span class="comment"># Prometheus告警规则</span></span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://NodeIP:30090">http://NodeIP:30090</a></p>
<p><img src="/images/FCA892D84C824901A612C96B7D44F38Aclipboard.png" alt></p>
<p>2、对应用暴露指标，部署应用，并让Prometheus采集暴露的指标。</p>
<p>在做这步之前先了解下Prometheus如何监控应用的。</p>
<p>如果要想监控，前提是能获取被监控端指标数据，并且这个数据格式必须遵 循Prometheus数据模型，这样才能识别和采集，一般使用exporter提供监 控指标数据。但对于自己开发的项目，是需要自己实现类似于exporter的指 标采集程序。</p>
<p>exporter列表：<a href="https://prometheus.io/docs/instrumenting/exporters">https://prometheus.io/docs/instrumenting/exporters</a></p>
<p><img src="/images/2BA1364BE5C14304AE57EE4F4F29D42Cclipboard.png" alt></p>
<p>先模拟自己开发一个网站，采用Python Flask Web框架，写两个页面：</p>
<ul>
<li>
<p>/ 首页</p>
</li>
<li>
<p>/metrics 指标</p>
</li>
</ul>
<p>然后使用Dockefile制作成镜像并部署到Kubernetes平台。</p>
<p><a href="/attachments/0EAFCBECFD4F42879075E1CE8990D2EFmetrics-app.zip">metrics-app.zip</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f metrics-flask-app.yaml  <span class="comment">#部署应用对外暴露指标并声明让prometheus采集</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/9A74475680A24C1C995BEFA1F54AE871clipboard.png" alt></p>
<p>由于我们Prometheus配置了基于Kubernetes服务发现，会自动采集Pod暴露的指标：</p>
<p><img src="/images/27BB787CAD964355930CCEE95858D3ADclipboard.png" alt></p>
<p><img src="/images/46A280BD5F6D4A5C9E2F14B0BC21A847clipboard.png" alt></p>
<p>3、部署Prometheus Adapter</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f prometheus-adapter.yaml</span><br></pre></td></tr></table></figure>
<p>验证是否正常工作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get apiservices |grep custom</span><br><span class="line">kubectl get --raw <span class="string">&quot;/apis/custom.metrics.k8s.io/v1beta1&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/06B921886DCB4A22AA557A870DDE2C52clipboard.png" alt></p>
<p>4、为指定HPA配置Prometheus Adapter</p>
<p>增加一段配置，增加完后删除adapter pod重建生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi prometheus-adapter.yaml</span></span><br><span class="line">data:</span><br><span class="line">  config.yaml: |</span><br><span class="line">    rules:</span><br><span class="line">    - seriesQuery: <span class="string">&#x27;request_count_total&#123;app=&quot;flask-app&quot;&#125;&#x27;</span></span><br><span class="line">      resources:</span><br><span class="line">        overrides:</span><br><span class="line">          kubernetes_namespace: &#123;resource: <span class="string">&quot;namespace&quot;</span>&#125;</span><br><span class="line">          kubernetes_pod_name: &#123;resource: <span class="string">&quot;pod&quot;</span>&#125;</span><br><span class="line">      name:</span><br><span class="line">        matches: <span class="string">&quot;request_count_total&quot;</span></span><br><span class="line">        as: <span class="string">&quot;qps&quot;</span></span><br><span class="line">      metricsQuery: <span class="string">&#x27;sum(rate(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;&#125;[2m])) by (&lt;&lt;.GroupBy&gt;&gt;)&#x27;</span></span><br><span class="line">    - seriesQuery: <span class="string">&#x27;&#123;__name__=~&quot;^container_.*&quot;,container!=&quot;POD&quot;,namespace!=&quot;&quot;,pod!=&quot;&quot;&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置描述：</p>
<ul>
<li>
<p>seriesQuery：Prometheus查询语句，查询应用系列指标。</p>
</li>
<li>
<p>resources：Kubernetes资源标签映射到Prometheus标签。</p>
</li>
<li>
<p>name：将Prometheus指标名称在自定义指标API中重命名， matches正则匹配，as指定新名称。</p>
</li>
<li>
<p>metricsQuery：一个Go模板，对调用自定义指标API转换为 Prometheus查询语句。</p>
</li>
</ul>
<p>Adapter向Prometheus查询语句最终是：</p>
<p>sum(rate(request_count_total{app=“flask-app”, kubernetes_namespace=“default”}[2m])) by (kubernetes_pod_name)</p>
<p>由于HTTP请求统计是累计的，对HPA自动缩放不是特别有用，因此将其转为速率指标。 这条语句意思是：查询每个Pod在2分钟内访问速率，即QPS（每秒查询率）</p>
<p><img src="/images/288324F062F64096A5BFA295B30E2468clipboard.png" alt></p>
<p>向自定义指标API访问：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get --raw <span class="string">&quot;/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/*/qps&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果配置没问题，会返回JSON数据，注意里面的value字段，HPA控制器会拿这个值计算然后比对阈值。这个值单位是m，表示 毫秒，千分之一，例如值为500m是每秒0.5个请求，10000m是每秒10个请求（并发）。</p>
<p><img src="/images/00740B593E1C42479ADA61F0D40FE0D5clipboard.png" alt></p>
<p>进一步模拟验证：</p>
<p><img src="/images/7870750D339B47298292D035876488DFclipboard.png" alt></p>
<p>对比请求的数据：</p>
<p><img src="/images/7F9CDC8EA0524B878823B38929B98518clipboard.png" alt></p>
<p><img src="/images/DB3C8D8A632D42498A58BFF087C23C93clipboard.png" alt></p>
<p>5、创建HPA</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi hpa-v2-qps.yaml</span></span><br><span class="line"></span><br><span class="line">apiVersion: autoscaling/v2beta2</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: metrics-flask-app</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  maxReplicas: 10</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: metrics-flask-app</span><br><span class="line">  metrics:</span><br><span class="line">  - <span class="built_in">type</span>: Pods</span><br><span class="line">    pods:</span><br><span class="line">      metric:</span><br><span class="line">        name: qps</span><br><span class="line">      target:</span><br><span class="line">        <span class="built_in">type</span>: AverageValue</span><br><span class="line">        averageValue: 10000m    <span class="comment"># 所有Pod平均值为10000m触发扩容，即每秒10个请求</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>每秒超过10个请求进行扩容pod操作</p>
<p><img src="/images/5FFECCEDFB4849D69DBC010EBCD3C5B6clipboard.png" alt></p>
<p><img src="/images/65CA2980E64B4AAAA8068141195E0F98clipboard.png" alt></p>
<p><img src="/images/B0473BE0FE72441380AB7ED8F85B7C8Eclipboard.png" alt></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes核心概念</title>
    <url>/2022/06/10/kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="有了Docker，为什么还用Kubernetes？">有了Docker，为什么还用Kubernetes？</h2>
<p>为提高业务并发和高可用，会使用多台服务器，因此会面向这些问题：</p>
<ul>
<li>
<p>多容器跨主机提供服务</p>
</li>
<li>
<p>多容器分布节点部署</p>
</li>
<li>
<p>多容器怎么升级</p>
</li>
<li>
<p>怎么高效管理这些容器</p>
</li>
</ul>
<p><img src="/images/28FBDEB7C0804F9C9A9E53A5C9DEC0C5clipboard.png" alt></p>
<p>容器编排系统：</p>
<ul>
<li>
<p>Kubernetes</p>
</li>
<li>
<p>Swarm</p>
</li>
<li>
<p>Mesos Marathon</p>
</li>
</ul>
<p><img src="/images/B1FE2493A067433EBB99A47D55740E33clipboard.png" alt></p>
<h2 id="Kubernetes是什么">Kubernetes是什么</h2>
<ul>
<li>
<p>Kubernetes是Google在2014年开源的一个容器集群管理系统，Kubernetes简称K8s。</p>
</li>
<li>
<p>Kubernetes用于容器化应用程序的部署，扩展和管理，目标是让部署容器化应用简单高效</p>
</li>
</ul>
<p>官方网站：<a href="http://www.kubernetes.io/">http://www.kubernetes.io/</a></p>
<p>官方文档：<a href="https://kubernetes.io/zh/docs/home/">https://kubernetes.io/zh/docs/home/</a></p>
<h2 id="Kubernetes集群架构与组件">Kubernetes集群架构与组件</h2>
<p><img src="/images/2C6E9B5C538E4A97A18CC499EFCC98ADclipboard.png" alt></p>
<p><img src="/images/FF51CE19DAFF43B6AEB17650553CE68Aclipboard.png" alt></p>
<h3 id="Master组件">Master组件</h3>
<p>kube-apiserver</p>
<p>Kubernetes API，集群的统一入口，各组件协调者，以RESTful API提供接口服务，所有对			   象资源的增删改查和监听操作都交给 APIServer处理后再提交给Etcd存储。</p>
<p>kube-controller-manager</p>
<p>处理集群中常规后台任务，一个资源对应一个控制器，而 ControllerManager就是负责管理这些控制器的。</p>
<p>kube-scheduler</p>
<p>根据调度算法为新创建的Pod选择一个Node节点，可以任意部署, 可以部署在同一个节点上,也可以部署在不同的节点上。</p>
<p>etcd</p>
<p>分布式键值存储系统。用于保存集群状态数据，比如Pod、Service 等对象信息。</p>
<h3 id="Node组件">Node组件</h3>
<p>kubelet</p>
<p>kubelet是Master在Node节点上的Agent，管理本机运行容器的生命周 期，比如创建容器、Pod挂载数据卷、下载secret、获取容器和节点状态 等工作。kubelet将每个Pod转换成一组容器。</p>
<p>kube-proxy</p>
<p>在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作。</p>
<p>docker或rocket</p>
<p>容器引擎，运行容器。</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes运维管理</title>
    <url>/2023/08/10/kubernetes%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="Kubernetes-容器云平台技术方案">Kubernetes 容器云平台技术方案</h2>
<p><img src="/images/BE0CAF453EFC4A9C9A313378AEEBB235clipboard.png" alt></p>
<h3 id="Kubernetes-容器云平台技术方案：存储">Kubernetes 容器云平台技术方案：存储</h3>
<p>Ceph是一个高性能的分布式存储系统，提供对象存 储、块存储和文件存储功能，可存储海量数据。 角色：Pod数据持久化存储</p>
<p><img src="/images/0529DD2E898E451381DDB87446AA14A4clipboard.png" alt></p>
<h3 id="Kubernetes-容器云平台技术方案：网络">Kubernetes 容器云平台技术方案：网络</h3>
<p>Calico是一个纯三层的数据中心网络方案，Calico支 持广泛的平台，包括Kubernetes、OpenStack等。 Calico 在每一个计算节点利用 Linux Kernel 实现了 一个高效的虚拟路由器（ vRouter） 来负责数据转发， 而每个 vRouter 通过 BGP 协议负责把自己上运行的 workload 的路由信息向整个 Calico 网络内传播。 此外，Calico 项目还实现了 Kubernetes 网络策略， 提供ACL功能。</p>
<p><img src="/images/FAFC458BFE1740C2A0E4F06C3CEEFC18clipboard.png" alt></p>
<h3 id="Kubernetes-容器云平台技术方案：监控">Kubernetes 容器云平台技术方案：监控</h3>
<p>Prometheus是SoundCloud开源的一款监控 系统。它的实现参考了Google内部的监控系 统，并支持在Kubernetes自动发现被监控端。 是目前Kubernetes监控首选方案。</p>
<p><img src="/images/92B46314509743E0A2952DAC8E4BA734clipboard.png" alt></p>
<p>Pod</p>
<p>kubelet的节点使用cAdvisor提供的metrics接口获取该节点所有 Pod和容器相关的性能指标数据。 指标接口：<a href="https://NodeIP:10250/metrics/cadvisor">https://NodeIP:10250/metrics/cadvisor</a></p>
<p>Node</p>
<p>使用node_exporter收集器采集节点资源利用率。</p>
<p>项目地址：<a href="https://github.com/prometheus/node_exporter">https://github.com/prometheus/node_exporter</a></p>
<p>K8s资源对象</p>
<p>kube-state-metrics采集了k8s中各种资源对象的状态信息。 项目地址：<a href="https://github.com/kubernetes/kube-state-metrics">https://github.com/kubernetes/kube-state-metrics</a></p>
<p><img src="/images/1376CD2E30B54811A8BA135E48D6576Eclipboard.png" alt></p>
<h3 id="Kubernetes-容器云平台技术方案：日志">Kubernetes 容器云平台技术方案：日志</h3>
<p>ELK 是三个开源软件的缩写，提供一套完整的企业级日 志平台解决方案。</p>
<p>分别是：</p>
<ul>
<li>
<p>Elasticsearch：搜索、分析和存储数据</p>
</li>
<li>
<p>Logstash ：采集日志、格式化、过滤，最后将数据 推送到Elasticsearch存储</p>
</li>
<li>
<p>Kibana：数据可视化</p>
</li>
<li>
<p>Beats ：集合了多种单一用途数据采集器，用于实 现从边缘机器向 Logstash 和 Elasticsearch 发送数 据。里面应用最多的是Filebeat，是一个轻量级日 志采集器。</p>
</li>
</ul>
<p><img src="/images/A49093752EEA4E17AEA2BBB45BF27EA4clipboard.png" alt></p>
<p><img src="/images/9180EE3332F14900A846D466D0E82B3Bclipboard.png" alt></p>
<h3 id="Kubernetes-容器云平台技术方案：CI-CD">Kubernetes 容器云平台技术方案：CI/CD</h3>
<p><img src="/images/3DBD05C59B9F4131934A279BD2D2DF4Fclipboard.png" alt></p>
<h3 id="其他事项">其他事项</h3>
<ul>
<li>
<p>选择物理机还是虚拟机？</p>
</li>
<li>
<p>Linux操作系统选哪个好</p>
</li>
<li>
<p>内核是否需要升级？</p>
</li>
<li>
<p>使用命名空间隔离环境</p>
</li>
<li>
<p>使用RBAC分配权限</p>
</li>
<li>
<p>对于应用者来说，K8s编排和应用学习成本大，应平台化操作</p>
</li>
</ul>
<h2 id="自动化部署-Kubernetes-集群">自动化部署 Kubernetes 集群</h2>
<p>有哪些自动化部署工具？</p>
<p>kubeadm</p>
<p><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></p>
<p>kops</p>
<p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kops/">https://kubernetes.io/docs/setup/production-environment/tools/kops/</a></p>
<p><a href="https://github.com/kubernetes/kops">https://github.com/kubernetes/kops</a></p>
<p>kubespray</p>
<p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubespray/">https://kubernetes.io/docs/setup/production-environment/tools/kubespray/</a></p>
<p><a href="https://github.com/kubernetes-sigs/kubespray">https://github.com/kubernetes-sigs/kubespray</a></p>
<p>Ansible Playbook自动化部署K8s集群：<a href="https://gitee.com/lucky_liuzhe/ansible-install-k8s">https://gitee.com/lucky_liuzhe/ansible-install-k8s</a></p>
<p>为什么自己造轮子？</p>
<ul>
<li>
<p>进一步熟悉k8s</p>
</li>
<li>
<p>方便部署</p>
</li>
<li>
<p>更易于维护</p>
</li>
</ul>
<h2 id="Kubernetes-高可用方案">Kubernetes 高可用方案</h2>
<ul>
<li>
<p>Etcd高可用</p>
</li>
<li>
<p>kube-apiserver高可用</p>
</li>
<li>
<p>kube-controller-manager与kube-scheduler高可用</p>
</li>
<li>
<p>CoreDNS高可用</p>
</li>
</ul>
<p><img src="/images/5E920104DEDB44FB82D5CEDAD0EEECD9clipboard.png" alt></p>
<h2 id="Kubernetes-数据库-Etcd-备份与恢复">Kubernetes 数据库 Etcd 备份与恢复</h2>
<p>Kubernetes 使用 Etcd 数据库实时存储集群中的数据，安全起见，一定要备份！</p>
<p>kubeadm部署方式：</p>
<p>备份：</p>
<p>1.安装etcdctl命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install etcd （里面包含ectdctl客户端命令）</span><br></pre></td></tr></table></figure>
<p>2.备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl \</span><br><span class="line">snapshot save snap.db \</span><br><span class="line">--endpoints=https://127.0.0.1:2379 \</span><br><span class="line">--cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/server.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/server.key </span><br></pre></td></tr></table></figure>
<p>恢复：</p>
<p>1、先暂停kube-apiserver和etcd容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /etc/kubernetes/manifests /etc/kubernetes/manifests.bak</span><br><span class="line"><span class="built_in">mv</span> /var/lib/etcd/ /var/lib/etcd.bak</span><br></pre></td></tr></table></figure>
<p>2、恢复</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl \</span><br><span class="line">snapshot restore snap.db \</span><br><span class="line">--data-dir=/var/lib/etcd</span><br></pre></td></tr></table></figure>
<p>3、启动kube-apiserver和etcd容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /etc/kubernetes/manifests.bak /etc/kubernetes/manifests</span><br></pre></td></tr></table></figure>
<p>二进制部署方式：</p>
<p>备份：</p>
<p>1.备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 /opt/etcd/bin/etcdctl \</span><br><span class="line">snapshot save snap.db \</span><br><span class="line">--endpoints=https://192.168.0.11:2379 \</span><br><span class="line">--cacert=/opt/etcd/ssl/ca.pem \</span><br><span class="line">--cert=/opt/etcd/ssl/server.pem \</span><br><span class="line">--key=/opt/etcd/ssl/server-key.pem</span><br></pre></td></tr></table></figure>
<p>2.拷贝备份数据到另两个etcd节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp snap.db root@192.168.0.12:~</span><br><span class="line">scp snap.db root@192.168.0.13:~</span><br></pre></td></tr></table></figure>
<p>恢复：</p>
<p>1、先暂停kube-apiserver和etcd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#所有master节点操作</span></span><br><span class="line">systemctl stop kube-apiserver</span><br><span class="line"><span class="comment">#所有etcd节点操作</span></span><br><span class="line">systemctl stop etcd</span><br><span class="line"><span class="built_in">mv</span> /var/lib/etcd/default.etcd /var/lib/etcd/default.etcd.bak</span><br></pre></td></tr></table></figure>
<p>2、在每个节点上恢复</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 /opt/etcd/bin/etcdctl snapshot restore snap.db \</span><br><span class="line">--name etcd-1 \</span><br><span class="line">--initial-cluster=<span class="string">&quot;etcd-1=https://192.168.0.11:2380,etcd2=https://192.168.0.12:2380,etcd-3=https://192.168.0.13:2380&quot;</span> \</span><br><span class="line">--initial-cluster-token=etcd-cluster \</span><br><span class="line">--initial-advertise-peer-urls=https://192.168.0.11:2380 \</span><br><span class="line">--data-dir=/var/lib/etcd/default.etcd</span><br><span class="line"></span><br><span class="line">ETCDCTL_API=3 /opt/etcd/bin/etcdctl snapshot restore snap.db \</span><br><span class="line">--name etcd-2 \</span><br><span class="line">--initial-cluster=<span class="string">&quot;etcd-1=https://192.168.0.11:2380,etcd2=https://192.168.0.12:2380,etcd-3=https://192.168.0.13:2380&quot;</span> \</span><br><span class="line">--initial-cluster-token=etcd-cluster \</span><br><span class="line">--initial-advertise-peer-urls=https://192.168.0.12:2380 \</span><br><span class="line">--data-dir=/var/lib/etcd/default.etcd</span><br><span class="line"></span><br><span class="line">ETCDCTL_API=3 /opt/etcd/bin/etcdctl snapshot restore snap.db \</span><br><span class="line">--name etcd-3 \</span><br><span class="line">--initial-cluster=<span class="string">&quot;etcd-1=https://192.168.0.11:2380,etcd2=https://192.168.0.12:2380,etcd-3=https://192.168.0.13:2380&quot;</span> \</span><br><span class="line">--initial-cluster-token=etcd-cluster \</span><br><span class="line">--initial-advertise-peer-urls=https://192.168.0.13:2380 \</span><br><span class="line">--data-dir=/var/lib/etcd/default.etcd</span><br></pre></td></tr></table></figure>
<p>3、启动kube-apiserver和etcd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#所有master节点操作</span></span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line"><span class="comment">#所有etcd节点操作</span></span><br><span class="line">systemctl start etcd</span><br></pre></td></tr></table></figure>
<h2 id="Kubelet-证书自动续签">Kubelet 证书自动续签</h2>
<p>K8s证书一般分为两套：K8s组件（apiserver）和Etcd</p>
<p>假如按角色来分，证书分为管理节点和工作节点。</p>
<ul>
<li>
<p>管理节点：如果是kubeadm部署则自动生成，如果是二进制部署一般由cfssl或者openssl生成。</p>
</li>
<li>
<p>工作节点：工作节点主要是指kubelet连接apiserver所需的客户端证书，这个证书由controller-manager组件自动颁发，默认 是一年，如果到期，kubelet将无法使用过期的证书连接apiserver，从而导致无法正常工作，日志会给出证书过期错误（x509: certificate has expired or is not yet valid）</p>
</li>
</ul>
<p><img src="/images/51C5DE0AF4B14580AEC12BE6F0FC0DF0clipboard.png" alt></p>
<p>管理节点：</p>
<ul>
<li>
<p>kube-apiserver  （本地访问apiserver:127.0.0.1:8080 远端访问apiserver:IP:6443）</p>
</li>
<li>
<p>controller-manager  （可单独部署到其他机器）</p>
</li>
<li>
<p>scheduler  （可单独部署到其他机器）</p>
</li>
</ul>
<p>工作节点：</p>
<ul>
<li>
<p>kubelet</p>
</li>
<li>
<p>kube-proxy</p>
</li>
</ul>
<p>#查看证书有效期</p>
<p>kubeadm alpha certs check-expiration</p>
<p>kubeadm:</p>
<p>管理节点：kubeadm alpha certs renew 或者升级k8s版本 kubeadm upgrade</p>
<p><a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/</a></p>
<p>工作节点：</p>
<p>1、配置kube-controller-manager组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim /etc/kubernetes/manifests/kube-controller-manager.yaml </span></span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - <span class="built_in">command</span>:</span><br><span class="line">    - kube-controller-manager</span><br><span class="line">    - --experimental-cluster-signing-duration=87600h0m0s</span><br><span class="line">    - --feature-gates=RotateKubeletServerCertificate=<span class="literal">true</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>添加上述两个参数：</p>
<ul>
<li>
<p>experimental-cluster-signing-duration=87600h0m0s 为kubelet客户端证书颁发有效期10年</p>
</li>
<li>
<p>feature-gates=RotateKubeletServerCertificate=true 启用server证书颁发</p>
</li>
</ul>
<p>配置完成后，重建pod使之生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete pod kube-controller-manager-k8s-master -n kube-system</span><br></pre></td></tr></table></figure>
<p>2、配置kubelet组件</p>
<p>默认kubelet证书轮转已启用：</p>
<p>vi /var/lib/kubelet/config.yaml</p>
<p><img src="/images/67162AA145D94B059DEB71CB8C2ED2D5clipboard.png" alt></p>
<p>3、测试</p>
<p>找一台节点测试，先查看现有客户端证书有效期：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/kubelet/pki/</span><br><span class="line">openssl x509 -<span class="keyword">in</span> kubelet-client-current.pem -noout -dates</span><br></pre></td></tr></table></figure>
<p><img src="/images/38E535415D414FF997BAC641D66C24BFclipboard.png" alt></p>
<p>修改服务器时间，模拟证书即将到期：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2022-2-1&quot;</span></span><br><span class="line">systemctl restart kubelet.service </span><br></pre></td></tr></table></figure>
<p>再查看证书有效期，可以看到已经是十年：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> kubelet-client-current.pem -noout -dates </span><br></pre></td></tr></table></figure>
<p><img src="/images/E513AA60AB32434D92095C3AE79C57BFclipboard.png" alt></p>
<p>二进制：</p>
<p>管理节点：证书自管理</p>
<p>工作节点：</p>
<p>找一台节点查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /opt/kubernetes/ssl</span></span><br><span class="line"><span class="comment"># openssl x509 -in kubelet-client-current.pem -noout -dates</span></span><br><span class="line">notBefore=Aug 8 15:54:54 2020 GMT </span><br><span class="line">notAfter=Aug 7 07:38:00 2025 GMT</span><br><span class="line"><span class="comment"># openssl x509 -in /opt/kubernetes/ssl/ca.pem -noout -dates</span></span><br></pre></td></tr></table></figure>
<p>配置了默认是5年，所以在5年之前不会出现证书过期的问题</p>
<h2 id="Kubernetes-集群常见故障排查思路">Kubernetes 集群常见故障排查思路</h2>
<p>先区分部署方式：</p>
<p>1、kubeadm 除kubelet外，其他组件均采用静态Pod启动</p>
<p>2、二进制 所有组件均采用systemd管理</p>
<p>集群部署类问题：</p>
<ul>
<li>
<p>网络不通</p>
</li>
<li>
<p>启动失败，一般配置文件或者依赖服务</p>
</li>
<li>
<p>平台不兼容</p>
</li>
</ul>
<p>应用部署类问题：</p>
<ul>
<li>
<p>查看资源详情：kubectl describe TYPE/NAME</p>
</li>
<li>
<p>查看容器日志：kubectl logs TYPE/NAME [-c CONTAINER]</p>
</li>
<li>
<p>进入容器中：kubectl exec POD [-c CONTAINER] – COMMAND [args…]</p>
</li>
</ul>
<p>网络类问题，一般指无法在集群内部或者外部访问应用：</p>
<ul>
<li>
<p>Pod正常工作吗？</p>
</li>
<li>
<p>Service是否关联Pod？</p>
</li>
<li>
<p>Service指定target-port端口是否正确？</p>
</li>
<li>
<p>如果用名称访问，DNS是否正常工作？</p>
</li>
<li>
<p>kube-proxy正常工作吗？是否正常写iptables规则？</p>
</li>
<li>
<p>CNI网络插件是否正常工作？</p>
</li>
</ul>
<p><img src="/images/B85247E5D1CA45FDBB878F0943B22CC4clipboard.png" alt></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Logstash 过滤插件Grok GeoIp Date</title>
    <url>/2021/07/06/logstash%E8%BF%87%E6%BB%A4%E6%8F%92%E4%BB%B6grok_geoip_date/</url>
    <content><![CDATA[<p><img src="/images/DA7BE9A5EF94401F831E6B0343E245FCclipboard.png" alt></p>
<p>过滤插件：Grok</p>
<p>Grok插件：如果采集的日志格式是非结构化的，可以写正则表 达式提取，grok是正则表达式支持的实现。</p>
<p>常用字段：</p>
<p>• match 正则匹配模式</p>
<p>• patterns_dir 自定义正则模式文件</p>
<p>Logstash内置的正则匹配模式，在安装目录下可以看到，路径： vendor/bundle/jruby/2.5.0/gems/logstash-patterns-core-4.1.2/patterns/grok-patterns</p>
<p>正则匹配模式语法格式：%{SYNTAX:SEMANTIC}</p>
<p>• SYNTAX 模式名称，模式文件中的第一列</p>
<p>• SEMANTIC 匹配文件的字段名</p>
<p>例如： %{IP:client}</p>
<p>示例：正则匹配HTTP请求日志</p>
<p>修改logstash配置文件</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">   file &#123;</span><br><span class="line">       path =&gt; <span class="string">&quot;/var/log/test/*.log&quot;</span></span><br><span class="line">       exclude =&gt; <span class="string">&quot;1.log&quot;</span></span><br><span class="line">       start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;web&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;nginx&quot;</span></span><br><span class="line">       <span class="built_in">type</span> =&gt; <span class="string">&quot;access&quot;</span></span><br><span class="line">       add_field =&gt; &#123;</span><br><span class="line">          <span class="string">&quot;project&quot;</span> =&gt; <span class="string">&quot;microservice&quot;</span></span><br><span class="line">          <span class="string">&quot;app&quot;</span> =&gt; <span class="string">&quot;product&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">      match =&gt; &#123;</span><br><span class="line">       <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;%&#123;IP:client_ip&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        hosts =&gt;</span><br><span class="line">        [<span class="string">&quot;192.168.0.11:9200&quot;</span>]</span><br><span class="line">        index =&gt; <span class="string">&quot;test-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">#file &#123;</span></span><br><span class="line">    <span class="comment">#   path =&gt; &quot;/tmp/test.log&quot;</span></span><br><span class="line">   <span class="comment"># &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>模拟数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;192.168.1.12 GET /log.html 192822 0.053&quot;</span> &gt;&gt;/var/log/test/2.<span class="built_in">log</span> </span><br></pre></td></tr></table></figure>
<p>在kibana上验证：</p>
<p><img src="/images/34889E26266448B1BB14B74B5EEACE9CSnipaste_2021-02-09_20-34-18.png" alt></p>
<p>未使用grok正则格式化前的kibana展示页面</p>
<p><img src="/images/67285F004F10491DA2B2E9167267F8F6Snipaste_2021-02-09_20-39-41.png" alt></p>
<p>使用grok正则格式化后的kibana展示页面</p>
<p><img src="/images/EA4D1E27B4924CF395AA874389F07884Snipaste_2021-02-09_20-58-38.png" alt></p>
<p>从上面可以看到，使用grok正则格式化数据后，会增加了几个字段，这个字段就是我们使用正则添加的几个字段，它是从message字段中提取的值，然后将这些值赋予了新的字段。这样的好处是，我们可以基于某个字段去查询数据，比如我们可以分析持续时间大于1秒的日志等待。</p>
<p>如果内置匹配模式中没有你想要的，可以自定义正则模式。</p>
<p><img src="/images/FA4388E181E349A992FF856AF22EC028Snipaste_2021-02-09_22-17-18.png" alt></p>
<p><img src="/images/9C3679D1AC65448F9795ED046E8731ADSnipaste_2021-02-09_22-18-04.png" alt></p>
<p>创建自定义正则模式文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /opt/patterns</span><br><span class="line">NUM [0-9]&#123;4,8&#125;              <span class="comment">#匹配4到8位数字</span></span><br></pre></td></tr></table></figure>
<p>修改logstash配置文件</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">   file &#123;</span><br><span class="line">       path =&gt; <span class="string">&quot;/var/log/test/*.log&quot;</span></span><br><span class="line">       exclude =&gt; <span class="string">&quot;1.log&quot;</span></span><br><span class="line">       start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;web&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;nginx&quot;</span></span><br><span class="line">       <span class="built_in">type</span> =&gt; <span class="string">&quot;access&quot;</span></span><br><span class="line">       add_field =&gt; &#123;</span><br><span class="line">          <span class="string">&quot;project&quot;</span> =&gt; <span class="string">&quot;microservice&quot;</span></span><br><span class="line">          <span class="string">&quot;app&quot;</span> =&gt; <span class="string">&quot;product&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">      patterns_dir =&gt; <span class="string">&quot;/opt/patterns&quot;</span></span><br><span class="line">      match =&gt; &#123;</span><br><span class="line">       <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;%&#123;IP:client_ip&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125; %&#123;NUM:num&#125;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        hosts =&gt;</span><br><span class="line">        [<span class="string">&quot;192.168.0.11:9200&quot;</span>]</span><br><span class="line">        index =&gt; <span class="string">&quot;test-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">#file &#123;</span></span><br><span class="line">    <span class="comment">#   path =&gt; &quot;/tmp/test.log&quot;</span></span><br><span class="line">   <span class="comment"># &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>模拟数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /var/log/test/2.<span class="built_in">log</span> </span><br><span class="line">192.168.1.15 GET /task.html 15824 0.043 888999</span><br></pre></td></tr></table></figure>
<p>在kibana页面上查看</p>
<p><img src="/images/EEAE112017454CE3BD071057838087F6Snipaste_2021-02-09_22-35-16.png" alt></p>
<p>从上面可以看到，通过自定义正则的模式，我们可以制定出我们想要的正则模式。</p>
<p><img src="/images/7269F1D345914D119F97A102653ABC60clipboard.png" alt></p>
<p>我们可以使用其他的正则，不一定使用内置的正则，这样更灵活一点。</p>
<p>如果一个日志文件下有多个日志格式怎么办？例如项目新版本添加一个日志字段，需要兼容旧日志匹配 使用多模式匹配，写多个正则表达式，只要满足其中一条就能匹配成功。</p>
<p>创建自定义正则模式文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /opt/patterns</span><br><span class="line">NUM [0-9]&#123;4,8&#125;          <span class="comment">#匹配4到8位数字</span></span><br><span class="line">MUM [a-z]&#123;4,8&#125;          <span class="comment">#匹配4到8位小写字母</span></span><br><span class="line">TAG \w+                 <span class="comment">#匹配非特殊字符，a-z,A-Z,0-9,汉字，_</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">   file &#123;</span><br><span class="line">       path =&gt; <span class="string">&quot;/var/log/test/*.log&quot;</span></span><br><span class="line">       exclude =&gt; <span class="string">&quot;1.log&quot;</span></span><br><span class="line">       start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;web&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;nginx&quot;</span></span><br><span class="line">       <span class="built_in">type</span> =&gt; <span class="string">&quot;access&quot;</span></span><br><span class="line">       add_field =&gt; &#123;</span><br><span class="line">          <span class="string">&quot;project&quot;</span> =&gt; <span class="string">&quot;microservice&quot;</span></span><br><span class="line">          <span class="string">&quot;app&quot;</span> =&gt; <span class="string">&quot;product&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">      patterns_dir =&gt; <span class="string">&quot;/opt/patterns&quot;</span></span><br><span class="line">      match =&gt; [</span><br><span class="line">       <span class="string">&quot;message&quot;</span>, <span class="string">&quot;%&#123;IP:client_ip&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125; %&#123;NUM:num&#125;&quot;</span>,</span><br><span class="line">       <span class="string">&quot;message&quot;</span>, <span class="string">&quot;%&#123;IP:client_ip&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125; %&#123;MUM:mum&#125; %&#123;TAG:tag&#125;&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        hosts =&gt;</span><br><span class="line">        [<span class="string">&quot;192.168.0.11:9200&quot;</span>]</span><br><span class="line">        index =&gt; <span class="string">&quot;test-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">#file &#123;</span></span><br><span class="line">    <span class="comment">#   path =&gt; &quot;/tmp/test.log&quot;</span></span><br><span class="line">   <span class="comment"># &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>模拟数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /var/log/test/2.<span class="built_in">log</span> </span><br><span class="line"><span class="comment">#新日志（修改了一个字段且新增一个字段）</span></span><br><span class="line">192.168.1.15 GET /task.html 15824 0.043 ssssssss azhe123</span><br><span class="line"><span class="comment">#旧日志不变</span></span><br><span class="line">192.168.1.15 GET /task.html 15824 0.043 10010</span><br></pre></td></tr></table></figure>
<p>在kibana页面上查看</p>
<p><img src="/images/8C0D703B1F8F41A19FDEDD33226EDA86clipboard.png" alt></p>
<p>从上面可以看出，我们可以多模式匹配日志，新版本和旧版本日志共存。</p>
<p>过滤插件：GeoIP</p>
<p>GeoIP插件：根据Maxmind GeoLite2数据库中的数据添加有关IP地址位置信息。 使用多模式匹配，写多个正则表达式，只要满足其中一条就能匹配成功。</p>
<p>常用字段：</p>
<p>• source 指定要解析的IP字段，结果保存到geoip字段</p>
<p>• database GeoLite2数据库文件的路径</p>
<p>• fields 保留解析的指定字段</p>
<p>下载地址： <a href="https://www.maxmind.com/en/accounts/436070/geoip/downloads%EF%BC%88%E9%9C%80%E8%A6%81%E7%99%BB%E5%BD%95%EF%BC%89">https://www.maxmind.com/en/accounts/436070/geoip/downloads（需要登录）</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxf GeoLite2-City_20201103.tar.gz </span><br><span class="line"><span class="built_in">mv</span> GeoLite2-City_20201103/GeoLite2-City.mmdb  /opt/</span><br></pre></td></tr></table></figure>
<p>修改logstash配置文件</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123; </span><br><span class="line">   file &#123;</span><br><span class="line">       path =&gt; <span class="string">&quot;/var/log/test/*.log&quot;</span></span><br><span class="line">       exclude =&gt; <span class="string">&quot;1.log&quot;</span>       </span><br><span class="line">       start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;web&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;nginx&quot;</span></span><br><span class="line">       <span class="built_in">type</span> =&gt; <span class="string">&quot;access&quot;</span></span><br><span class="line">       add_field =&gt; &#123;</span><br><span class="line">          <span class="string">&quot;project&quot;</span> =&gt; <span class="string">&quot;microservice&quot;</span></span><br><span class="line">          <span class="string">&quot;app&quot;</span> =&gt; <span class="string">&quot;product&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">      patterns_dir =&gt; <span class="string">&quot;/opt/patterns&quot;</span></span><br><span class="line">      match =&gt; [</span><br><span class="line">       <span class="string">&quot;message&quot;</span>, <span class="string">&quot;%&#123;IP:client_ip&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125; %&#123;NUM:num&#125;&quot;</span>,</span><br><span class="line">       <span class="string">&quot;message&quot;</span>, <span class="string">&quot;%&#123;IP:client_ip&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125; %&#123;MUM:mum&#125; %&#123;TAG:tag&#125;&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    geoip &#123;</span><br><span class="line">        <span class="built_in">source</span> =&gt; <span class="string">&quot;client_ip&quot;</span></span><br><span class="line">        database =&gt; <span class="string">&quot;/opt/GeoLite2-City.mmdb&quot;</span></span><br><span class="line">        <span class="comment">#target 将解析的结果放到指定字段，如果不指定，默认在 事件的顶层</span></span><br><span class="line">        <span class="comment">#target =&gt; &quot;geoip&quot;</span></span><br><span class="line">        <span class="comment">#fields 保留解析的指定字段</span></span><br><span class="line">        <span class="comment">#fields =&gt; [&quot;city_name&quot;,&quot;country_code2&quot;,&quot;country_name&quot;,&quot;region_name&quot;]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        hosts =&gt;</span><br><span class="line">        [<span class="string">&quot;192.168.0.11:9200&quot;</span>]</span><br><span class="line">        index =&gt; <span class="string">&quot;test-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">#file &#123;</span></span><br><span class="line">    <span class="comment">#   path =&gt; &quot;/tmp/test.log&quot;</span></span><br><span class="line">   <span class="comment"># &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>在kibana页面上查看</p>
<p><img src="/images/50DE8860A8F9412FB0DB03630631D994clipboard.png" alt></p>
<p>过滤插件：Date</p>
<p>Date插件：用于从指定字段解析日期，一般用于将日志中时间字段 替换Logstash添加的事件时间。 常用字段：</p>
<p>• locale 语言环境</p>
<p>• match 指定匹配时间的字段</p>
<p>• target 将匹配的时间存储指定字段，默认@timestamp</p>
<p>示例：将日志中时间字段替换Logstash事件时间</p>
<p>在kibana页面上验证：</p>
<p><img src="/images/5E9A44A6813148B588271DFB47676980clipboard.png" alt></p>
<p>修改logstash配置文件</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">   file &#123;</span><br><span class="line">       path =&gt; <span class="string">&quot;/var/log/test/*.log&quot;</span></span><br><span class="line">       exclude =&gt; <span class="string">&quot;1.log&quot;</span></span><br><span class="line">       start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;web&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;nginx&quot;</span></span><br><span class="line">       <span class="built_in">type</span> =&gt; <span class="string">&quot;access&quot;</span></span><br><span class="line">       add_field =&gt; &#123;</span><br><span class="line">          <span class="string">&quot;project&quot;</span> =&gt; <span class="string">&quot;microservice&quot;</span></span><br><span class="line">          <span class="string">&quot;app&quot;</span> =&gt; <span class="string">&quot;product&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">      match =&gt; &#123;</span><br><span class="line">       <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;%&#123;DATA:datetime&#125; %&#123;IP:client_ip&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">date</span> &#123;</span><br><span class="line">        locale =&gt; <span class="string">&quot;en&quot;</span></span><br><span class="line">        match =&gt; [<span class="string">&quot;datetime&quot;</span>,<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss&quot;</span>]</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        hosts =&gt;</span><br><span class="line">        [<span class="string">&quot;192.168.0.11:9200&quot;</span>]</span><br><span class="line">        index =&gt; <span class="string">&quot;test-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>在kibana页面上查看</p>
<p><img src="/images/B3A12BD9920145619A06ED0D062FEDC0clipboard.png" alt></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>pipeline发布java网站项目</title>
    <url>/2021/05/20/pipeline%E5%8F%91%E5%B8%83java%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>一.安装pipeline,Git plugin,Git Parameter Plug-In,Pulish Over SSH等插件并生成插件语法。</p>
<p>系统管理—&gt;系统配置—&gt;Publish over SSH配置</p>
<p>#此配置是使用ssh生成一对密钥，将id_rsa私钥放置于此，将id_rsa.pub拷贝到你要部署的远程web服务器上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用root账户生成一对密钥</span></span><br><span class="line">ssh-keygen</span><br><span class="line">ssh-copy root@x.x.x.x  (拷贝到要部署的web服务器上实现免密登录)</span><br></pre></td></tr></table></figure>
<p><img src="/images/7D79BFBF17CC4FCFA79930FBA95A8AD0clipboard.png" alt></p>
<p><img src="/images/687BC592A61A4DE88CA097951971C855clipboard.png" alt></p>
<p>新建项目(流水线)----&gt;配置----&gt;最下面流水线语法</p>
<p>1.Git Parameter Plug-In插件</p>
<p><img src="/images/F80B490C494348AA96A5491C1968175Dclipboard.png" alt></p>
<p><img src="/images/9F31A12E0C8A4679985DF356AD1347F9clipboard.png" alt></p>
<p><img src="/images/8EDEED0C56034CEBA71F581E2F1133E1clipboard.png" alt></p>
<p>2.Git plugin插件</p>
<p><img src="/images/D51B54D424D34AFC89603ABE0D489795clipboard.png" alt></p>
<p><img src="/images/286930CAA9734BB4A567FDD87DC39092clipboard.png" alt></p>
<p><img src="/images/68A53AFCF8094E6E925A7E8F24EF2450clipboard.png" alt></p>
<p>3.triggers触发器</p>
<p><img src="/images/7AE2B06E68BE4028897BD4B3D184A980clipboard.png" alt></p>
<p><img src="/images/DA693E875B4A4931A2306059DEE22A2Dclipboard.png" alt></p>
<p><img src="/images/C4CC023F9C1F4F58AE24C2C56E5D1A89clipboard.png" alt></p>
<p>4.Pulish Over SSH插件</p>
<p><img src="/images/286D2AA784644F2B8CB332781AE88186clipboard.png" alt></p>
<p><img src="/images/20EBA0119EFC415AB5785A8139D7D7EAclipboard.png" alt></p>
<p><img src="/images/109D47D2DE5341A48BA9261D5C10F8EFclipboard.png" alt></p>
<p>二.配置流水线脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">    	label  <span class="string">&quot;task1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">  	gitParameter branch: <span class="string">&#x27;&#x27;</span>, branchFilter: <span class="string">&#x27;.*&#x27;</span>, defaultValue: <span class="string">&#x27;master&#x27;</span>, description: <span class="string">&#x27;请选择你要发布的分支&#x27;</span>, name: <span class="string">&#x27;branch&#x27;</span>, quickFilterEnabled: <span class="literal">false</span>, selectedValue: <span class="string">&#x27;NONE&#x27;</span>, sortMode: <span class="string">&#x27;NONE&#x27;</span>, tagFilter: <span class="string">&#x27;*&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;PT_BRANCH&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    environment &#123;</span><br><span class="line"> 	 git_address = <span class="string">&quot;http://gitlab.ctnrs.com/my-group/ansible.git&quot;</span></span><br><span class="line"> 	 git_password = <span class="string">&quot;4cfc8d8f-489b-4c29-9f10-4a1b265e0cb3&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	triggers &#123;</span><br><span class="line">  	pollSCM <span class="string">&#x27;*/1 * * * * &#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉去取代码&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&quot;<span class="variable">$&#123;params.branch&#125;</span>&quot;</span>]], doGenerateSubmoduleConfigurations: <span class="literal">false</span>, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$git_password</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$git_address</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;编译构建&#x27;</span>)&#123;</span><br><span class="line">        	steps &#123;</span><br><span class="line">        		sh <span class="string">&quot;mvn clean package -Dmaven.test.skip=true&quot;</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;推送部署包&#x27;</span>)&#123;</span><br><span class="line">        	steps &#123;</span><br><span class="line">        		<span class="built_in">echo</span> <span class="string">&#x27;推送部署包&#x27;</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;部署验证测试&#x27;</span>) &#123;</span><br><span class="line">        	steps &#123;</span><br><span class="line">        		sshPublisher(publishers: [sshPublisherDesc(configName: <span class="string">&#x27;web2&#x27;</span>, transfers: [sshTransfer(cleanRemote: <span class="literal">false</span>, excludes: <span class="string">&#x27;&#x27;</span>, execCommand: <span class="string">&#x27;&#x27;</span><span class="string">&#x27;	tomcat=/usr/local/tomcat</span></span><br><span class="line"><span class="string">				cd $tomcat/webapps</span></span><br><span class="line"><span class="string">				#备份远程web服务上的数据到备份目录下</span></span><br><span class="line"><span class="string">				mv ROOT.war  /data/backup/$(date +%F_%T)_ROOT.war </span></span><br><span class="line"><span class="string">				#部署新的war包并启动tomcat</span></span><br><span class="line"><span class="string">				mv /tmp/ly-simple-tomcat-0.0.1-SNAPSHOT.war $tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">				pid=$(ps -ef |grep tomcat |egrep -v &quot;grep|$$&quot; |awk \&#x27;</span>&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;\&#x27;)</span><br><span class="line">				[ -n <span class="variable">$pid</span> ] &amp;&amp; <span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">				/bin/bash /usr/local/tomcat/bin/startup.sh  <span class="string">&#x27;&#x27;</span><span class="string">&#x27;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#x27;</span>[, ]+<span class="string">&#x27;, remoteDirectory: &#x27;</span>tmp<span class="string">&#x27;, remoteDirectorySDF: false, removePrefix: &#x27;</span>target<span class="string">&#x27;, sourceFiles: &#x27;</span>target/*.war<span class="string">&#x27;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])     	</span></span><br><span class="line"><span class="string">			&#125;	</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>三.验证访问</p>
<p>访问tomcat web服务器</p>
<p>192.168.0.5:8080</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改页面代码</span></span><br><span class="line">vim java-demo/src/main/resources/templates/index.ftl</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;demo&quot;</span></span><br><span class="line">git push origin master </span><br><span class="line"></span><br><span class="line">提交代码等待jenkins触发构建，验证查看页面是否变化</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Logstash部署，输入插件</title>
    <url>/2021/07/05/logstash%E9%83%A8%E7%BD%B2%E8%BE%93%E5%85%A5%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>Logstash 介绍</p>
<p>Logstash能够将采集日志、格式化、过滤，最后将数据推送到Elasticsearch存储。</p>
<p><img src="/images/7EA4E1558E434F1D9D29E88D3D58C68Eclipboard.png" alt></p>
<p>Input：输入，输入数据可以是Stdin、File、TCP、Redis、Syslog等。</p>
<p>Filter：过滤，将日志格式化。有丰富的过滤插件：Grok正则捕获、Date时间处理、Json编解码、Mutate数据修改等。</p>
<p>Output：输出，输出目标可以是Stdout、File、TCP、Redis、ES等</p>
<p>Logstash 部署</p>
<p>二进制方式部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk -y</span><br><span class="line">tar zxvf logstash-7.9.3.tar.gz</span><br><span class="line"><span class="built_in">mv</span> logstash-7.9.3 /opt/elk/logstash</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改配置文件：</p>
<p>vi /opt/elk/logstash/config/logstash.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline: <span class="comment"># 管道配置</span></span><br><span class="line"> batch:</span><br><span class="line">  size: 125</span><br><span class="line">  delay: 5</span><br><span class="line">path.config: /opt/elk/logstash/conf.d <span class="comment"># conf.d目录自己创建</span></span><br><span class="line"><span class="comment"># 定期检查配置是否修改，并重新加载管道。也可以使用SIGHUP信号手动触发</span></span><br><span class="line"><span class="comment"># # config.reload.automatic: false</span></span><br><span class="line"><span class="comment"># # config.reload.interval: 3s</span></span><br><span class="line"><span class="comment"># # http.enabled: true</span></span><br><span class="line">http.host: 0.0.0.0</span><br><span class="line">http.port: 9600-9700</span><br><span class="line">log.level: info</span><br><span class="line">path.logs: /opt/elk/logstash/logs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Logstash 基本使用</p>
<p>示例：从标准输入获取日志并打印到标准输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意先注视掉配置文件中path.config这个参数，这个是指定目录下的文件(file)输出的。</span></span><br><span class="line">path.config: /opt/elk/logstash/conf.d</span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台输出</span></span><br><span class="line">/opt/elk/logstash/bin/logstash -e <span class="string">&#x27;input&#123;stdin&#123;&#125;&#125;output&#123;stdout&#123;codec=&gt;rubydebug&#125;&#125;&#x27;</span></span><br><span class="line">hello world </span><br><span class="line">&#123; </span><br><span class="line">    <span class="string">&quot;@version&quot;</span> =&gt; <span class="string">&quot;1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;hello world &quot;</span>, </span><br><span class="line">    <span class="string">&quot;@timestamp&quot;</span> =&gt; 2020-11-05T09:23:44.025Z, </span><br><span class="line">    <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&quot;localhost&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认给日志加的三个字段：</p>
<p>• “@timestamp” 标记事件发生的时间点</p>
<p>• “host” 标记事件发生的主机</p>
<p>• “type” 标记事件的唯一类型</p>
<p>命令行参数：</p>
<p>• -e 字符串形式写配置</p>
<p>• -f 指定配置文件</p>
<p>• -t 测试配置文件语法</p>
<p>输入插件（Input）</p>
<p>输入阶段：从哪里获取日志 常用插件：</p>
<p>• Stdin（一般用于调试）</p>
<p>• File</p>
<p>• Redis</p>
<p>• Beats（例如filebeat）</p>
<p>示例：读取日志文件并输出到文件</p>
<p>创建目录及文件（用于测试）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输入文件</span></span><br><span class="line"><span class="built_in">mkdir</span> /var/log/test</span><br><span class="line"><span class="built_in">touch</span> /var/log/test/1.<span class="built_in">log</span></span><br><span class="line"><span class="built_in">touch</span> /var/log/test/2.<span class="built_in">log</span></span><br><span class="line"><span class="comment">#输出文件</span></span><br><span class="line"><span class="built_in">touch</span> /tmp/test.log</span><br></pre></td></tr></table></figure>
<p>输入插件：File</p>
<p>File插件：用于读取指定日志文件 常用字段：</p>
<p>• path 日志文件路径，可以使用通配符</p>
<p>• exclude 排除采集的日志文件</p>
<p>• start_position 指定日志文件什么位置开始读，默认从结尾 开始，指定beginning表示从头开始读</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">   file &#123;</span><br><span class="line">       path =&gt; <span class="string">&quot;/var/log/test/*.log&quot;</span></span><br><span class="line">       exclude =&gt; <span class="string">&quot;1.log&quot;</span>	</span><br><span class="line">       start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">       path =&gt; <span class="string">&quot;/tmp/test.log&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在启动之前可以先测试以下配置文件是否正确</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试配置文件</span></span><br><span class="line">/opt/elk/logstash/bin/logstash -t -f /opt/elk/logstash/conf.d/test.conf </span><br><span class="line"><span class="comment">#启动logstash</span></span><br><span class="line">/opt/elk/logstash/bin/logstash -f /opt/elk/logstash/conf.d/test.conf </span><br></pre></td></tr></table></figure>
<p>这里我们采用配置为系统服务启动：</p>
<p>vim /usr/lib/systemd/system/logstash.service</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=logstash</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/opt/elk/logstash/bin/logstash -f /opt/elk/logstash/conf.d/*.conf</span><br><span class="line">ExecReload=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start logstash</span><br><span class="line">systemctl <span class="built_in">enable</span> logstash</span><br></pre></td></tr></table></figure>
<p>测试验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1111111111111 &gt;&gt; /var/log/test/1.<span class="built_in">log</span>  <span class="comment">#发现并没有输出到/tmp/test.log文件中</span></span><br><span class="line"><span class="built_in">echo</span> 2222222222222 &gt;&gt; /var/log/test/2.<span class="built_in">log</span>  <span class="comment">#发现输出到/tmp/test.log文件中</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/4BE50D06008D4E33A981915E488D3CF1clipboard.png" alt></p>
<p>示例：配置日志来源</p>
<p>输入插件：通用配置字段</p>
<p>输入插件都支持的字段：</p>
<p>• add_field 添加一个字段到一个事件，放到事件顶部，一般用于标记日志来源。例如属于哪个项目，哪个应用</p>
<p>• tags 添加任意数量的标签，用于标记日志的其他属性，例如表明访问日志还是错误日志</p>
<p>• type 为所有输入添加一个字段，例如表明日志类型</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">   file &#123;</span><br><span class="line">       path =&gt; <span class="string">&quot;/var/log/test/*.log&quot;</span></span><br><span class="line">       exclude =&gt; <span class="string">&quot;1.log&quot;</span></span><br><span class="line">       start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;web&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;nginx&quot;</span></span><br><span class="line">       <span class="built_in">type</span> =&gt; <span class="string">&quot;access&quot;</span></span><br><span class="line">       add_field =&gt; &#123;</span><br><span class="line">          <span class="string">&quot;project&quot;</span> =&gt; <span class="string">&quot;microservice&quot;</span></span><br><span class="line">          <span class="string">&quot;app&quot;</span> =&gt; <span class="string">&quot;product&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">       path =&gt; <span class="string">&quot;/tmp/test.log&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>测试验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 9999999999999999 &gt;&gt; /var/log/test/2.<span class="built_in">log</span> </span><br></pre></td></tr></table></figure>
<p><img src="/images/E9FDBCF827164A30A64ACCDC1EBDF280clipboard.png" alt></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>Logstash 过滤插件 json kv</title>
    <url>/2021/07/03/logstash%E8%BF%87%E6%BB%A4%E6%8F%92%E4%BB%B6json_kv/</url>
    <content><![CDATA[<p>过滤插件（Filter）</p>
<p>过滤阶段：将日志格式化处理</p>
<p>常用插件：</p>
<p>• json     • kv    • grok    • geoip     • date</p>
<p>过滤插件：通用配置字段</p>
<p>过滤插件都支持的字段：</p>
<p>• add_field 如果过滤成功，添加一个字段到这个事件</p>
<p>• add_tags 如果过滤成功，添加任意数量的标签到这个事件</p>
<p>• remove_field 如果过滤成功，从这个事件移除任意字段</p>
<p>• remove_tag 如果过滤成功，从这个事件移除任意标签</p>
<p>过滤插件：JSON</p>
<p>JSON插件：接收一个json数据，将其展开为Logstash事件中的 数据结构，放到事件顶层。</p>
<p>常用字段：</p>
<p>• source 指定要解析的字段，一般是原始消息message字段</p>
<p>• target 将解析的结果放到指定字段，如果不指定，默认在 事件的顶层</p>
<p>示例：解析HTTP请求</p>
<p>修改logstash配置文件</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">   file &#123;</span><br><span class="line">       path =&gt; <span class="string">&quot;/var/log/test/*.log&quot;</span></span><br><span class="line">       exclude =&gt; <span class="string">&quot;1.log&quot;</span></span><br><span class="line">       start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;web&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;nginx&quot;</span></span><br><span class="line">       <span class="built_in">type</span> =&gt; <span class="string">&quot;access&quot;</span></span><br><span class="line">       add_field =&gt; &#123;</span><br><span class="line">          <span class="string">&quot;project&quot;</span> =&gt; <span class="string">&quot;microservice&quot;</span></span><br><span class="line">          <span class="string">&quot;app&quot;</span> =&gt; <span class="string">&quot;product&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    json &#123;</span><br><span class="line">      <span class="built_in">source</span> =&gt; <span class="string">&quot;message&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        hosts =&gt;</span><br><span class="line">        [<span class="string">&quot;192.168.0.11:9200&quot;</span>]</span><br><span class="line">        index =&gt; <span class="string">&quot;test-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">#file &#123;</span></span><br><span class="line">    <span class="comment">#   path =&gt; &quot;/tmp/test.log&quot;</span></span><br><span class="line">   <span class="comment"># &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>模拟数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /var/log/test/2.<span class="built_in">log</span> </span><br><span class="line"><span class="comment">#json格式，如果不是json格式会解析失败</span></span><br><span class="line">&#123;<span class="string">&quot;remote_addr&quot;</span>: <span class="string">&quot;192.168.1.10&quot;</span>,<span class="string">&quot;url&quot;</span>:<span class="string">&quot;/index&quot;</span>,<span class="string">&quot;status&quot;</span>:<span class="string">&quot;200&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>访问kibana：</p>
<p><a href="http://192.168.0.12:5601/">http://192.168.0.12:5601/</a></p>
<p><img src="/images/84882A1D7B454D81BC53510891F8CFC1clipboard.png" alt></p>
<p>这里只会展示以test-开头所有的索引，因为这里的索引是按照天进行存储的，这样就可以匹配所有的天，这样好处是清理索引历史的日志，就可以针对天删除索引了。也就是删除数据库一样。</p>
<p><img src="/images/A3FE13C6F0CA4D0994DBA046F6C5D130clipboard.png" alt></p>
<p>可以看到kibana可以根据这些字段查询出我们所需要的数据</p>
<p>可以看到这些字段很重要，这些字段可以标识出日志当中有哪些关键字段，从而根据这些字段查询我们需要的数据。可以看到通过json过滤模块格式化处理解析为顶层的字段</p>
<p><img src="/images/DA9C81D0F97B413DB38571AC4A6FB25Fclipboard.png" alt></p>
<p>参考连接：</p>
<p><a href="https://blog.csdn.net/qq_34556414/article/details/111251732">https://blog.csdn.net/qq_34556414/article/details/111251732</a></p>
<p>过滤插件：KV</p>
<p>KV插件：接收一个键值数据，按照指定分隔符解析为Logstash 事件中的数据结构，放到事件顶层。 常用字段：</p>
<p>• field_split 指定键值分隔符，默认空</p>
<p>示例：解析URL中参数</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">   file &#123;</span><br><span class="line">       path =&gt; <span class="string">&quot;/var/log/test/*.log&quot;</span></span><br><span class="line">       exclude =&gt; <span class="string">&quot;1.log&quot;</span></span><br><span class="line">       start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;web&quot;</span></span><br><span class="line">       tags =&gt; <span class="string">&quot;nginx&quot;</span></span><br><span class="line">       <span class="built_in">type</span> =&gt; <span class="string">&quot;access&quot;</span></span><br><span class="line">       add_field =&gt; &#123;</span><br><span class="line">          <span class="string">&quot;project&quot;</span> =&gt; <span class="string">&quot;microservice&quot;</span></span><br><span class="line">          <span class="string">&quot;app&quot;</span> =&gt; <span class="string">&quot;product&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    kv &#123;</span><br><span class="line">      field_split =&gt; <span class="string">&quot;&amp;?&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        hosts =&gt;</span><br><span class="line">        [<span class="string">&quot;192.168.0.11:9200&quot;</span>]</span><br><span class="line">        index =&gt; <span class="string">&quot;test-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">#file &#123;</span></span><br><span class="line">    <span class="comment">#   path =&gt; &quot;/tmp/test.log&quot;</span></span><br><span class="line">   <span class="comment"># &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>模拟数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /var/log/test/2.<span class="built_in">log</span> </span><br><span class="line"><span class="comment">#键值对</span></span><br><span class="line">hello?<span class="built_in">id</span>=1&amp;name=azhe&amp;age=23</span><br></pre></td></tr></table></figure>
<p>访问kibana：</p>
<p><a href="http://192.168.0.12:5601/">http://192.168.0.12:5601/</a></p>
<p><img src="/images/474AEC34837843789A60801AF139FCC2clipboard.png" alt></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>pipeline集合ansible发布多台web服务器</title>
    <url>/2021/05/21/pipeline%E9%9B%86%E5%90%88ansible%E5%8F%91%E5%B8%83%E5%A4%9A%E5%8F%B0web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>一.安装ansible插件并生成对应插件的语法</p>
<p>新建项目(流水线)----&gt;配置----&gt;最下面流水线语法</p>
<p>1.生成ansible远程连接要部署web服务器的用户名和密码认证语法</p>
<p><img src="/images/9580E13623BF4DD6AC1362FBF1065C44clipboard.png" alt></p>
<p><img src="/images/263C500EB9314380915B6475581CFBBDclipboard.png" alt></p>
<p><img src="/images/358259C19042407F8C4CA37075117DE3clipboard.png" alt></p>
<p>2.生成选项参数语法</p>
<p><img src="/images/EDE7E78894354847B21658B28BFF739Dclipboard.png" alt></p>
<p><img src="/images/4A8E82BACAB24826A6314AAA8092243Eclipboard.png" alt></p>
<p><img src="/images/06EBE0B55ACB4510B259D9B4E81632F0clipboard.png" alt></p>
<p>3.生成连接Jenkins服务器用户名和密码语法</p>
<p><img src="/images/E27F1850F9FA45FCBA795B36B606BBF0clipboard.png" alt></p>
<p><img src="/images/ECD7F6F8A15B4E27975C3C8C9D3DA400clipboard.png" alt></p>
<p><img src="/images/7516A963C1DA4139B78FBEC4D27C979Bclipboard.png" alt></p>
<p>二.配置流水线脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        label <span class="string">&quot;task1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    environment &#123;</span><br><span class="line">        git_address = <span class="string">&quot;http://gitlab.ctnrs.com/my-group/ansible.git&quot;</span></span><br><span class="line">        git_password = <span class="string">&quot;4cfc8d8f-489b-4c29-9f10-4a1b265e0cb3&quot;</span></span><br><span class="line">        ansible_ssh_auth = <span class="string">&quot;a14ad8a7-5ad6-43de-bac6-221000c8015c&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">        gitParameter branch: <span class="string">&#x27;&#x27;</span>, branchFilter: <span class="string">&#x27;.*&#x27;</span>, defaultValue: <span class="string">&#x27;master&#x27;</span>, description: <span class="string">&#x27;请选择你要发布的分支&#x27;</span>, name: <span class="string">&#x27;branch&#x27;</span>, quickFilterEnabled: <span class="literal">false</span>, selectedValue: <span class="string">&#x27;NONE&#x27;</span>, sortMode: <span class="string">&#x27;NONE&#x27;</span>, tagFilter: <span class="string">&#x27;*&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;PT_BRANCH&#x27;</span></span><br><span class="line">        choice choices: [<span class="string">&#x27;webservers1&#x27;</span>, <span class="string">&#x27;webservers2&#x27;</span>, <span class="string">&#x27;webservers3&#x27;</span>], description: <span class="string">&#x27;&#x27;</span><span class="string">&#x27;灰度发布策略，分批次部署</span></span><br><span class="line"><span class="string">        webservers1</span></span><br><span class="line"><span class="string">        192.168.0.2</span></span><br><span class="line"><span class="string">        192.168.0.5</span></span><br><span class="line"><span class="string">        webservers2</span></span><br><span class="line"><span class="string">        192.168.0.2</span></span><br><span class="line"><span class="string">        webservers3</span></span><br><span class="line"><span class="string">        192.168.0.5&#x27;</span><span class="string">&#x27;&#x27;</span>, name: <span class="string">&#x27;ENV&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">   triggers &#123;</span><br><span class="line">    pollSCM <span class="string">&#x27;*/1 * * * * &#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&quot;<span class="variable">$&#123;params.branch&#125;</span>&quot;</span>]], doGenerateSubmoduleConfigurations: <span class="literal">false</span>, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$git_password</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$git_address</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;编译构建&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&quot;/usr/local/maven/bin/mvn clean package -Dmaven.test.skip=true&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;拷贝构建文件到远程主机并部署&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                // 读取连接Jenkins服务器用户名和密码</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&#x27;911fbe26-312f-4959-9fd1-a9799cafe4c5&#x27;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                // ===========================================</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">###################### 主机清单文件 ############################</span></span><br><span class="line"><span class="string">cat &gt; /opt/jenkins/.hosts &lt;&lt; EOF</span></span><br><span class="line"><span class="string">[webservers1]</span></span><br><span class="line"><span class="string">192.168.0.2</span></span><br><span class="line"><span class="string">192.168.0.5</span></span><br><span class="line"><span class="string">[webservers2]</span></span><br><span class="line"><span class="string">192.168.0.2</span></span><br><span class="line"><span class="string">[webservers3]</span></span><br><span class="line"><span class="string">192.168.0.5</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">###################### Playbook文件 ############################</span></span><br><span class="line"><span class="string">cat &gt; /opt/jenkins/.playbook.yaml &lt;&lt; &quot;</span>EOF<span class="string">&quot;</span></span><br><span class="line"><span class="string">- hosts: <span class="variable">$ENV</span>   # Jenkins参数化变量 </span></span><br><span class="line"><span class="string">  gather_facts: no</span></span><br><span class="line"><span class="string">  vars:    # 定义playbook变量，下面&#123;&#123;&#125;&#125;引用这里的变量</span></span><br><span class="line"><span class="string">    workspace: <span class="variable">$WORKSPACE</span>   # WORKSPACE和BUILD_NUMBER引用Jenkins变量</span></span><br><span class="line"><span class="string">    build_number: <span class="variable">$BUILD_NUMBER</span></span></span><br><span class="line"><span class="string">    tomcat_dir: &quot;</span>/usr/local/tomcat<span class="string">&quot;  # 自定义变量</span></span><br><span class="line"><span class="string">    backup_dir: &quot;</span>/data/backup<span class="string">&quot;</span></span><br><span class="line"><span class="string">    backup_filename: &quot;</span>demo-ROOT-\$(<span class="built_in">date</span> +%F)-&#123;&#123; build_number &#125;&#125;.war<span class="string">&quot;  # 格式：项目名-文件名-日期-构建编号</span></span><br><span class="line"><span class="string">  tasks:</span></span><br><span class="line"><span class="string">  - name: 推送部署包到远程服务器</span></span><br><span class="line"><span class="string">    copy: src=&quot;</span>&#123;&#123; item &#125;&#125;<span class="string">&quot; dest=&#123;&#123; tomcat_dir &#125;&#125;/webapps</span></span><br><span class="line"><span class="string">    with_fileglob:</span></span><br><span class="line"><span class="string">      - &quot;</span>&#123;&#123; workspace &#125;&#125;/target/*.war<span class="string">&quot;</span></span><br><span class="line"><span class="string">  - name: 部署新程序并重启Tomcat</span></span><br><span class="line"><span class="string">    # 脚本中\$必须转义，否则会认为是Jenkins变量</span></span><br><span class="line"><span class="string">    shell: |   </span></span><br><span class="line"><span class="string">       cd &#123;&#123; tomcat_dir &#125;&#125;/webapps</span></span><br><span class="line"><span class="string">       mv ROOT.war &#123;&#123; backup_dir &#125;&#125;/&#123;&#123; backup_filename &#125;&#125;</span></span><br><span class="line"><span class="string">       mv *.war ROOT.war</span></span><br><span class="line"><span class="string">       pid=\$(ps -ef |grep &#123;&#123; tomcat_dir &#125;&#125; |egrep -v &#x27;grep&#x27; |awk &#x27;&#123;print \$2&#125;&#x27;)</span></span><br><span class="line"><span class="string">       [ -n &quot;</span>\<span class="variable">$pid</span><span class="string">&quot; ] &amp;&amp; kill -9 \$pid</span></span><br><span class="line"><span class="string">       export JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">       nohup &#123;&#123; tomcat_dir &#125;&#125;/bin/startup.sh</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                // ===========================================</span><br><span class="line">                &#125;</span><br><span class="line">            	ansiblePlaybook( </span><br><span class="line">                playbook: <span class="string">&#x27;/opt/jenkins/.playbook.yaml&#x27;</span>,</span><br><span class="line">                inventory: <span class="string">&#x27;/opt/jenkins/.hosts&#x27;</span>, </span><br><span class="line">                credentialsId: <span class="string">&quot;<span class="variable">$&#123;ansible_ssh_auth&#125;</span>&quot;</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>三.验证访问</p>
<p>1.发布webservers1组服务器部署</p>
<p>访问tomcat web服务器1</p>
<p>192.168.0.2:8080</p>
<p>访问tomcat web服务器2</p>
<p>192.168.0.5:8080</p>
<p>2.发布webservers2组服务器部署</p>
<p>#修改页面代码</p>
<p>vim java-demo/src/main/resources/templates/index.ftl</p>
<p>git add .</p>
<p>git commit -m “demo”</p>
<p>git push origin master</p>
<p>访问tomcat web服务器1，查看tomcat web服务器2是否变化</p>
<p>192.168.0.2:8080</p>
<p>3.发布webservers3组服务器部署</p>
<p>访问tomcat web服务器</p>
<p>#修改页面代码</p>
<p>vim java-demo/src/main/resources/templates/index.ftl</p>
<p>git add .</p>
<p>git commit -m “demo2”</p>
<p>git push origin master</p>
<p>访问tomcat web2服务器，查看tomcat web服务器1是否变化</p>
<p>192.168.0.5:8080</p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Logstash 输出插件</title>
    <url>/2021/07/04/lostash%E8%BE%93%E5%87%BA%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>输出插件（Output）</p>
<p>输出阶段：将处理完成的日志推送到远程数据库存储</p>
<p>常用插件：</p>
<p>• file</p>
<p>• Elasticsearch</p>
<p>输入插件：Elasticsearch</p>
<p>Elasticsearch插件：将数据推送到ES存储。</p>
<p>常用字段：</p>
<p>• hosts 指定ES主机地址</p>
<p>• index 指定写入的ES索引名称，一般按日期ec 划分</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        hosts =&gt;</span><br><span class="line">        [<span class="string">&quot;192.168.0.11:9200&quot;</span>,<span class="string">&quot;192.168.0.12:9200&quot;</span>,<span class="string">&quot;192.168.0.13:9200&quot;</span>]</span><br><span class="line">        index =&gt; <span class="string">&quot;product-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>条件判断</p>
<p>操作符：</p>
<p> 比较操作符：== ，!= ， &lt; ， &gt; ， &lt;= ，&gt;=</p>
<p> 正则匹配操作符：=~(匹配正则) ，!~(不匹配正则)</p>
<p> 成员操作符：in(包含) ， not in(不包含)</p>
<p> 逻辑操作符：and(与)，or(或), nand(非与) ， xor(非或)</p>
<p> 一元运算符：!(取反) ，()(复合表达式) ，!()(对复合表达式结果取反)</p>
<p>条件判断语句：</p>
<p>if &lt;表达式&gt; {</p>
<pre><code> &lt;语句&gt; 
</code></pre>
<p>} else if &lt;表达式&gt; {</p>
<pre><code>&lt;语句&gt; 
</code></pre>
<p>} else {</p>
<p>&lt;语句&gt;</p>
<p>}</p>
<p>典型的应用场景：</p>
<p> 根据日志来源（例如项目名称，应用名）字段写入不同索引名称</p>
<p> 根据日志来源（例如测试环境，生产环境）字段写入不同索引名称</p>
<p>mutate过滤器能够帮助你修改指定字段的内容。</p>
<p>@metadata 是logstash内部的一个元数据，这个数据不会写到es里面，一般用于临时存储一些数据，</p>
<p>比如是我们需要把数据写入到不同的索引中，同时我们也不想在es里多保存一个字段，一般用于filter中。</p>
<p>现在要做的就是将采集日志的来源放在不同的索引里面。如果不这样配置那么在logstash采集的日志都会输出到一个索引里面，这样是不利于对后期的管理的。因为索引相当于数据库，按天命名方便清理。把同类的日志放在同一个索引里面。</p>
<p>修改logstash配置文件</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">  path =&gt; <span class="string">&quot;/var/log/test/test.log&quot;</span></span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;log_type&quot;</span> =&gt; <span class="string">&quot;test&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  file &#123;</span><br><span class="line">  path =&gt; <span class="string">&quot;/var/log/test/prod.log&quot;</span></span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;log_type&quot;</span> =&gt; <span class="string">&quot;prod&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  <span class="keyword">if</span> [log_type] <span class="keyword">in</span> [<span class="string">&quot;test&quot;</span>,<span class="string">&quot;dev&quot;</span>] &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;test-%&#123;+YYYY.MM&#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> [log_type] == <span class="string">&quot;prod&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;prod-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;unknown-%&#123;+YYYY&#125;&quot;</span></span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">  hosts =&gt; <span class="string">&quot;192.168.0.11:9200&quot;</span></span><br><span class="line">  index =&gt; <span class="string">&quot;%&#123;[@metadata][target_index]&#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>模拟写入日志数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is test&quot;</span> &gt; /var/log/test/test.log </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is prod&quot;</span> &gt; /var/log/test/prod.log </span><br></pre></td></tr></table></figure>
<p>在kibana页面上查看</p>
<p><img src="/images/32DB334AA2884069A4E0AF88818D6BA8clipboard.png" alt></p>
<p><img src="/images/87DAE279C5284567883A1937CD3A29B2clipboard.png" alt></p>
<p><img src="/images/9965F3504E644E2C8931E0100D51A1CBclipboard.png" alt></p>
<p><img src="/images/35F458AEE9BA4AA697F76A371AFE2DC1clipboard.png" alt></p>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/qq_34624315/article/details/83013531">https://blog.csdn.net/qq_34624315/article/details/83013531</a></p>
<p><a href="https://blog.csdn.net/qq_34556414/article/details/111955410">https://blog.csdn.net/qq_34556414/article/details/111955410</a></p>
<p><a href="https://blog.csdn.net/wmg_fly/article/details/112171804">https://blog.csdn.net/wmg_fly/article/details/112171804</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus+Grafana监控Kubernetes</title>
    <url>/2023/05/10/prometheus+grafana%E7%9B%91%E6%8E%A7kubernetes/</url>
    <content><![CDATA[<h2 id="Prometheus-介绍">Prometheus 介绍</h2>
<p>Prometheus（普罗米修斯）是一个最初在SoundCloud上构建的监控系统。自2012年成为社区开源项目， 拥有非常活跃的开发人员和用户社区。为强调开源及独立维护，Prometheus于2016年加入云原生云计算基 金会（CNCF），成为继Kubernetes之后的第二个托管项目。</p>
<p><a href="https://prometheus.io/">https://prometheus.io/</a></p>
<p><a href="https://github.com/prometheus">https://github.com/prometheus</a></p>
<h2 id="Prometheus组件与架构">Prometheus组件与架构</h2>
<p><img src="/images/02E7559039504D2697674993D5445F38clipboard.png" alt></p>
<ul>
<li>
<p>Prometheus Server：收集指标和存储时间序列数据，并提供查询接口</p>
</li>
<li>
<p>ClientLibrary：客户端库</p>
</li>
<li>
<p>Push Gateway：短期存储指标数据。主要用于临时性的任务</p>
</li>
<li>
<p>Exporters：采集已有的第三方服务监控指标并暴露metrics</p>
</li>
<li>
<p>Alertmanager：告警</p>
</li>
<li>
<p>Web UI：简单的Web控制台</p>
</li>
</ul>
<h2 id="Prometheus基本使用：怎么来监控？">Prometheus基本使用：怎么来监控？</h2>
<p>如果要想监控，前提是能获取被监控端指标数据，并且这个 数据格式必须遵循Prometheus数据模型，这样才能识别和 采集，一般使用exporter提供监控指标数据</p>
<p>exporter列表：</p>
<p><a href="https://prometheus.io/docs/instrumenting/exporters">https://prometheus.io/docs/instrumenting/exporters</a></p>
<p><img src="/images/2D613AC47FB64D1E9B2A92FF54B9EE98clipboard.png" alt></p>
<ul>
<li>
<p>Prometheus Server：收集指标和存储时间序列数据，并提供查询接口</p>
</li>
<li>
<p>ClientLibrary：客户端库</p>
</li>
<li>
<p>Push Gateway：短期存储指标数据。主要用于临时性的任务</p>
</li>
<li>
<p>Exporters：采集已有的第三方服务监控指标并暴露metrics</p>
</li>
<li>
<p>Alertmanager：告警</p>
</li>
<li>
<p>Web UI：简单的Web控制台</p>
</li>
</ul>
<h2 id="Prometheus基本使用：部署">Prometheus基本使用：部署</h2>
<p>部署Prometheus：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name=prometheus -p 9090:9090 prom/prometheus</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://ip:9090/">http://ip:9090/</a></p>
<p>部署文档：<a href="https://prometheus.io/docs/prometheus/latest/installation/">https://prometheus.io/docs/prometheus/latest/installation/</a></p>
<p>部署Grafana：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name=grafana -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://ip:3000/">http://ip:3000/</a></p>
<p>部署文档：<a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a></p>
<p>用户名/密码：admin/admin # 第一次需要重置密码</p>
<p><img src="/images/810B7F4A81EE44BA9DD094BF855C8763clipboard.png" alt></p>
<h2 id="Prometheus基本使用：监控Linux服务器">Prometheus基本使用：监控Linux服务器</h2>
<p>node_exporter：用于监控Linux系统的指标采集器。</p>
<p>常用指标：</p>
<ul>
<li>
<p>CPU</p>
</li>
<li>
<p>内存</p>
</li>
<li>
<p>硬盘</p>
</li>
<li>
<p>网络流量</p>
</li>
<li>
<p>文件描述符</p>
</li>
<li>
<p>系统负载</p>
</li>
<li>
<p>系统服务</p>
</li>
</ul>
<p>数据接口：<a href="http://ip:9100/">http://ip:9100/</a></p>
<p>使用文档：<a href="https://prometheus.io/docs/guides/node-exporter/">https://prometheus.io/docs/guides/node-exporter/</a></p>
<p>GitHub：<a href="https://github.com/prometheus/node_exporter">https://github.com/prometheus/node_exporter</a></p>
<p>在Prometheus配置文件添加被监控端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrape_configs:                                                    </span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span>                                                                       </span><br><span class="line">                                                                                                 </span><br><span class="line">    <span class="comment"># metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">    <span class="comment"># scheme defaults to &#x27;http&#x27;.         </span></span><br><span class="line">                                         </span><br><span class="line">    static_configs:             </span><br><span class="line">    - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line">  - job_name: <span class="string">&#x27;Linux Server&#x27;</span>     </span><br><span class="line">    static_configs:              </span><br><span class="line">    - targets: [<span class="string">&#x27;192.168.0.12:9100&#x27;</span>,<span class="string">&#x27;192.168.0.13:9100&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用Grafana展示node_exporter数据指标，仪表盘ID： 9276</p>
<p><img src="/images/94A58E9E493A4507828805F430835074clipboard.png" alt></p>
<p><img src="/images/E0C7336FB9014DCF886C68EA1A6D4BDAclipboard.png" alt></p>
<h2 id="Prometheus基本使用：查询数据">Prometheus基本使用：查询数据</h2>
<p>PromQL(Prometheus Query Language) 是 Prometheus 自己开发的数据查询 DSL 语言，语言表现力非常丰 富，支持条件查询、操作符，并且内建了大量内置函数，供我们针对监控数据的各种维度进行查询。</p>
<p>数据模型：</p>
<ul>
<li>
<p>Prometheus将所有数据存储为时间序列；</p>
</li>
<li>
<p>具有相同度量名称以及标签属于同一个指标；</p>
</li>
<li>
<p>每个时间序列都由度量标准名称和一组键值对（称为标签）唯一标识， 通过标签查询指定指标。</p>
</li>
</ul>
<p>指标格式：</p>
<p><metric name>{<label name>=<label value>,…}</label></label></metric></p>
<p>示例：</p>
<p>查询指标最新样本（称为瞬时向量）：</p>
<p>node_cpu_seconds_total</p>
<p>可以通过附加一组标签来进一步过来这些时间序列：</p>
<p>node_cpu_seconds_total{job=“Linux Server”}</p>
<p>查询指标近5分钟内样本（称为范围向量，时间单位 s，m，h，d，w，y）： node_cpu_seconds_total{job=“Linux Server”}[5m]</p>
<p>node_cpu_seconds_total{job=“Linux Server”}[1h]</p>
<p><img src="/images/C15669D7F54143B9B450796E42803460clipboard.png" alt></p>
<h2 id="Kubernetes-监控指标">Kubernetes 监控指标</h2>
<p>Kubernetes本身监控</p>
<ul>
<li>
<p>Node资源利用率</p>
</li>
<li>
<p>Node数量</p>
</li>
<li>
<p>每个Node运行Pod数量</p>
</li>
<li>
<p>资源对象状态</p>
</li>
</ul>
<p>Pod监控</p>
<ul>
<li>
<p>Pod总数量及每个控制器预期数量</p>
</li>
<li>
<p>Pod状态</p>
</li>
<li>
<p>容器资源利用率：CPU、内存、网络</p>
</li>
</ul>
<h2 id="Kubernetes-监控实现思路">Kubernetes 监控实现思路</h2>
<p><img src="/images/27D0E1AC0E504AF28615CE9BA0D66E7Aclipboard.png" alt></p>
<p><img src="/images/AFBC9203DEBA40ECBFE01B98E1F76880clipboard.png" alt></p>
<p>Pod</p>
<p>kubelet的节点使用cAdvisor提供的metrics接口获取该节点所有Pod和容器相关的性能指标数据。</p>
<p>指标接口：<a href="https://NodeIP:10250/metrics/cadvisor">https://NodeIP:10250/metrics/cadvisor</a></p>
<p>Node</p>
<p>使用node_exporter收集器采集节点资源利用率。</p>
<p>项目地址：<a href="https://github.com/prometheus/node_exporter">https://github.com/prometheus/node_exporter</a></p>
<p>K8s资源对象</p>
<p>kube-state-metrics采集了k8s中各种资源对象的状态信息。</p>
<p>项目地址：<a href="https://github.com/kubernetes/kube-state-metrics">https://github.com/kubernetes/kube-state-metrics</a></p>
<h2 id="在Kubernetes平台部署相关组件">在Kubernetes平台部署相关组件</h2>
<p><a href="/attachments/40AFBBBACCBA4802B365208376B77297prometheus.zip">prometheus.zip</a></p>
<ul>
<li>
<p>prometheus-deployment.yaml # 部署Prometheus</p>
</li>
<li>
<p>prometheus-configmap.yaml # Prometheus配置文件，主要配置Kubernetes服务发现</p>
</li>
<li>
<p>prometheus-rules.yaml # Prometheus告警规则</p>
</li>
<li>
<p>grafana.yaml # 可视化展示</p>
</li>
<li>
<p>node-exporter.yml # 采集节点资源，通过DaemonSet方式部署，并声明让Prometheus收集</p>
</li>
<li>
<p>kube-state-metrics.yaml # 采集K8s资源，并声明让Prometheus收集</p>
</li>
<li>
<p>alertmanager-configmap.yaml # 配置文件，配置发件人和收件人</p>
</li>
<li>
<p>alertmanager-deployment.yaml # 部署Alertmanager告警组件</p>
</li>
</ul>
<p><a href="/attachments/3FC447C7D2D84D568FEA2B0B3AD166C7nfs-client.zip">nfs-client.zip</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装nfs安装包（每个k8s节点都要安装）</span></span><br><span class="line">yum install nfs-utils</span><br><span class="line"><span class="comment">#创建nfs共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/kubernetes</span><br><span class="line"><span class="comment">#修改nfs配置文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/nfs/kubernetes *(rw,no_root_squash)</span><br><span class="line"><span class="comment">#启动nfs并加入开机自启</span></span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署NFS实现自动创建PV插件：</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-incubator/external-storage </span><br><span class="line"><span class="built_in">cd</span> nfs-client/deploy </span><br><span class="line">kubectl apply -f rbac.yaml <span class="comment"># 授权访问apiserver </span></span><br><span class="line">kubectl apply -f deployment.yaml <span class="comment"># 部署插件，需修改里面NFS服务器地址与共享目录 </span></span><br><span class="line">kubectl apply -f class.yaml <span class="comment"># 创建存储类</span></span><br><span class="line">kubectl get sc  <span class="comment"># 查看存储类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubernetes-node-kubelet:获取kebelet暴露的指标，访问地址https://NodeIP:10250/metrics</span><br><span class="line">kubernetes-node-cadvisor:获取kubelet暴露的cadvisor，访问地址https://NodeIP:10250/metrics/cadvisor</span><br><span class="line">kubernetes-service-endpooints:从service列表只能endpoint发现pod为目标</span><br><span class="line">kubernetes-pod:发现所有pod为目标</span><br><span class="line"></span><br><span class="line">给pod重新标记标签</span><br><span class="line">1.配置采集pod的默认采集信息，例如协议，端口，url</span><br><span class="line">2.给pod添加标签，方便后面对数据多维度查询</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#prometheus和altermanger手动热加载配置</span></span><br><span class="line">curl -XPOST 10.244.169.152:9093/-/reload</span><br></pre></td></tr></table></figure>
<h2 id="Prometheus-告警">Prometheus 告警</h2>
<p>Prometheus报警功能利用Alertmanager组件完成，当Prometheus会对接收的指标数据比对告警规则，如果 满足条件，则将告警事件发送给Alertmanager组件，Alertmanager组件发送到接收人。</p>
<p>使用步骤：</p>
<ol>
<li>
<p>部署Alertmanager</p>
</li>
<li>
<p>配置告警接收人</p>
</li>
<li>
<p>配置Prometheus与Alertmanager通信</p>
</li>
<li>
<p>在Prometheus中创建告警规则</p>
</li>
</ol>
<p><img src="/images/7A103C798FC745D78E01C269EA892CEEclipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line"> resolve_timeout: 5m</span><br><span class="line"> <span class="comment"># 邮箱服务器</span></span><br><span class="line"> smtp_smarthost: <span class="string">&#x27;smtp.163.com:25&#x27;</span></span><br><span class="line"> smtp_from: <span class="string">&#x27;baojingtongzhi@163.com&#x27;</span></span><br><span class="line"> smtp_auth_username: <span class="string">&#x27;baojingtongzhi@163.com&#x27;</span></span><br><span class="line"> smtp_auth_password: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"> smtp_require_tls: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 配置路由树</span></span><br><span class="line">route:</span><br><span class="line"> group_by: [‘alertname’] <span class="comment"># 根据告警规则组名进行分组</span></span><br><span class="line"> group_wait: 10s <span class="comment"># 分组内第一个告警等待时间，10s内如有第二个告警会合并一个告警</span></span><br><span class="line"> group_interval: 10s <span class="comment"># 发送新告警间隔时间</span></span><br><span class="line"> repeat_interval: 1h <span class="comment"># 重复告警间隔发送时间</span></span><br><span class="line"> receiver: <span class="string">&#x27;mail&#x27;</span></span><br><span class="line"><span class="comment"># 接收人</span></span><br><span class="line">receivers:</span><br><span class="line">- name: <span class="string">&#x27;mail&#x27;</span></span><br><span class="line">  email_configs:</span><br><span class="line">  - to: <span class="string">&#x27;zhenliang369@163.com&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi prometheus.yml</span></span><br><span class="line"><span class="comment"># 指定Alertmanager组件地址</span></span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      - 127.0.0.1:9093</span><br><span class="line"><span class="comment"># 执行告警规则</span></span><br><span class="line">rule_files:</span><br><span class="line">  - <span class="string">&quot;rules/*.yml&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># vi rules/general.yml</span></span><br><span class="line"><span class="built_in">groups</span>:</span><br><span class="line">- name: example <span class="comment">#告警规则组名称</span></span><br><span class="line">  rules:</span><br><span class="line">  <span class="comment"># 任何实例5分钟内无法访问发出告警</span></span><br><span class="line">  - alert: InstanceDown <span class="comment"># 告警规则名称</span></span><br><span class="line">    <span class="built_in">expr</span>: up == 0 <span class="comment"># 基于PromQL的触发条件</span></span><br><span class="line">    <span class="keyword">for</span>: 5m <span class="comment"># 等待评估时间</span></span><br><span class="line">    labels: <span class="comment"># 自定义标签</span></span><br><span class="line">      severity: page</span><br><span class="line">    annotations: <span class="comment"># 指定附加信息</span></span><br><span class="line">      summary: <span class="string">&quot; &#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; 停止工作&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125;：job &#123;&#123; <span class="variable">$labels</span>.job &#125;&#125; 已经停止5分钟以上.&quot;</span>  </span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>告警状态：</p>
<ul>
<li>
<p>Inactive：这里什么都没有发生。</p>
</li>
<li>
<p>Pending：已触发阈值，但未满足告警持续时间</p>
</li>
<li>
<p>Firing：已触发阈值且满足告警持续时间。警报发送给接受者。</p>
</li>
</ul>
<p><img src="/images/80903A4C542A4376BF2CCF2255CA6F5Fclipboard.png" alt></p>
<p><img src="/images/166CD46A4C7F4434A1E761175A1B05E6clipboard.png" alt></p>
<p><img src="/images/29359740BD3A4AF498A5A7CC1F94E911clipboard.png" alt></p>
<p><img src="/images/49E932B96C6241CABC2D385839708FE4clipboard.png" alt></p>
<p>小结：</p>
<p>1.在k8s中部署应用，在service或者pod中配置注解</p>
<p>annotations:</p>
<pre><code>  prometheus.io/scrape: 'true'
</code></pre>
<p>2.数据被采集到，可以写任意告警规则，出现问题，第一时间通知你</p>
<p>3.如果grafana仪表盘无法满足需求，可以自定义</p>
<p>4.grafana图标没数据，数据没采集到，promq写的有问题，服务器时间没同步</p>
<p>5.altermanger和prometheus配置文件如果没生效，手动配置热加载</p>
<p>curl -XPOST 10.244.169.152:9093/-/reload</p>
<p>curl -XPOST 10.244.26.74:9090/-/reload</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数</title>
    <url>/2024/02/17/python%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数定义与调用">函数定义与调用</h2>
<p>函数：是指一段可以直接被另一段程序或代码引用的程序或代码。 在编写代码时，常将一些常用的功能模块编写成函数，放在函数库中供公共使用，可 减少重复编写程序段和简化代码结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">语法： </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">函数名称</span>(<span class="params">参数<span class="number">1</span>, 参数<span class="number">2</span>, ...</span>): </span><br><span class="line">    &lt;代码块&gt; </span><br><span class="line">    <span class="keyword">return</span> &lt;表达式&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>) </span><br><span class="line">hello() <span class="comment"># 调用函数</span></span><br></pre></td></tr></table></figure>
<h2 id="函数参数">函数参数</h2>
<h3 id="函数参数：接收参数">函数参数：接收参数</h3>
<p>示例：求和函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b</span>): </span><br><span class="line">    <span class="keyword">return</span> a + b </span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>,<span class="number">2</span>)) <span class="comment"># 按参数位置赋值 </span></span><br><span class="line"><span class="built_in">print</span>(f(b=<span class="number">2</span>,a=<span class="number">1</span>)) <span class="comment"># 按对应关系赋值</span></span><br></pre></td></tr></table></figure>
<p>示例：生成序列列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seq</span>(<span class="params">n</span>): </span><br><span class="line">    result = [] </span><br><span class="line">    x = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">while</span> x &lt; n: </span><br><span class="line">        result.append(x) </span><br><span class="line">        x += <span class="number">1</span> </span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line"><span class="built_in">print</span>(seq(<span class="number">9</span>))</span><br></pre></td></tr></table></figure>
<h3 id="函数参数：参数默认值">函数参数：参数默认值</h3>
<p>参数默认值：预先给参数定义默认值，如果调用函数时没指定该值，则用默认值。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b=<span class="number">2</span></span>): </span><br><span class="line">    <span class="keyword">return</span> a + b </span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>)) </span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h3 id="函数参数：接收任意数量参数">函数参数：接收任意数量参数</h3>
<p>前面学习的是固定参数数量，当不知道有多少个参数时可以在参数前面加*与**，表示可接收任意多个参数。</p>
<ul>
<li>
<p>*args 接收任意多个参数，并放到一个元组中。</p>
</li>
<li>
<p>**kwargs 接收一个键值，并存储为字典。</p>
</li>
</ul>
<p>示例：传入多个参数，计算总和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*seq</span>): </span><br><span class="line">    x = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> seq: </span><br><span class="line">        x += n </span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>示例：传入多个键值，进行处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**computer</span>): </span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> computer.items(): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;名称:%s\t价格:%s&quot;</span> % (k,v))</span><br><span class="line">func(主机=<span class="number">5000</span>,显示器=<span class="number">1000</span>,鼠标=<span class="number">60</span>,键盘=<span class="number">150</span>)        </span><br></pre></td></tr></table></figure>
<h2 id="匿名函数（Lambda）">匿名函数（Lambda）</h2>
<p>匿名函数：没有名字的函数，使用lambda关键字定义，一般仅用于单个表达式。</p>
<p>示例：求和函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="keyword">lambda</span> a, b: a+b </span><br><span class="line"><span class="built_in">print</span>(s(<span class="number">1</span>,<span class="number">2</span>)) </span><br><span class="line">等价于 </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b</span>): </span><br><span class="line">    <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure>
<h2 id="函数装饰器">函数装饰器</h2>
<p>函数装饰器作用：装饰器本质上是一个函数，它可以让其他函数在不需要做任何代码 变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。</p>
<p>应用场景：记录日志、性能测试、权限效验等</p>
<h3 id="函数装饰器：无参数">函数装饰器：无参数</h3>
<p>示例：装饰器使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是原函数&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;原函数开始执行了&quot;</span>) </span><br><span class="line">        func() </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;原函数执行结束了&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> f <span class="comment"># 返回函数体</span></span><br><span class="line">    </span><br><span class="line">dec = decorator(hello) <span class="comment"># 装饰器传入函数 </span></span><br><span class="line">dec() <span class="comment"># 调用内部函数    </span></span><br></pre></td></tr></table></figure>
<p>Python提供一个更简洁引用装饰器的方法：语法糖“@”</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是原函数&quot;</span>) </span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>
<h3 id="函数装饰器：带参数">函数装饰器：带参数</h3>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">msg</span>): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;原函数开始执行了&quot;</span>) </span><br><span class="line">        func(msg) </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;原函数执行结束了&quot;</span>) </span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">    </span><br><span class="line"><span class="meta">@decorator </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">msg</span>): </span><br><span class="line">    <span class="built_in">print</span>(msg)    </span><br><span class="line">    </span><br><span class="line">hello(<span class="string">&quot;我是原函数&quot;</span>)    </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PromQL基本使用</title>
    <url>/2021/09/08/promql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>PromQL(Prometheus Query Language) 是 Prometheus 自己开发的数据查询 DSL 语言，语言表现力 非常丰富，支持条件查询、操作符，并且内建了大量内置函数，供我们针对监控数据的各种维度进行查 询。</p>
<p><a href="https://prometheus.io/docs/prometheus/latest/querying/examples/">https://prometheus.io/docs/prometheus/latest/querying/examples/</a></p>
<p><a href="https://prometheus.io/docs/prometheus/latest/querying/operators/">https://prometheus.io/docs/prometheus/latest/querying/operators/</a></p>
<p><a href="https://prometheus.io/docs/querying/functions/">https://prometheus.io/docs/querying/functions/</a></p>
<p><img src="/images/C59A0A116F2E4FC0ABAC1773A6B5C3F8clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">目标实例状态:</span><br><span class="line">up   <span class="comment">#查看当前的一个实例以及实例的状态，1表示正常，0表示不正常</span></span><br><span class="line">count(up)   <span class="comment">#查看当前实例的总数  count()计数函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询指标最新样本（称为瞬时向量）： </span><br><span class="line">node_cpu_seconds_total </span><br><span class="line">可以通过附加一组标签来进一步过来这些时间序列： </span><br><span class="line">node_cpu_seconds_total&#123;job=<span class="string">&quot;Linux Server&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询指标近5分钟内样本（称为范围向量，时间单位 s，m，h，d，w，y）： </span><br><span class="line">node_cpu_seconds_total&#123;job=<span class="string">&quot;Linux Server&quot;</span>&#125;[5m] </span><br><span class="line">node_cpu_seconds_total&#123;job=<span class="string">&quot;Linux Server&quot;</span>&#125;[1h]</span><br><span class="line"></span><br><span class="line">查询cpu0除空闲利用率其他的资源利用率 != 不等于 </span><br><span class="line">node_cpu_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode!=<span class="string">&quot;idle&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数： • irate()：计算指标在一定时间间隔内的变化速率 </span><br><span class="line">示例：</span><br><span class="line">    irate(node_cpu_seconds_total&#123;job=<span class="string">&quot;Linux Server&quot;</span>,mode=<span class="string">&quot;system&quot;</span>&#125;[5m])</span><br><span class="line">        </span><br><span class="line">查询cpu0空闲利用率在5分钟内的一个变化速率值</span><br><span class="line">irate(node_cpu_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;[5m])</span><br><span class="line">查询整个总的cpu空闲利用率在5分钟内的一个变化速率平均值    avg:平均值</span><br><span class="line">avg(irate(node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>&#125;[5m]))</span><br><span class="line">空闲cpu利用率</span><br><span class="line">avg(irate(node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>&#125;[5m]))*100</span><br><span class="line">使用的cpu利用率</span><br><span class="line">100-(avg(irate(node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>&#125;[5m]))*100)</span><br><span class="line">查询磁盘/分区空闲利用率</span><br><span class="line">node_filesystem_free_bytes&#123;mountpoint=<span class="string">&quot;/&quot;</span>,fstype=~<span class="string">&quot;ext4|xfs&quot;</span>&#125;/node_filesystem_size_bytes&#123;mountpoint=<span class="string">&quot;/&quot;</span>,fstype=~<span class="string">&quot;ext4|xfs&quot;</span>&#125;*100</span><br><span class="line">查看磁盘/分区使用率</span><br><span class="line">100-(node_filesystem_free_bytes&#123;mountpoint=<span class="string">&quot;/&quot;</span>,fstype=~<span class="string">&quot;ext4|xfs&quot;</span>&#125;/node_filesystem_size_bytes&#123;mountpoint=<span class="string">&quot;/&quot;</span>,fstype=~<span class="string">&quot;ext4|xfs&quot;</span>&#125;*100)</span><br><span class="line">查看192.168.0.12这台机器的几核cpu的空闲利用率和</span><br><span class="line"><span class="built_in">sum</span>(node_cpu_seconds_total&#123;instance=<span class="string">&quot;192.168.0.12:9100&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;)</span><br><span class="line">查看192.168.0.12这台机器的几核cpu除空闲利用率的和，也就是几核cpu使用率的和</span><br><span class="line"><span class="built_in">sum</span>(node_cpu_seconds_total&#123;instance=<span class="string">&quot;192.168.0.12:9100&quot;</span>,mode!=<span class="string">&quot;idle&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/D6F1FDA841CC492987EABC164334BC46clipboard.png" alt></p>
<p><img src="/images/B1B24003545B4D79892B31B950294349clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础知识</title>
    <url>/2024/02/11/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="Python介绍">Python介绍</h2>
<p>Python是一种面向对象、解释型、多用途设计语言，具有很丰富和强大的库，语法简洁，强制用空格作为语法 缩进，能够完成快速项目开发，相比传统语言开发效率提高数倍。</p>
<p>应用领域：系统运维、网站开发、科学计算、爬虫、人工智能等</p>
<p>Web框架：</p>
<ul>
<li>
<p>Django（最流行）</p>
</li>
<li>
<p>Flask（轻量级）</p>
</li>
<li>
<p>Tornado（异步）</p>
</li>
</ul>
<p>为什么选择Python？</p>
<ul>
<li>
<p>语法简单，易于学习</p>
</li>
<li>
<p>广泛的标准库，适合快速开发</p>
</li>
<li>
<p>跨平台，基本所有操作系统都能运行</p>
</li>
<li>
<p>是DevOps开发领域应用最广泛的语言</p>
</li>
</ul>
<p>学习Python编程工具：</p>
<ul>
<li>
<p>Python官方文档：<a href="https://www.python.org/doc">https://www.python.org/doc</a></p>
</li>
<li>
<p>iPython：升级版的python解释器</p>
</li>
<li>
<p>PyCharm：一款功能强大的Python集成开发环境</p>
</li>
<li>
<p>Sublime：代码编辑器</p>
</li>
<li>
<p>Jupyter notebook：在网页中编写和运行代码</p>
</li>
<li>
<p>Pip：Python模块安装工具</p>
</li>
</ul>
<h2 id="Python安装">Python安装</h2>
<p>Linux安装：yum install python36 -y 一条命令完成安装。</p>
<p>或者编译安装指定版本：<a href="https://www.python.org/downloads/source">https://www.python.org/downloads/source</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.11.3/Python-3.11.3.tgz </span><br><span class="line">yum install zlib-devel -y </span><br><span class="line">tar zxvf Python-3.11.3.tgz </span><br><span class="line">cd Python-3.11.3 </span><br><span class="line">./configure </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>Windows安装：<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a> 官网下载安装程序。</p>
<p>Windows设置环境变量： 右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;Path-&gt;编辑-&gt;新建-&gt;粘贴Python安装目录 （例如D:\Python3.11\Scripts）</p>
<h2 id="Python解释器">Python解释器</h2>
<p>交互式解释器：</p>
<p><img src="/images/C70792B256AE466A8D7089D8F7F99218clipboard.png" alt></p>
<h2 id="运行第一个程序">运行第一个程序</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim hello.py </span></span><br><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># python hello.py </span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型">基本数据类型</h2>
<p>Python的基本数据类型：</p>
<ul>
<li>
<p>整数（int），例如6</p>
</li>
<li>
<p>浮点数（float），例如6.6</p>
</li>
<li>
<p>字符串（str），例如&quot;6&quot;,“python”</p>
</li>
<li>
<p>布尔值（bool），例如True、False</p>
</li>
</ul>
<p>注：使用type()内建函数查看对象类型。</p>
<h2 id="算术运算符">算术运算符</h2>
<p>什么是运算符？</p>
<p>举个简单的例子 6+6=12，其中两个6被称为操作数，+称为运算符。</p>
<p><img src="/images/559FAF0084B24F44803394692DAF17A1clipboard.png" alt></p>
<h2 id="变量">变量</h2>
<p>变量：编程语言中能储存结果或能表示值的抽象概念。</p>
<p>用途：给一段数据赋予一个简短、易于记忆的名字，方便重用。</p>
<p>变量赋值：</p>
<p>变量名=变量值</p>
<p>例如：name=“zhangsan”</p>
<p>多重赋值：</p>
<p>name1, name2 = “zhangsan”,”wangwu”</p>
<p>变量引用：</p>
<p>print(变量名)</p>
<p><img src="/images/09B986A2C9EA4A29B1C0EC834C8C6A10clipboard.png" alt></p>
<p>格式化字符串：</p>
<p>print(“hello %s”%name)</p>
<p>保留2位小数点：</p>
<p>calc = 100 / 88</p>
<p>print(‘计算结果：%.2f’ %calc)</p>
<h2 id="赋值操作符">赋值操作符</h2>
<p><img src="/images/109A29D7754F405AA9E7024362220071clipboard.png" alt></p>
<h2 id="转义字符">转义字符</h2>
<p><img src="/images/9547A52F08184238A918C234A01B88CCclipboard.png" alt></p>
<p>示例：</p>
<p>print(“姓名: %s, &quot;年龄：%d” %(name, age))</p>
<h2 id="获取用户输入">获取用户输入</h2>
<p>input()内建函数：用于与用户交互，接收一个参数，即要向用户显示的提示或者说明，让用户知道该怎么做。</p>
<p>示例：</p>
<p>name = input(“请输入你的姓名：”)</p>
<p>print(name)</p>
<p>一个#号表示单行注释</p>
<p>#print(name)</p>
<p>三个单引号或者三个双引号表示多行注释</p>
<p>‘’’</p>
<p>多行注释</p>
<p>‘’’</p>
<h2 id="综合案例：实现简单的计算器">综合案例：实现简单的计算器</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;计算器，输入编号进行运算&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    # 1. 加法</span></span><br><span class="line"><span class="string">    # 2. 减法</span></span><br><span class="line"><span class="string">    # 3. 乘法</span></span><br><span class="line"><span class="string">    # 4. 除法</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">choice = <span class="built_in">input</span>(<span class="string">&#x27;请输入编号：&#x27;</span>)</span><br><span class="line">num1 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入数字1：&#x27;</span>))</span><br><span class="line">num2 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入数字2：&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> choice == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(num1+num2)</span><br><span class="line"><span class="keyword">elif</span> choice == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(num1-num2)</span><br><span class="line"><span class="keyword">elif</span> choice == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(num1*num2)</span><br><span class="line"><span class="keyword">elif</span> choice == <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(num1/num2)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误，请输入对应的编号&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python字符串</title>
    <url>/2024/02/12/python%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="字符串格式化输出">字符串格式化输出</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;zhangsan&quot;</span> </span><br><span class="line">age = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法1 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字是%s,今年%s岁了。&quot;</span> % (name, age)) </span><br><span class="line"><span class="comment"># 方法2 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;我的名字是<span class="subst">&#123;name&#125;</span>,今年<span class="subst">&#123;age&#125;</span>岁了。&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="字符串拼接">字符串拼接</h2>
<p>使用“+”可以对多个字符串进行拼接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">示例： </span><br><span class="line">str1 = <span class="string">&quot;hello&quot;</span> </span><br><span class="line">str2 = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1 + str2)</span><br></pre></td></tr></table></figure>
<p>其他方式：</p>
<ul>
<li>
<p>格式化输出</p>
</li>
<li>
<p>逗号</p>
</li>
<li>
<p>join() 字符串的内置函数，将序列中的元素拼接成一个字符串。后面讲到</p>
</li>
</ul>
<h2 id="获取字符串长度">获取字符串长度</h2>
<p>len()内建函数：计算字符串的长度。</p>
<p>语法格式：len(string)</p>
<h2 id="字符串切片">字符串切片</h2>
<p>切片：截取字符串中的某部分内容</p>
<p>语法格式：string[start:end:step]</p>
<ul>
<li>
<p>string 要切片的字符串</p>
</li>
<li>
<p>start 要切片的第一个字符的索引（包括该字符），如果不指定默认为0</p>
</li>
<li>
<p>end 要切片的最后一个字符的索引（不包括该字符），如果不指定默认为字符串的长度</p>
</li>
<li>
<p>step 表示切片的步长，如果不指定默认为1</p>
</li>
</ul>
<p><img src="/images/B252BCFE0972479CA0C46799B9AFD92Fclipboard.png" alt></p>
<p>示例：</p>
<p>截取第5个字符：s[4]</p>
<p>截取第1个字符到第5个字符：s[0:5]</p>
<p>截取最后1个字符：s[-1]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串切片</span></span><br><span class="line">str1 = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">4</span>]) <span class="comment">#o</span></span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">0</span>:<span class="number">5</span>]) <span class="comment">#Hello</span></span><br><span class="line"><span class="built_in">print</span>(str1[-<span class="number">1</span>])  <span class="comment">#!</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串处理方法">字符串处理方法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串的方法使用</span></span><br><span class="line">xxoo = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;首字母大写: %s&quot;</span> % xxoo.capitalize())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符l出现次数: %s&quot;</span> % xxoo.count(<span class="string">&#x27;l&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;感叹号是否结尾: %s&quot;</span> % xxoo.endswith(<span class="string">&#x27;!&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;w字符是否是开头: %s&quot;</span> % xxoo.startswith(<span class="string">&#x27;w&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;w字符索引位置: %s&quot;</span> % xxoo.find(<span class="string">&#x27;w&#x27;</span>)) <span class="comment"># xxoo.index(&#x27;W&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;格式化字符串: Hello&#123;0&#125; world!&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;是否都是小写: %s&quot;</span> % xxoo.islower())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;是否都是大写: %s&quot;</span> % xxoo.isupper())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有字母转为小写: %s&quot;</span> % xxoo.lower())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有字母转为大写: %s&quot;</span> % xxoo.upper())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;感叹号替换为句号: %s&quot;</span> % xxoo.replace(<span class="string">&#x27;!&#x27;</span>,<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;以空格分隔切分成列表: %s&quot;</span> % xxoo.split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;切分为一个列表: %s&quot;</span> % xxoo.splitlines())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;去除两边空格: %s&quot;</span> % xxoo.strip())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;大小写互换: %s&quot;</span> % xxoo.swapcase())</span><br></pre></td></tr></table></figure>
<p><img src="/images/BE2EF9E638E64A86AED9FB1D10AB24A4clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>常用内建函数</title>
    <url>/2024/02/18/python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="内建函数">内建函数</h2>
<p>Python解释器内置了很多函数，你可以直接使用它们。</p>
<p>在前面学习过的内建函数有：print()、len()、open()、range()</p>
<p><img src="/images/2C0DA00C753D4EF9A4B75F09EB413915clipboard.png" alt></p>
<p>参考文档：<a href="https://docs.python.org/zh-cn/3.11/library/functions.html">https://docs.python.org/zh-cn/3.11/library/functions.html</a></p>
<h2 id="高阶函数">高阶函数</h2>
<p>内建高阶函数：map()、filter()</p>
<p>高阶函数至少满足两个任意的一个条件：</p>
<ul>
<li>
<p>能接收一个或多个函数作为输入</p>
</li>
<li>
<p>输出一个函数</p>
</li>
</ul>
<h3 id="高阶函数：map">高阶函数：map()</h3>
<p>map() 函数：根据提供的函数处理序列中的元素，处理完后返回一个迭代器对象。</p>
<p>语法：map(function, iterable, …)</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">n</span>): </span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2</span> </span><br><span class="line">result = <span class="built_in">map</span>(handle, num)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result)) </span><br><span class="line">或者使用匿名函数： </span><br><span class="line">result = <span class="built_in">map</span>(<span class="keyword">lambda</span> n:n * <span class="number">2</span>, num) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br></pre></td></tr></table></figure>
<h3 id="高阶函数：filter">高阶函数：filter()</h3>
<p>filter()函数：用于过滤序列，过滤掉不符合条件的元素，处理完后返回一个迭代器对象。</p>
<p>语法：filter(function, iterable)</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">n</span>): </span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: </span><br><span class="line">    <span class="keyword">return</span> n </span><br><span class="line">result = <span class="built_in">filter</span>(handle, num) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result)) </span><br><span class="line">或者使用匿名函数： </span><br><span class="line">result = <span class="built_in">filter</span>(<span class="keyword">lambda</span> n:n % <span class="number">2</span> == <span class="number">0</span>, num) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br></pre></td></tr></table></figure>
<h2 id="排序函数">排序函数</h2>
<p>sorted()函数：对所有可迭代的对象进行排序操作。</p>
<p>语法：sorted(iterable, *, key=None, reverse=False)</p>
<ul>
<li>
<p>key：指定带有单个参数的函数，用于从interable的每个元素取出比较的键，默认为None（直接比较元素）</p>
</li>
<li>
<p>reverse 排序规则，True降序， False升序（默认）</p>
</li>
</ul>
<p>示例1：对列表排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>] </span><br><span class="line">s = [<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;a&quot;</span>] </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(n)) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(s))</span><br></pre></td></tr></table></figure>
<p>示例2：对字典中的值排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">86</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">23</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">45</span>&#125; </span><br><span class="line">result = <span class="built_in">sorted</span>(<span class="built_in">dict</span>.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>]) </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<h2 id="反转函数">反转函数</h2>
<p>reversed()函数：返回一个反转的迭代器。</p>
<p>语法：reversed(seq)</p>
<p>示例：列表反向</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(n)))</span><br></pre></td></tr></table></figure>
<h2 id="最小值、最大值、求和函数">最小值、最大值、求和函数</h2>
<ul>
<li>
<p>min() 返回可迭代对象中最小的元素</p>
</li>
<li>
<p>max() 返回可迭代对象中最大的元素</p>
</li>
<li>
<p>sum() 对可迭代对象求和</p>
</li>
</ul>
<h2 id="多个可迭代对象聚合">多个可迭代对象聚合</h2>
<p>zip()函数：对多个可迭代对象创建一个聚合，返回一个元组的迭代器。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] </span><br><span class="line">zipped = <span class="built_in">zip</span>(x, y) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(zipped))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用标准库</title>
    <url>/2024/02/23/python%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<h2 id="常用标准库">常用标准库</h2>
<p><img src="/images/826ADF0CA6A4422C912B586E5F6F8895clipboard.png" alt></p>
<p>官方文档标准库列表：</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/index.html">https://docs.python.org/zh-cn/3.8/library/index.html</a></p>
<h2 id="标准库：os">标准库：os</h2>
<p>os库主要对目标和文件操作。</p>
<p><img src="/images/452F568C82094DE99844D93618F5E4DAclipboard.png" alt></p>
<p>os.path类用于获取文件属性。</p>
<p><img src="/images/F3F24F1F75CA4AFD88EED93D275AF514clipboard.png" alt></p>
<h2 id="标准库：sys">标准库：sys</h2>
<p>sys库用于与Python解释器交互。</p>
<p><img src="/images/B029463CDB554813B3D9EC4C15EE84FFclipboard.png" alt></p>
<h2 id="标准库：platform">标准库：platform</h2>
<p>platform库用于获取操作系统详细信息。</p>
<p><img src="/images/583DFCCD732A4DB5A027C0258DFF0060clipboard.png" alt></p>
<h2 id="标准库：glob">标准库：glob</h2>
<p>glob库用于文件查找，支持通配符（*、？、[]）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>：查找目录中所有以.sh为后缀的文件: </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">&#x27;/home/user/*.sh&#x27;</span>) </span><br><span class="line">[<span class="string">&#x27;/home/user/b.sh&#x27;</span>, <span class="string">&#x27;/home/user/a.sh&#x27;</span>, <span class="string">&#x27;/home/user/sum.sh&#x27;</span>] </span><br><span class="line">示例<span class="number">2</span>：查找目录中出现单个字符并以.sh为后缀的文件: </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">&#x27;/home/user/?.sh&#x27;</span>) </span><br><span class="line">[<span class="string">&#x27;/home/user/b.sh&#x27;</span>, <span class="string">&#x27;/home/user/a.sh&#x27;</span>] </span><br><span class="line">示例<span class="number">3</span>：查找目录中出现a.sh或b.sh的文件: </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">&#x27;/home/user/[a|b].sh&#x27;</span>) </span><br><span class="line">[<span class="string">&#x27;/home/user/b.sh&#x27;</span>, <span class="string">&#x27;/home/user/a.sh&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="标准库：random">标准库：random</h2>
<p>random库用于生成随机数。</p>
<p><img src="/images/AB9A7220ADEC47F5B67424076E47A920clipboard.png" alt></p>
<h2 id="标准库：subprocess">标准库：subprocess</h2>
<p>subprocess库用于执行Shell命令，工作时会fork一个子进程去执行任务，连接到子进程的标准输入、输出、错误，并获得 它们的返回代码。</p>
<p>这个模块将取代os.system、os.spawn*、os.popen*、popen2.<em>和commands.</em>。</p>
<p>subprocess的主要方法：</p>
<p>subprocess.run()，subprocess.Popen(),subprocess.call</p>
<p>语法：subprocess.run(args, *, stdin=None, stdout=None, stderr=None, shell=False, cwd=None, timeout=None, check=False, encoding=None)</p>
<p><img src="/images/40E7AC476D5842698194CE67F2CF1C89clipboard.png" alt></p>
<p>示例：执行shell命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess </span><br><span class="line">cmd = <span class="string">&quot;pwd&quot;</span> </span><br><span class="line">result = subprocess.run(cmd, shell=<span class="literal">True</span>, timeout=<span class="number">3</span>, stderr=subprocess.PIPE, stdout=subprocess.PIPE) </span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">run方法返回CompletedProcess实例，可以直接从这个实例中获取命令运行结果： </span><br><span class="line"><span class="built_in">print</span>(result.returncode) <span class="comment"># 获取命令执行返回状态码 </span></span><br><span class="line"><span class="built_in">print</span>(result.stdout) <span class="comment"># 命令执行标准输出 </span></span><br><span class="line"><span class="built_in">print</span>(result.stderr) <span class="comment"># 命令执行错误输出</span></span><br></pre></td></tr></table></figure>
<h2 id="标准库：json">标准库：json</h2>
<p>JSON是一种轻量级数据交换格式，一般API返回的数据大多是 JSON、XML，如果返回JSON的话，需将获取的数据转换成字典， 方面在程序中处理。</p>
<p>json主要提供两种方法：</p>
<ul>
<li>
<p>dumps() 将python对象转为json对象</p>
</li>
<li>
<p>loads() 将json对象转为python对象</p>
</li>
</ul>
<p>应用场景：访问API</p>
<p><img src="/images/769BB8FDD99349639290E2B18008BCFDclipboard.png" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将字典类型转换为JSON对象 </span></span><br><span class="line"><span class="keyword">import</span> json </span><br><span class="line">computer = &#123;<span class="string">&quot;主机&quot;</span>:<span class="number">5000</span>,<span class="string">&quot;显示器&quot;</span>:<span class="number">1000</span>,<span class="string">&quot;鼠标&quot;</span>:<span class="number">60</span>,<span class="string">&quot;键盘&quot;</span>:<span class="number">150</span>&#125; </span><br><span class="line">json_obj = json.dumps(computer) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(json_obj)) </span><br><span class="line"><span class="built_in">print</span>(json_obj) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将JSON对象转换为字典 </span></span><br><span class="line"><span class="keyword">import</span> json </span><br><span class="line">data = json.loads(json_obj) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br></pre></td></tr></table></figure>
<h2 id="标准库：time">标准库：time</h2>
<p>time库用于满足简单的时间处理，例如获 取当前时间戳、日期、时间、休眠。</p>
<p><img src="/images/F57BCF0223184642A8153B4F220FEF94clipboard.png" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>：将当前时间转换为指定格式 </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line">time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) </span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span>：将时间戳转换指定格式 </span><br><span class="line">now = time.time() </span><br><span class="line">struct_time = time.localtime(now) </span><br><span class="line">time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>,struct_time)</span><br></pre></td></tr></table></figure>
<h2 id="标准库：datetime">标准库：datetime</h2>
<p>datetime库用于处理更复杂的日期和时间。</p>
<p>提供以下几个类：</p>
<p><img src="/images/38E1EB61A446433DAB85A9303975DC62clipboard.png" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime </span><br><span class="line"><span class="comment"># 将当前系统时间转换指定格式 </span></span><br><span class="line">date.strftime(datetime.now(), <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>) </span><br><span class="line"><span class="comment"># 获取当前系统日期 </span></span><br><span class="line">date.today() </span><br><span class="line"><span class="comment"># 将时间戳转换指定格式 </span></span><br><span class="line">date_array = datetime.fromtimestamp(time.time()) </span><br><span class="line">date_array.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取昨天日期 </span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, timedelta </span><br><span class="line">yesterday = date.today() - timedelta(days=<span class="number">1</span>) </span><br><span class="line"><span class="built_in">print</span>(yesterday) </span><br><span class="line"><span class="comment"># 获取明天日期 </span></span><br><span class="line">tomorrow = date.today() + timedelta(days=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="标准库：urllib">标准库：urllib</h2>
<p>urllib库用于访问URL。</p>
<p>urllib包含以下类：</p>
<ul>
<li>
<p>urllib.request 打开和读取 URL</p>
</li>
<li>
<p>urllib.error 包含 urllib.request 抛出的异常</p>
</li>
<li>
<p>urllib.parse 用于解析 URL</p>
</li>
<li>
<p>urllib.robotparser 用于解析 robots.txt 文件</p>
</li>
</ul>
<p>用的最多是urllib.request 类，它定义了适用于在各种复杂情况下打开 URL，例如基本认证、重定向、Cookie、代理等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request </span><br><span class="line">res = request.urlopen(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>res 是一个HTTPResponse类型的对象，包含以下方法和属性：</p>
<p><img src="/images/E1D659E847D74C2E8865D587A535E1A6clipboard.png" alt></p>
<p>示例1：自定义用户代理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request </span><br><span class="line">url = <span class="string">&quot;http://www.baidu.com&quot;</span> </span><br><span class="line">user_agent = <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&quot;</span> </span><br><span class="line">header = &#123;<span class="string">&quot;User-Agent&quot;</span>: user_agent&#125; </span><br><span class="line">req = request.Request(url, headers=header) </span><br><span class="line">res = request.urlopen(req) </span><br><span class="line"><span class="built_in">print</span>(res.getcode())</span><br></pre></td></tr></table></figure>
<p>示例2：向接口提交用户数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse </span><br><span class="line">url = <span class="string">&quot;http://www.baidu.com/login&quot;</span> </span><br><span class="line">post_data = &#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;user1&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123456&quot;</span>&#125; </span><br><span class="line"><span class="comment">#将字典转为URL查询字符串格式，并转为bytes类型 </span></span><br><span class="line">post_data = parse.urlencode(post_data).encode(<span class="string">&quot;utf8&quot;</span>) </span><br><span class="line">req = request.Request(url, data=post_data, headers=header) </span><br><span class="line">res = request.urlopen(req) </span><br><span class="line"><span class="built_in">print</span>(res.read())</span><br></pre></td></tr></table></figure>
<h2 id="标准库：re">标准库：re</h2>
<p>Python正则表达式主要由re标准库提供，基本上支持所有的正则表达式。</p>
<p><img src="/images/54C41DBF1439489885FA1D4B581C38D1clipboard.png" alt></p>
<p>语法：re.compile(pattern, flags=0)</p>
<p>pattern 指的是正则表达式。flags是标志位 的修饰符，用于控制表达式匹配模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">s = <span class="string">&quot;this is test string&quot;</span> </span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;this&#x27;</span>) </span><br><span class="line">result = pattern.<span class="keyword">match</span>(s) </span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br></pre></td></tr></table></figure>
<p>语法：re.match(pattern, string, flags=0)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line">s = <span class="string">&quot;this is test string&quot;</span> </span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">&#x27;this&#x27;</span>, s) </span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br></pre></td></tr></table></figure>
<p>匹配成功后，result对象会增加一个group()方法，可 以用它来获取匹配结果</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python操作符</title>
    <url>/2024/02/14/python%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="操作符有什么用？">操作符有什么用？</h2>
<p><img src="/images/826B3FA47C7043958D702698DB4F25A6clipboard.png" alt></p>
<p>操作符：一个特定的符号，用它与其他数据类型连接起来组成一个 表达式。常用于条件判断，根据表达式返回True/False采取动作。</p>
<h2 id="比较操作符">比较操作符</h2>
<p>比较操作符：比较两边值</p>
<p><img src="/images/983BD94438074D9AAAA1F95B70E262F6clipboard.png" alt></p>
<h2 id="逻辑操作符">逻辑操作符</h2>
<p>逻辑操作符：判断条件逻辑</p>
<p><img src="/images/15C8AA9146D245A9836049AD8B348836clipboard.png" alt></p>
<h2 id="成员操作符">成员操作符</h2>
<p>成员操作符：判断某个元素是否在数据类型里</p>
<p><img src="/images/C6D5088C7FF84C1FB8D1A8EE33F7E8F4clipboard.png" alt></p>
<h2 id="身份操作符">身份操作符</h2>
<p>身份操作符：判断两个对象是否相等</p>
<p><img src="/images/5F29758389ED40DBB13DCD3542904E4Eclipboard.png" alt></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python异常处理</title>
    <url>/2024/02/21/python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="什么是异常">什么是异常</h2>
<p>什么是异常？</p>
<p>顾名思义，异常就是程序因为某种原因无法正常工作了，比如缩进错误、缺少软件包、环境 错误、连接超时等都会引发异常。 一个健壮的程序应该把所能预知的异常都应做相应的处理，保障程序长期运行。</p>
<h2 id="捕获异常语法">捕获异常语法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">语法： </span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    &lt;代码块&gt; </span><br><span class="line"><span class="keyword">except</span> [异常类型]: </span><br><span class="line">    &lt;发生异常时执行的代码块&gt;</span><br></pre></td></tr></table></figure>
<p>如果在执行 try 块里的业务逻辑代码时出现异常，系统会自动生成一个异常对象，该异常对象被提交给 Python 解释器，这个过程被称为引发 异常。</p>
<p>当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块，如果找到合适的 except 块，则把该异常对象交给该 except 块处理， 这个过程被称为捕获异常。如果 Python 解释器找不到捕获异常的 except 块，则运行时环境终止，Python 解释器也将退出。</p>
<h2 id="异常类型">异常类型</h2>
<p><img src="/images/01DFCA1C701146FAB22CFE69FE5C65B2clipboard.png" alt></p>
<h2 id="异常处理">异常处理</h2>
<p>示例：打印一个没有定义的变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    <span class="built_in">print</span>(name) </span><br><span class="line"><span class="keyword">except</span> NameError: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生名称错误时，执行的代码&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>示例：当不确定异常类型时，可以使用通用异常类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    <span class="built_in">print</span>(name) </span><br><span class="line"><span class="keyword">except</span> Exception: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生名称错误时，执行的代码&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>示例：保存异常信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    <span class="built_in">print</span>(name) </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;错误：%s&quot;</span> %e) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生名称错误时，执行的代码&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据类型</title>
    <url>/2024/02/13/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="数据类型">数据类型</h2>
<p>在Python中，组合数据类型有：列表（list）、元组（tuple）、字典（dict）、集合（set）。 组合数据类型：为了方便处理数据，把一些同类数据放到一起，是一组数据的集合。</p>
<h2 id="列表">列表</h2>
<p>列表（List）：是一个序列的数据结构。</p>
<p>什么是序列？ 是指它成员都是有序排列，并且可以通过索引访问一个或多个成员。</p>
<p>格式：名称 = [“元素1”，“元素2”，…]</p>
<h3 id="列表：基本操作">列表：基本操作</h3>
<p>定义列表：computer = [“主机”,“显示器”,“鼠标”,“键盘”]</p>
<p><img src="/images/67512F8DA03040DC80BF7DFD842E942Cclipboard.png" alt></p>
<h3 id="列表：切片">列表：切片</h3>
<p>与字符串切片使用方法一样。</p>
<p>语法格式：list[start:end:step]</p>
<p>示例：</p>
<p>截取第1个元素：computer[0]</p>
<p>截取第1个字符到第5个元素：computer[0:5]</p>
<p>截取第1个到倒数第2个元素：computer[0:-1]</p>
<p>截取最后1个元素：computer[-1]</p>
<p><img src="/images/4C3F05114AE448C495A0AF898867E190clipboard.png" alt></p>
<h3 id="列表：清空列表">列表：清空列表</h3>
<p>重新初始化列表</p>
<p>computer = []</p>
<p>del语句删除列表</p>
<p>del computer</p>
<h2 id="元组">元组</h2>
<p>元组（Tuple）：与列表类似，也是一个序列数据结构。主要区别在于元组中的元素不能修改。</p>
<p>格式：名称 = （“元素1”，“元素2”，…）</p>
<h3 id="元组：基本操作">元组：基本操作</h3>
<p>定义元组：computer = (“主机”,“显示器”,“鼠标”,“键盘”)</p>
<p><img src="/images/53FFB8537A3249FA9DB514E8D0872EE5clipboard.png" alt></p>
<p>同样支持切片，与列表使用方法一样。</p>
<h2 id="集合">集合</h2>
<p>集合（Set）：是一个无序、不重复元素的序列，主要用于元素去重和关系测试。</p>
<p>关系测试支持：</p>
<ul>
<li>
<p>联合</p>
</li>
<li>
<p>交集</p>
</li>
<li>
<p>差集</p>
</li>
<li>
<p>对称差集</p>
</li>
</ul>
<p>定义方法：set()函数或者大括号来创建集合。</p>
<p>注意：想要创建空集合，必须使用set()而不是{}。后者用于创建空字典。</p>
<h3 id="集合：基本操作">集合：基本操作</h3>
<p>定义空数组：computer = set()</p>
<p>定义元组：</p>
<p>computer = {“主机”,“显示器”,“鼠标”,“键盘”}</p>
<p>或者</p>
<p>computer = set([“主机”,“显示器”,“鼠标”,“键盘”,“主机”])</p>
<p><img src="/images/FC44858638A944BE9A1835C26632E00Fclipboard.png" alt></p>
<p>列表去重： 如果有元素则删除 随机删除一个元素</p>
<p>computer = [“主机”,“显示器”,“鼠标”,“键盘”,“显示器”,“鼠标”]</p>
<p>s = set(computer) print(s)</p>
<h3 id="集合：关系测试">集合：关系测试</h3>
<p><img src="/images/9C41AD031E164747AE8CDF48265FB4EEclipboard.png" alt></p>
<p>对两个列表进行关系测试：</p>
<p>a = set([1, 2, 3, 4, 5, 6])</p>
<p>b = set([4, 5, 6, 7, 8, 9])</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回a集合中元素在b集合没有的 </span></span><br><span class="line"><span class="built_in">print</span>(a - b) </span><br><span class="line"><span class="comment"># 返回b集合中元素在a集合中没有的 </span></span><br><span class="line"><span class="built_in">print</span>(b - a) </span><br><span class="line"><span class="comment"># 返回交集，即两个集合中一样的元素 </span></span><br><span class="line"><span class="built_in">print</span>(a &amp; b) </span><br><span class="line"><span class="comment"># 返回合集，即合并去重 </span></span><br><span class="line"><span class="built_in">print</span>(a | b) </span><br><span class="line"><span class="comment"># 判断是否不相等 </span></span><br><span class="line"><span class="built_in">print</span>(a != b) </span><br><span class="line"><span class="comment"># 判断是否相等 </span></span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br></pre></td></tr></table></figure>
<h2 id="字典">字典</h2>
<p>字典（Dict）：是一个具有映射关系的数据结构。用于存储有一定关系的元素。</p>
<p>格式：d = {‘key1’:value1, ‘key2’:value2, ‘key3’:value3}</p>
<p>注意：字典通过key来访问value，因此字典中的key不允许重复。</p>
<h3 id="字典：基本操作">字典：基本操作</h3>
<p>定义字典：computer = {“主机”:5000,“显示器”:1000,“鼠标”:60,“键盘”:150}</p>
<p><img src="/images/F07AC8F598934E8992FBE1BE23A9456Dclipboard.png" alt></p>
<h3 id="字典：嵌套">字典：嵌套</h3>
<p>字典里的值不但是可以写整数、字符串，也可以是其他数据类型，例如列表、元组、集 合、字典，这样可满足一个键还包含其他属性。</p>
<p>computer = {“主机”:{“CPU”:1300,“内存”:400,“硬盘”:200},“显示器”:1000,“鼠标”:60,“键 盘”:[“机械键盘”,“薄膜键盘”]}</p>
<p>操作key中字典：</p>
<p>computer[“主机”][“硬盘”]</p>
<p>computer[“主机”][“硬盘”] = &quot;300“</p>
<p>操作key中列表：</p>
<p>computer[“键盘”]</p>
<p>computer[“键盘”].append(“其他”)</p>
<h2 id="常用数据类型转换">常用数据类型转换</h2>
<p><img src="/images/1ADBEB80091D4D5BB325B08B307C7358clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python文件操作</title>
    <url>/2024/02/16/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="open-函数">open()函数</h2>
<p>要想读取文件（如txt、csv等），第一步要用open()内建函数打开文件，它会返回一个文件对象，这个对象 拥有read()、write()、close()等方法。</p>
<p>语法：open(file, mode=‘r’, encoding=None)</p>
<p>file：打开的文件路径</p>
<p>mode（可选）：打开文件的模式，如只读、追加、写入等</p>
<ul>
<li>
<p>r：只读（默认）</p>
</li>
<li>
<p>w：只写</p>
</li>
<li>
<p>a：在原有内容的基础上追加内容（末尾）</p>
</li>
<li>
<p>w+：读写</p>
</li>
</ul>
<p>如果需要以字节（二进制）形式读取文件，只需要在mode值追加‘b’即可，例如wb</p>
<h2 id="文件对象操作">文件对象操作</h2>
<p>f = open(‘test.txt’)</p>
<p><img src="/images/A2AA6F2EEE33495F98BDC2811D7380D6clipboard.png" alt></p>
<p>示例：遍历打印每一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;computer.txt&#x27;</span>) </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f: </span><br><span class="line">    <span class="built_in">print</span>(line.strip(<span class="string">&#x27;\n&#x27;</span>)) <span class="comment"># 去掉换行符</span></span><br></pre></td></tr></table></figure>
<h2 id="with语句">with语句</h2>
<p>with语句：不管在处理文件过程中是否发生异常，都能保证 with 语句 执行完毕后已经关闭了打开的文件句柄。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;computer.txt&quot;</span>,encoding=<span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> f: </span><br><span class="line">    data = f.read() </span><br><span class="line">    <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据库编程</title>
    <url>/2024/02/24/python%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="pymysql模块">pymysql模块</h2>
<p>pymysql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同。但目前pymysql 支持python3.x而后者不支持3.x版本。</p>
<p>pymysql是第三方模块，需要单独安装，首选通过pip安装PyMySQL:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pip3 install pymysql</span></span><br></pre></td></tr></table></figure>
<h2 id="基本使用">基本使用</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">先创建一个test库，再创建一张user表： </span><br><span class="line">create database test; </span><br><span class="line">use test; </span><br><span class="line">create table user( <span class="built_in">id</span> <span class="built_in">int</span> primary key <span class="keyword">not</span> null auto_increment, username varchar(<span class="number">50</span>) <span class="keyword">not</span> null, password varchar(<span class="number">50</span>) <span class="keyword">not</span> null );</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql </span><br><span class="line">conn = pymysql.connect( </span><br><span class="line">    host=<span class="string">&#x27;192.168.1.11&#x27;</span>, </span><br><span class="line">    port=<span class="number">3306</span>, </span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>, </span><br><span class="line">    password=<span class="string">&#x27;123456&#x27;</span>, </span><br><span class="line">    db=<span class="string">&#x27;test&#x27;</span>, </span><br><span class="line">    charset=<span class="string">&#x27;utf8&#x27;</span>, </span><br><span class="line">    cursorclass=pymysql.cursors.DictCursor </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cursor = conn.cursor() </span><br><span class="line"><span class="comment"># 插入单条记录 </span></span><br><span class="line">sql = <span class="string">&quot;insert into user(username, password) values (&#x27;amei&#x27;, &#x27;123456&#x27;)&quot;</span> </span><br><span class="line">cursor.execute(sql) </span><br><span class="line">conn.commit() </span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<p><img src="/images/F37E1300DDBF4E6E970872C4651F242Eclipboard.png" alt></p>
<h2 id="增删改查">增删改查</h2>
<p>示例：遍历查询结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql </span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;192.168.1.12&#x27;</span>, </span><br><span class="line">    port=<span class="number">3308</span>, </span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>, </span><br><span class="line">    password=<span class="string">&#x27;123456&#x27;</span>, </span><br><span class="line">    db=<span class="string">&#x27;test&#x27;</span>, </span><br><span class="line">    charset=<span class="string">&#x27;utf8&#x27;</span>, </span><br><span class="line">    cursorclass=pymysql.cursors.DictCursor</span><br><span class="line">) </span><br><span class="line"></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor: </span><br><span class="line">    sql = <span class="string">&quot;select id,username,password from user&quot;</span> </span><br><span class="line">    cursor.execute(sql) </span><br><span class="line">    result = cursor.fetchall()</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dict</span> <span class="keyword">in</span> result: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;ID: <span class="subst">&#123;<span class="built_in">dict</span>[<span class="string">&#x27;id&#x27;</span>]&#125;</span>, 用户名: <span class="subst">&#123;<span class="built_in">dict</span>[<span class="string">&#x27;username&#x27;</span>]&#125;</span>, 密码: <span class="subst">&#123;<span class="built_in">dict</span>[<span class="string">&#x27;password&#x27;</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python正则表达式</title>
    <url>/2024/02/23/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="什么是正则表达式">什么是正则表达式</h2>
<p>正则表达式是对字符串操作的一种逻辑方式，就是用实现定义好的一些特定字符及这些特定字符的组 合，组成一个规则字符串，这个规则字符串就是表达对字符串的逻辑，给定一个正则表达式和另一个 字符串，通过正则表达式从字符串我们想要的部分。</p>
<h2 id="re-标准库">re 标准库</h2>
<p>Python正则表达式主要由re标准库提供，拥有了基本所有的表达式。</p>
<p><img src="/images/8691DBE21A7C46D189E5B0FC625F0DA8clipboard.png" alt></p>
<p>语法：re.compile(pattern, flags=0)</p>
<p>pattern 指的是正则表达式。flags是标志位的修饰符，用于控制表达式匹配模式</p>
<p>示例1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">&quot;this is test string&quot;</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;this&#x27;</span>)</span><br><span class="line">result = pattern.<span class="keyword">match</span>(s)</span><br><span class="line"><span class="built_in">print</span>(result.group())   </span><br><span class="line"><span class="comment">#匹配成功后，result对象会增加一个group()</span></span><br><span class="line">方法，可以用它来获取匹配结果</span><br></pre></td></tr></table></figure>
<p>语法：re.match(pattern, string, flags=0)</p>
<p>示例2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = re.<span class="keyword">match</span>(<span class="string">&#x27;this&#x27;</span>, s) </span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br></pre></td></tr></table></figure>
<p>小结：案例1好处是先使用compile把正则表达式编译一个对象， 方便再次使用。案例2更直观。</p>
<h2 id="代表字符">代表字符</h2>
<p><img src="/images/A608A62811C34CB9A4FC5DAFD05F467Aclipboard.png" alt></p>
<p>“r”表示原始字符串，有了它，字符串里的特殊意义符号就会自动加转义符。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;123\\abc&quot;</span></span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">r&quot;123\\abc&quot;</span>, s)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<h2 id="代表数量">代表数量</h2>
<p><img src="/images/F43A13B2F06C463CB6D9D99188BDE03Dclipboard.png" alt></p>
<h2 id="代表边界">代表边界</h2>
<p><img src="/images/A89C411A460E43E4B054AF100AB9656Dclipboard.png" alt></p>
<h2 id="代表分组">代表分组</h2>
<p><img src="/images/719D56BC81E3494A8A599464FE776B3Cclipboard.png" alt></p>
<h2 id="贪婪模式与非贪婪模式">贪婪模式与非贪婪模式</h2>
<p>贪婪模式：尽可能最多匹配</p>
<p>非贪婪模式：尽可能最少匹配，一般在量词（*、+）后面加个？问号就是非贪婪模式。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;hello 666666&quot;</span></span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">&quot;hello 6+&quot;</span>, s)  <span class="comment"># 贪婪匹配</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">&quot;hello 6+?&quot;</span>, s)  <span class="comment"># 非贪婪匹配</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<h2 id="re-标准库其他方法">re 标准库其他方法</h2>
<p><img src="/images/5288A68849DF4CD8B5FA2AEFB840C052clipboard.png" alt></p>
<h2 id="标志位">标志位</h2>
<p><img src="/images/7E76E0FB679E48F7B68244DCED142CA3clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python流程控制</title>
    <url>/2024/02/15/python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="条件判断">条件判断</h2>
<p><img src="/images/3CECF864F90649F798C7B990481516F0clipboard.png" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">语法： </span><br><span class="line"><span class="keyword">if</span> &lt;表达式&gt;: </span><br><span class="line">    &lt;代码块&gt; </span><br><span class="line"><span class="keyword">elif</span> &lt;表达式&gt;: </span><br><span class="line">    &lt;代码块&gt; </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    &lt;代码块&gt;</span><br></pre></td></tr></table></figure>
<h3 id="条件判断：单分支">条件判断：单分支</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">示例：判断是否成年 </span><br><span class="line">age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄: &quot;</span>)) </span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span>: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恭喜，你已经成年！&quot;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;抱歉，你还未成年！&quot;</span>)</span><br><span class="line">    </span><br><span class="line">简写，也成三目表达式： <span class="string">&quot;恭喜，你已经成年！&quot;</span> <span class="keyword">if</span> age &gt; <span class="number">18</span> <span class="keyword">else</span> <span class="string">&quot;抱歉，你还未成年！&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="条件判断：多分支">条件判断：多分支</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">示例：根据人的年龄段划分 </span><br><span class="line">age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄: &quot;</span>)) </span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">7</span> : </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;儿童&quot;</span>) </span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">7</span> <span class="keyword">and</span> age &lt; <span class="number">17</span>: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;少年&quot;</span>) </span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span> <span class="keyword">and</span> age &lt; <span class="number">40</span>: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;青年&quot;</span>) </span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">41</span> <span class="keyword">and</span> age &lt; <span class="number">48</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;壮年&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;老年&quot;</span>)   </span><br></pre></td></tr></table></figure>
<h2 id="循环语句">循环语句</h2>
<p>在了解编程中的“循环”之前，先试想下这个场景： 在阳台种花，准备种4颗种子，开始逐个挖坑，放一颗种子。</p>
<p><img src="/images/4451617D17494398966292B8E7561286clipboard.png" alt></p>
<p>每一颗种子操作都是相同的，如果我们用一步将6颗 种子重复种下的行为表示出来呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始种花第%s次&quot;</span> %n)</span><br></pre></td></tr></table></figure>
<p>循环的作用在于将一段代码重复执行多次。</p>
<p>Python中实现循环常用有两个语句：for、while</p>
<h3 id="for语句">for语句</h3>
<p><img src="/images/72ED67ACAC454F2C9E57C28B567C2BE8clipboard.png" alt></p>
<p>for语句：一般用于遍历数据类型的元素进行处理，例如字符串、列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">语法： </span><br><span class="line"><span class="keyword">for</span> &lt;变量&gt; <span class="keyword">in</span> &lt;序列&gt;: </span><br><span class="line">    &lt;代码块&gt;</span><br></pre></td></tr></table></figure>
<p>示例1：遍历字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;123456&quot;</span> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s: </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>示例2：遍历列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">computer = [<span class="string">&quot;主机&quot;</span>,<span class="string">&quot;显示器&quot;</span>,<span class="string">&quot;鼠标&quot;</span>,<span class="string">&quot;键盘&quot;</span>] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> computer: </span><br><span class="line">    <span class="built_in">print</span>(i,<span class="built_in">len</span>(i))</span><br></pre></td></tr></table></figure>
<p>示例3：遍历字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">computer = &#123;<span class="string">&quot;主机&quot;</span>:<span class="number">5000</span>,<span class="string">&quot;显示器&quot;</span>:<span class="number">1000</span>,<span class="string">&quot;鼠标&quot;</span>:<span class="number">60</span>,<span class="string">&quot;键盘&quot;</span>:<span class="number">150</span>&#125; </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> computer.items(): </span><br><span class="line">    <span class="built_in">print</span>(i) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;名称: %s\t价格: %s&quot;</span> % (i[<span class="number">0</span>],i[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p>示例4：嵌套循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">&quot;123456&quot;</span> </span><br><span class="line">s2 = <span class="string">&quot;456789&quot;</span> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s1: </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> s2: </span><br><span class="line">        <span class="keyword">if</span> i == x: </span><br><span class="line">            <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>range()内建函数：动态生成数字序列，例如range(1,6)，结果类似列表[1,2,3,4,5,6]</p>
<p>示例：生成0-4序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<h3 id="while语句">while语句</h3>
<p><img src="/images/B1C32BE1841D48409AAD106DD836A629clipboard.png" alt></p>
<p>while语句：在某条件下循环执行一段代码，即重复相同的任务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">语法： </span><br><span class="line"><span class="keyword">while</span> &lt;表达式&gt;: </span><br><span class="line">    &lt;代码块&gt;</span><br></pre></td></tr></table></figure>
<p>示例1：当条件满足时停止循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span> </span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>: </span><br><span class="line">    <span class="built_in">print</span>(count) </span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>示例2：死循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">    <span class="built_in">print</span>(count) </span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="continue与break语句">continue与break语句</h3>
<p>continue 当满足条件时，跳出本次循环</p>
<p>break 当满足条件时，跳出所有循环</p>
<p>注：只有在for、while循环语句中才有效。</p>
<p>示例1：continue</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>): </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span>: </span><br><span class="line">        <span class="keyword">continue</span> </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>
<p>示例2：break</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>): </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span>: </span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>
<h3 id="综合案例：用户登录，三次错误机会">综合案例：用户登录，三次错误机会</h3>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> count &lt; <span class="number">3</span>:</span><br><span class="line">        username = <span class="built_in">input</span>(<span class="string">&#x27;请输入你的用户名：&#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(username) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;用户名不能为空&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> username == <span class="string">&#x27;azhe&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;输入错误，请重新输入&#x27;</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;输入错误次数过多，请稍候输入&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python类-面向对象</title>
    <url>/2024/02/20/python%E7%B1%BB-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="什么是面向对象编程？">什么是面向对象编程？</h2>
<p>面向过程编程：是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程。</p>
<p>面向对象编程：是一种计算机编程架构，以对象为中心的编程思想，对现实世界理解和抽象的方法。</p>
<p><img src="/images/0DB7B02658B544BD9AF8AFD4D040C24Fclipboard.png" alt></p>
<p>类、对象它们之间的关系：</p>
<ul>
<li>
<p>类：类是对现实生活中一类具有共同特征的事物的抽象描述。例如电脑类、空调类、人类</p>
</li>
<li>
<p>对象：类的实体，实际存在的事物，例如电脑类的“主机”、“显示器”</p>
</li>
<li>
<p>类与对象的关系：类是由对象来定，这个过程叫做抽象化。用类创建对象，这个过程称为实例化</p>
</li>
</ul>
<p>类的其他特点：</p>
<ul>
<li>
<p>封装：把相同对象的功能（函数）、属性（变量）组合在一起</p>
</li>
<li>
<p>方法：对象的功能（例如电脑能上网、看片），实际在类里面就是函数，称为成员函数，也可以称为方法</p>
</li>
<li>
<p>属性：对象的特征（例如电脑都有主机、显示器）</p>
</li>
<li>
<p>实例化：用类创建对象，这个对象具体是什么东西，例如你用的电脑、我这个人</p>
</li>
</ul>
<h2 id="类的定义">类的定义</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用<span class="keyword">class</span>关键字定义类： </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>(): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">funcName</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">电脑（类）： </span><br><span class="line">    特征（属性）：主机，显示器，键盘，鼠标… </span><br><span class="line">        host = <span class="string">&quot;4C8G&quot;</span> </span><br><span class="line">        displayer = <span class="string">&quot;27寸&quot;</span> </span><br><span class="line">        keyboard = <span class="string">&quot;机械键盘&quot;</span> </span><br><span class="line">        mouse = <span class="string">&quot;无线鼠标&quot;</span> </span><br><span class="line">    功能（方法）：办公，上网，看片… </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">office</span>(): </span><br><span class="line">        办公 </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">internet</span>(): </span><br><span class="line">        上网 </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">movies</span>(): </span><br><span class="line">        玩游戏 </span><br><span class="line">    …</span><br></pre></td></tr></table></figure>
<h2 id="类的书写规范">类的书写规范</h2>
<p>示例：定义一个电脑类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>(): </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">    电脑类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span> </span><br><span class="line">    <span class="comment"># 属性 </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): </span><br><span class="line">        self.host = <span class="string">&quot;4C8G&quot;</span> </span><br><span class="line">        self.displayer = <span class="string">&quot;27寸&quot;</span> </span><br><span class="line">        self.keyboard = <span class="string">&quot;机械键盘&quot;</span> </span><br><span class="line">        self.mouse = <span class="string">&quot;无线鼠标&quot;</span> </span><br><span class="line">    <span class="comment"># 方法 </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">office</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;办公&quot;</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">internet</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;上网&quot;</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">movies</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;看片&quot;</span></span><br></pre></td></tr></table></figure>
<p>类的书写规范：</p>
<ul>
<li>
<p>类一般采用大驼峰命名，例如MyClass</p>
</li>
<li>
<p>类注释，用于说明该类的用途，提高可阅读性</p>
</li>
<li>
<p>类中只存在两种数据：属性和方法</p>
</li>
<li>
<p>声明属性必须赋值</p>
</li>
<li>
<p>声明方法的第一个参数必须是self，其他与普通函数一样</p>
</li>
<li>
<p>一般会使用__init__方法给类指定的初始状态属性</p>
</li>
</ul>
<h2 id="类实例化">类实例化</h2>
<p>通常称为：</p>
<ul>
<li>
<p>实例化：用类创建对象的过程</p>
</li>
<li>
<p>类实例：用类创建对象</p>
</li>
<li>
<p>实例属性：对象的属性</p>
</li>
<li>
<p>实例方法：对象调用的方法</p>
</li>
</ul>
<p>示例：</p>
<p>pc = Computer() # 类实例化，</p>
<p>pc是类实例 print(pc.host) # 访问类属性，查看电脑配置</p>
<p>print(pc.movies()) # 访问类方法，让电脑做事</p>
<h2 id="初始化函数">初始化函数</h2>
<p>示例：让某个人使用电脑做事</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>(): </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">    电脑类 </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">     <span class="comment"># 属性 </span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>): </span><br><span class="line">         self.host = <span class="string">&quot;4C8G&quot;</span> </span><br><span class="line">         self.displayer = <span class="string">&quot;27寸&quot;</span> </span><br><span class="line">         self.keyboard = <span class="string">&quot;机械键盘&quot;</span> </span><br><span class="line">         self.mouse = <span class="string">&quot;无线鼠标&quot;</span> </span><br><span class="line">         self.name = name </span><br><span class="line">     <span class="comment"># 方法 </span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">office</span>(<span class="params">self</span>): </span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;%s在办公&quot;</span> %self.name </span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">internet</span>(<span class="params">self</span>): </span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;%s在上网&quot;</span> %self.name </span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">movies</span>(<span class="params">self</span>): </span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;%s在看片&quot;</span> %self.name </span><br><span class="line">         </span><br><span class="line">zhangsan = Computer(<span class="string">&quot;张三&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(zhangsan.office()) </span><br><span class="line">lisi = Computer(<span class="string">&quot;李四&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(lisi.movies())</span><br></pre></td></tr></table></figure>
<p>示例：初始化函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calc</span>(): </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;计算器类&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num1, num2</span>): </span><br><span class="line">        self.num1 = num1 </span><br><span class="line">        self.num2 = num2 </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jia</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">return</span> self.num1 + self.num2 </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jian</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">return</span> self.num1 - self.num2 </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cheng</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">return</span> self.num1 * self.num2 </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">chu</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">return</span> self.num1 / self.num2 </span><br><span class="line">        </span><br><span class="line">calc = Calc(<span class="number">6</span>, <span class="number">6</span>) </span><br><span class="line"><span class="built_in">print</span>(calc.jia())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Service(对外暴露你的应用）</title>
    <url>/2022/06/17/service%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Service是什么与Service存在的意义">Service是什么与Service存在的意义</h2>
<p>Service引入主要是解决Pod的动态变化，提供统一访问入口：</p>
<ul>
<li>
<p>防止Pod失联，准备找到提供同一个服务的Pod（服务发现）</p>
</li>
<li>
<p>定义一组Pod的访问策略（负载均衡）</p>
</li>
</ul>
<p><img src="/images/46FCA6D1D1DE4CB1BF7404E3E644AB9Bclipboard.png" alt></p>
<h3 id="Pod与Service的关系">Pod与Service的关系</h3>
<ul>
<li>
<p>Service通过标签关联一组Pod</p>
</li>
<li>
<p>Service使用iptables或者ipvs为一组Pod提供负载均衡能力</p>
</li>
</ul>
<p><img src="/images/D28365050B2C4212BD3B918D4E543123clipboard.png" alt></p>
<h3 id="Service定义与创建">Service定义与创建</h3>
<p>vim service.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建service： </span></span><br><span class="line">kubectl apply -f service.yaml </span><br><span class="line"><span class="comment">#查看service： </span></span><br><span class="line">kubectl get service</span><br><span class="line"><span class="comment">#查看service关联一组pod的IP</span></span><br><span class="line">kubectl get endpoints</span><br></pre></td></tr></table></figure>
<h2 id="Service三种类型">Service三种类型</h2>
<ul>
<li>
<p>ClusterIP：集群内部使用</p>
</li>
<li>
<p>NodePort：对外暴露应用（集群外）</p>
</li>
<li>
<p>LoadBalancer：对外暴露应用，适用公有云</p>
</li>
</ul>
<p>ClusterIP：默认，分配一个稳定的IP地址，即VIP，只能在集群内部访问。</p>
<p>vim service.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service.yaml </span><br><span class="line">kubectl get svc</span><br><span class="line">curl 10.107.214.48    <span class="comment">#访问集群内部暴露的service的IP及端口</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/4BC1CA5B289A4AABB644197644BFCF13clipboard.png" alt></p>
<p><img src="/images/57A69C2E53F6499B858D3C247528F7B3clipboard.png" alt></p>
<p>NodePort：在每个节点上启用一个端口来暴露服务，可以在集群 外部访问。也会分配一个稳定内部集群IP地址。 访问地址：&lt;任意NodeIP&gt;: 端口范围：30000-32767</p>
<p>vim service-node.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">    nodePort: 30009    <span class="comment">#nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service-node.yaml </span><br><span class="line">kubectl get svc</span><br><span class="line">http://192.168.1.12:30009/  <span class="comment">#访问集群外部节点IP以及暴露的端口</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/9D738F0AF4584DA38F71D1BC618DE8ACclipboard.png" alt></p>
<p><img src="/images/160A670AE9A44000B53A589FE400605Bclipboard.png" alt></p>
<p>NodePort：会在每台Node上监听端口接收用户流量，在实际情 况下，对用户暴露的只会有一个IP和端口，那这么多台Node该使 用哪台让用户访问呢？</p>
<p>这时就需要前面加一个公网负载均衡器为项目提供统一访问入口了。</p>
<p><img src="/images/D7C5CA3D9A9F4C41BD5E5FFDC2AF08F4clipboard.png" alt></p>
<p>负载均衡器：</p>
<ul>
<li>
<p>开源：nginx、lvs、haproxy</p>
</li>
<li>
<p>公有云：SLB</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream demo &#123;</span><br><span class="line">	server 192.168.0.11:30008;</span><br><span class="line">	server 192.168.0.12:30008;</span><br><span class="line">&#125;</span><br><span class="line">upstream demo2 &#123;</span><br><span class="line">	server 192.168.0.13:30009;</span><br><span class="line">	server 192.168.0.14:30009;</span><br><span class="line">&#125;</span><br><span class="line">upstream demo3 &#123;</span><br><span class="line">	server 192.168.0.15:30010;</span><br><span class="line">	server 192.168.0.16:30010;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	server_name a.xxx.com;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://demo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	server_name b.xxx.com;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://demo2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	server_name c.xxx.com;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://demo3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadBalancer：与NodePort类似，在每个节点上启用一个端口来暴 露服务。除此之外，Kubernetes会请求底层云平台（例如阿里云、腾 讯云、AWS等）上的负载均衡器，将每个Node （[NodeIP]:[NodePort]）作为后端添加进去。</p>
<p><img src="/images/57137C13B9A640EE8D7C367E149ADB23clipboard.png" alt></p>
<h2 id="Service代理模式">Service代理模式</h2>
<p>Service的底层实现主要有iptables和ipvs二种网络模式，决定了如何转发流量</p>
<p><img src="/images/45B9E4A9C42543FFAE1E1DBF9241EFDEclipboard.png" alt></p>
<p>基于iptables实现负载均衡的一个过程</p>
<p>1、在浏览器访问 <a href="http://192.168.0.11:30009/">http://192.168.0.11:30009/</a></p>
<p>2.数据包经过iptables规则匹配，重定向到另一个链KUBE-SVC-LOLE4ISW44XBNF3G</p>
<p>-A KUBE-NODEPORTS -p tcp -m comment --comment “default/web” -m tcp --dport 30009 -j KUBE-SVC-LOLE4ISW44XBNF3G</p>
<p><img src="/images/A0F68B2B033F444B8146083059B79962clipboard.png" alt></p>
<p>3.一组规则，有几个pod就会创建几条规则，这里实现了负载均衡 （概率1/3，1/2，1）</p>
<p>-A KUBE-SVC-LOLE4ISW44XBNF3G -m comment --comment “default/web” -m statistic --mode random --probability 0.33333333349 -j KUBE-SEP-PXRBKXV7I65SLLDB</p>
<p>-A KUBE-SVC-LOLE4ISW44XBNF3G -m comment --comment “default/web” -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-4MXWCRSI3HRHILKZ</p>
<p>-A KUBE-SVC-LOLE4ISW44XBNF3G -m comment --comment “default/web” -j KUBE-SEP-ODUGDMBPYLOH457E</p>
<p><img src="/images/1423425BFBBC4CF7B8B6547BDB6AA417clipboard.png" alt></p>
<p>4.使用DNAT转发到具体的pod</p>
<p>-A KUBE-SEP-PXRBKXV7I65SLLDB -p tcp -m comment --comment “default/web” -m tcp -j DNAT --to-destination 10.244.169.133:80</p>
<p><img src="/images/94448BF326BD473983D7823BCE74D6A2clipboard.png" alt></p>
<p>-A KUBE-SEP-4MXWCRSI3HRHILKZ -p tcp -m comment --comment “default/web” -m tcp -j DNAT --to-destination 10.244.36.67:80</p>
<p><img src="/images/2DC4797D7765429D852EBB7A5E6C32EEclipboard.png" alt></p>
<p>-A KUBE-SEP-ODUGDMBPYLOH457E -p tcp -m comment --comment “default/web” -m tcp -j DNAT --to-destination 10.244.36.68:80</p>
<p><img src="/images/31B2F70ADDAD4CA3AED602FECACBBC56clipboard.png" alt></p>
<p>针对ClusterIP实现的转发，后面与nodeport一样，回到了上面的第三步</p>
<p>-A KUBE-SERVICES -d 10.109.90.58/32 -p tcp -m comment --comment “default/web cluster IP” -m tcp --dport 80 -j KUBE-SVC-LOLE4ISW44XBNF3G</p>
<p><img src="/images/3CC81396D80F4171A1FDACC13E9C54D8clipboard.png" alt></p>
<p>kubeadm方式修改ipvs模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl edit configmaps kube-proxy -n kube-system </span><br><span class="line"><span class="comment">#搜索mode，添加ipvs，修改完保存</span></span><br><span class="line">  mode: <span class="string">&quot;ipvs&quot;</span></span><br><span class="line"><span class="comment">#删除node1节点proxy的pod,重新生成新的pod</span></span><br><span class="line">kubectl delete pod kube-proxy-lzjgg -n kube-system </span><br><span class="line">kubectl get pod -o wide -n kube-system </span><br><span class="line">kubectl logs kube-proxy-hnw5p -n kube-system </span><br></pre></td></tr></table></figure>
<p><img src="/images/A3F8D2A415C546398858681A0512333Dclipboard.png" alt></p>
<p>注： 1、kube-proxy配置文件以configmap方式存储 2、如果让所有节点生效，需要重建所有节点kube-proxy pod</p>
<p>在node1节点上安装ipvsadm工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install ipvsadm</span><br><span class="line">ipvsadm -L -n</span><br></pre></td></tr></table></figure>
<p><img src="/images/9ECAC01183284036B4DFF293FB29FA02clipboard.png" alt></p>
<p>ip a</p>
<p><img src="/images/C1397ED986B04C628380BEFC3B50A968clipboard.png" alt></p>
<p>二进制方式修改ipvs模式：</p>
<p>vi kube-proxy-config.yml</p>
<p>mode: ipvs</p>
<p>ipvs:</p>
<p>scheduler: &quot;rr“</p>
<p>systemctl restart kube-proxy</p>
<p>注：参考不同资料，文件名可能不同</p>
<p>流程包流程：客户端 -&gt;NodePort/ClusterIP（iptables/Ipvs负载均衡规则） -&gt; 分布在各节点Pod</p>
<p>查看负载均衡规则：</p>
<ul>
<li>iptables模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-save |grep </span><br></pre></td></tr></table></figure>
<ul>
<li>ipvs模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -L -n</span><br></pre></td></tr></table></figure>
<p><img src="/images/48DCC6F8FF224A899C3AF23FC8AD0B8Eclipboard.png" alt></p>
<p>当一个客户端访问service的时候，经过iptables/ipvs进行负载均衡，负载到后端的pod上，iptables/ipvs的规则是由kube-proxy去创建的。</p>
<p>当出现问题的时候，应该先检查的service的配置的是不是对的（标签端口等等），再检查kube-proxy是不是正常的，有没有创建对应的iptables/ipvs规则。</p>
<h2 id="Service-DNS名称">Service DNS名称</h2>
<p>CoreDNS：是一个DNS服务器，Kubernetes默认采用，以Pod部署在集群中，CoreDNS服 务监视Kubernetes API，为每一个Service创建DNS记录用于域名解析。</p>
<p>CoreDNS YAML文件：</p>
<p><a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dns/coredns">https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dns/coredns</a></p>
<p>ClusterIP A记录格式：<service-name>.<namespace-name>.svc.cluster.local</namespace-name></service-name></p>
<p>示例：my-svc.my-namespace.svc.cluster.local</p>
<p><img src="/images/ECF12D7CD8F145629E5BF72FD6A79F77clipboard.png" alt></p>
<p><img src="/images/4C475116BD954880B84C0AD18D7301A2clipboard.png" alt></p>
<p>当我们在pod内做nslookup(dns)解析时，它会请求coredns pod，coredns里面存放了从k8smaster中获取的service对应的dns记录，就会帮你解析成对应service的IP。</p>
<p>Iptables VS IPVS</p>
<p>Iptables：</p>
<ul>
<li>
<p>灵活，功能强大</p>
</li>
<li>
<p>规则遍历匹配和更新，呈线性时延</p>
</li>
</ul>
<p>IPVS：</p>
<ul>
<li>
<p>工作在内核态，有更好的性能</p>
</li>
<li>
<p>调度算法丰富：rr，wrr，lc，wlc，ip hash…</p>
</li>
</ul>
<p>生产环境建议使用IPVS</p>
<p>1、创建一个deployment 副本数 3，然后滚动更新镜像版本，并记录这个更新记录，最后再回滚到上一个版本</p>
<p>vim web-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: nginx:1.15</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web-deployment.yaml </span><br><span class="line"><span class="comment">#通过命令更新镜像，指定--record参数会将这条命令记录到历史版本记录中，方便回滚到对应的版本</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deploy web-deployment web=nginx:1.16 --record  </span><br><span class="line">kubectl get pod -o wide</span><br><span class="line">curl  -I10.244.169.140   <span class="comment">#验证是否是nginx1.16版本</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment web-deployment  <span class="comment">#查看历史版本记录</span></span><br><span class="line">kubectl rollout undo deployment web-deployment  <span class="comment">#默认回滚到上一个版本</span></span><br><span class="line">kubectl get pod -o wide    <span class="comment">#查看pod的IP</span></span><br><span class="line">curl -I 10.244.36.76   <span class="comment">#验证是否回滚到nginx1.15版本</span></span><br></pre></td></tr></table></figure>
<p>2、给一个应用扩容副本数为3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment web-deployment --replicas=6</span><br><span class="line">kubectl get pod </span><br></pre></td></tr></table></figure>
<p>3、创建一个pod，其中运行着nginx、redis、memcached 3个容器</p>
<p>vim nginx-redis-memcached.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-redis-memcached</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">      containers:</span><br><span class="line">      - name: redis</span><br><span class="line">        image: redis</span><br><span class="line">      containers:</span><br><span class="line">      - name: memcached</span><br><span class="line">        image: memcached</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-redis-memcached.yaml </span><br><span class="line">kubectl get pod</span><br><span class="line">kubectl <span class="built_in">exec</span> -it web-deployment-7c6bf5fdf8-8m2gm nginx -- bash</span><br><span class="line">kubectl <span class="built_in">exec</span> -it web-deployment-7c6bf5fdf8-8m2gm redis -- bash</span><br><span class="line">kubectl <span class="built_in">exec</span> -it web-deployment-7c6bf5fdf8-8m2gm memcached -- bash</span><br></pre></td></tr></table></figure>
<p>4、给一个pod创建service，并可以通过ClusterIP/NodePort访问</p>
<p>vim service-node.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">    nodePort: 30009    <span class="comment">#nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service-node.yaml </span><br><span class="line">kubectl get svc</span><br><span class="line">curl  -I 10.105.40.240   <span class="comment">#访问集群内部service IP</span></span><br><span class="line">http://192.168.0.12:30009/    <span class="comment">#访问任意node节点IP加30009端口</span></span><br></pre></td></tr></table></figure>
<p>5、创建deployment和service，使用busybox容器nslookup解析service</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run -it dns-test --image=busybox -- sh</span><br></pre></td></tr></table></figure>
<p><img src="/images/810CBA00E6294D12A8014902A6EC2B6Fclipboard.png" alt></p>
<p>注：自由发挥，实现需求即可</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 常用指令</title>
    <url>/2024/06/02/vue%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="指令介绍">指令介绍</h2>
<p>指令：带有v-前缀的特殊属性。</p>
<p>指令的作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM。</p>
<h2 id="v-text">v-text</h2>
<p>v-text作用与双大花括号作用一样，将数据填充到标签中。但没有闪烁问题！</p>
<p><img src="/images/ABA979BF052B46B69C77D1F31852FAE2clipboard.png" alt></p>
<h2 id="v-html">v-html</h2>
<p>某些情况下，从服务端请求的数据本身就是一个HTML代码，如果用双大括号会将数据解 释为普通文本，而非HTML代码，为了输出真正的HTML，需要使用v-html指令：</p>
<p><img src="/images/DF8B982A036945288AFE2BFFE3125916clipboard.png" alt></p>
<h2 id="v-on">v-on</h2>
<p>在前端开发中，我们经常监听用户发生的事件，例如点击、拖拽、键盘事件等。 在Vue中如何监听事件呢？使用v-on指令</p>
<p>示例：监听按钮的点击事件</p>
<p><img src="/images/D93ADECB822D46438C965AD7BB9AD340clipboard.png" alt></p>
<ul>
<li>v-on: 冒号后面是event参数，例如click、change</li>
</ul>
<h2 id="v-bind">v-bind</h2>
<p>v-bind：用于动态绑定一个或多个属性值，或者向另一个组件传递props值（这个后面再介绍）</p>
<p>应用场景：图片地址src、超链接href、动态绑定一些类、样式等等</p>
<h3 id="v-bind：绑定超链接">v-bind：绑定超链接</h3>
<p>示例：响应式地更新HTML 属性</p>
<p><img src="/images/D88777C6B9D54060BFDF3D62827BDF13clipboard.png" alt></p>
<ul>
<li>
<p>v-bind 指令后接收一个参数，以冒号分割。</p>
</li>
<li>
<p>v-bind 指令将该元素的href 属性与表达式url 的值绑定。</p>
</li>
</ul>
<h3 id="v-bind：绑定Class">v-bind：绑定Class</h3>
<p>操作元素（标签）的class 和style属性是数据绑 定的一个常见需求。</p>
<p>例如希望动态切换class，为div显示不同背景颜色</p>
<p>示例：给已有的div动态绑定一个class</p>
<p><img src="/images/ADC3E480F0C24E908EB0A8B958DBFF85clipboard.png" alt></p>
<p>参考文档： <a href="https://v3.cn.vuejs.org/guide/class-and-style.html">https://v3.cn.vuejs.org/guide/class-and-style.html</a></p>
<h3 id="v-bind：绑定Style">v-bind：绑定Style</h3>
<p>v-bind:style 的对象语法看着非常像CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式(camelCase) 或短横线分隔(kebab-case，记得用引号括起来) 来命名。</p>
<p>示例：给已有的div动态绑定一个style</p>
<p><img src="/images/0FF0A1E3D6B7469085F719CED6242DFAclipboard.png" alt></p>
<p>直接绑定到一个样式对象通常更好，这会让模板更清晰：</p>
<p><img src="/images/69E780729B6E440D9B72C0ACFBCD5800clipboard.png" alt></p>
<h2 id="指令缩写">指令缩写</h2>
<p>v- 前缀作为一种视觉提示，用来识别模板中Vue 特定的属性。</p>
<p>但对于一些频繁用到的指令来说，就会感到使用繁琐。</p>
<p>因此，Vue 为v-bind 和 v-on 这两个最常用的指令，提供了特定简写：</p>
<p><img src="/images/6ABFBD3ADA334D08B2834C180F91595Aclipboard.png" alt></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 常用属性</title>
    <url>/2024/06/03/vue%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="数据属性">数据属性</h2>
<p>组件的data 选项是一个函数。Vue 会在创建新组件实例的过程中调用此函数。它应该返 回一个对象，然后Vue 会通过响应性系统将其包裹起来，并以$data 的形式存储在组件实 例中。为方便起见，该对象的任何顶级“属性”也会直接通过组件实例暴露出来：</p>
<p><img src="/images/C48718674B744FDF9197F05A007F48DDclipboard.png" alt></p>
<p>参考文档： 相等 <a href="https://v3.cn.vuejs.org/guide/data-methods.html#data-property">https://v3.cn.vuejs.org/guide/data-methods.html#data-property</a></p>
<h2 id="方法">方法</h2>
<p>方法（methods）：处理数据的函数。在methods选项中定义的函数称为方法。</p>
<p>示例：添加方法及调用</p>
<p><img src="/images/7FF244B0B7F249F58C007FCFE25686BCclipboard.png" alt></p>
<p>在methods选项中定义的方法与data选项中的数据一样，可以在组件的模板中使用。</p>
<p>在模板中，它们通常被当做事件监听使用：</p>
<p><img src="/images/16CAB88248FC423593F0E6DFD25CAE7Dclipboard.png" alt></p>
<h2 id="计算属性">计算属性</h2>
<p>计算属性（computed）：根据所依赖的数据动态显示新的计算结果。</p>
<p>示例：需要在双花括号里添加计算再展示数据，例如统计分数</p>
<p><img src="/images/5CCA9A6B73854378B5B558636BABEA02clipboard.png" alt></p>
<p>使用computed：</p>
<p><img src="/images/09FFB136B2E6433F88E85406E893ED65clipboard.png" alt></p>
<p>小结：计算属性一般就是用来通过其他的数据算出一个新数据，而且它有一个好处就是， 它把新的数据缓存下来了，当其他的依赖数据没有发生改变，它调用的是缓存的数据，这 就极大的提高了我们程序的性能。而如果写在methods里，数据根本没有缓存的概念，所 以每次都会重新计算。这也是为什么不用methods的原因！</p>
<h2 id="监听属性">监听属性</h2>
<p>监听属性（watch）：是一个观察动作，监听data数 据变化后触发对应函数，函数有newValue（变化之后 结果）和oldValue（变化之前结果）两个参数。 当需要在数据变化时执行异步或开销较大的操作时， 这个方式是最有用的。</p>
<p>示例：监听变化</p>
<p><img src="/images/8388D75514DB4F4AAA08907D7DF29A52clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vuecli 脚手架</title>
    <url>/2024/06/07/vuecli%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="Vue-Cli-脚手架介绍">Vue Cli 脚手架介绍</h2>
<p>到目前为止，已经会了Vue基本使用，但这种在HTML引用Vue.js的方式，简单的页面还是没问题 的，如果用Vue开发整个前端项目，组建Vue项目结构及配置还是比较复杂的，例如引入各种js文 件、打包上线等。因此，为了提高开发效率，官方开发了VueCli脚手架快捷搭建开发环境。</p>
<p>Vue CLI 是一个基于Vue.js 进行快速开发的完整系统，提供：</p>
<ul>
<li>
<p>通过@vue/cli 实现的交互式的项目脚手架。</p>
</li>
<li>
<p>通过@vue/cli + @vue/cli-service-global 实现的零配置原型开发。</p>
</li>
<li>
<p>一个运行时依赖(@vue/cli-service)，该依赖：</p>
</li>
<li>
<p>可升级；</p>
</li>
<li>
<p>基于webpack 构建，并带有合理的默认配置；</p>
</li>
<li>
<p>可以通过项目内的配置文件进行配置；</p>
</li>
<li>
<p>可以通过插件进行扩展。</p>
</li>
<li>
<p>一个丰富的官方插件集合，集成了前端生态中最好的工具。</p>
</li>
<li>
<p>一套完全图形化的创建和管理Vue.js 项目的用户界面。</p>
</li>
</ul>
<p>Vue CLI 致力于将Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配</p>
<p>置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。</p>
<h2 id="认识NPM">认识NPM</h2>
<p>在使用Vue Cli之前，需先了解一些关于NPM的知识点：</p>
<ul>
<li>
<p>NPM（Node Package Manager，Node包管理器），存放JavaScript代码共享中心，是目 前最大的JavaScript仓库。类似于Linux yum仓库。</p>
</li>
<li>
<p>可能你会联想到Node.js，Node.js是服务端的JavaScript，类似于Gin、Django，NPM是基 于Node.js开发的软件。</p>
</li>
<li>
<p>随着Node.js兴起，生态圈的JS库都纷纷向NPM官方仓库发布，所以现在，大都是使用npm install命令来安装JS库，而不必再去它们官网下载了。</p>
</li>
</ul>
<p>安装Node.js，默认已经内置npm，下载对应软件包直接安装即可。<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p>
<p><img src="/images/0159F6872B874F44B8F43190A199DAA0clipboard.png" alt></p>
<p>配置淘宝npm仓库：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org --global </span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>
<h2 id="Vue-Cli-脚手架使用">Vue Cli 脚手架使用</h2>
<p>Vue Cli脚手架使用步骤：</p>
<ol>
<li>
<p>命令安装：npm install -g @vue/cli</p>
</li>
<li>
<p>检查版本：vue -V</p>
</li>
<li>
<p>创建项目：vue create &lt;项目名称&gt;</p>
</li>
<li>
<p>运行项目，访问</p>
</li>
</ol>
<h2 id="项目目录">项目目录</h2>
<p><img src="/images/CB418D4611014555B13297BB1B5E3267clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue常用指令之数据双向绑定</title>
    <url>/2024/06/05/vue%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="v-model">v-model</h2>
<p>双向数据绑定：通过前面学习知道Vue是数据驱动的，数据驱动有一个精髓之处是数据双向绑定， 即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">v-model指令提供表单输入绑定，可以在<span class="tag">&lt;<span class="name">input</span>&gt;</span>、<span class="tag">&lt;<span class="name">textarea</span>&gt;</span> 及<span class="tag">&lt;<span class="name">select</span>&gt;</span> 元素上创建双向数据绑定。</span><br></pre></td></tr></table></figure>
<p><img src="/images/E212615A92064F6DAE1B9903C41FF312clipboard.png" alt></p>
<ul>
<li>v-model指令其实是一个语法糖，背后本质上包含v-bind和v-on两个操作。</li>
</ul>
<p>单选框（radio）：</p>
<p><img src="/images/58E6741EF7BE4903B7889533E3F209A7clipboard.png" alt></p>
<p>多选框（select）：</p>
<p><img src="/images/ED4910AB5A1145009ABE33ADA9AE65B4clipboard.png" alt></p>
<p>登录案例：获取用户输入用户名和密码</p>
<p><img src="/images/A9484073ABB64A309D56CE0008FF099Bclipboard.png" alt></p>
<h2 id="常用指令总结">常用指令总结</h2>
<p><img src="/images/19F20EBE82574358BA4CF6CFB0B21428clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件</title>
    <url>/2024/06/08/vue%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="介绍">介绍</h2>
<p>组件：一段独立的，能代表页面某一个部分的代码片段，拥有自己独立的数据、JavaScript脚本、 以及CSS样式。</p>
<p>组件是可复用的Vue实例，在开发过程中可以把经常重复的功能，封装为组件，达到快捷开发的 目的。</p>
<p>组件的好处：</p>
<ul>
<li>
<p>提高开发效率</p>
</li>
<li>
<p>方便重复使用</p>
</li>
<li>
<p>易于管理和维护</p>
</li>
</ul>
<p>通常一个应用会以一棵嵌套的组件树的形式来组织，如图所 示。</p>
<p>例如，你可能会有页头、侧边栏、内容区等组件，每个组件 又包含了其它的像导航链接、博文之类的组件。</p>
<p><img src="/images/F21DC0DDBB424F56BDC14662618B9C38clipboard.png" alt></p>
<h2 id="文件格式">文件格式</h2>
<p>Vue单文件组件（又名*.vue文件，缩写为SFC）是一种特殊的文件格式，它允许讲Vue组件的模板、逻辑与样式封装在单个文件中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">正如所见，Vue SFC 是经典的HTML、CSS 与JavaScript 三个经典组合的自然延伸。每个*.vue 文件由三种类型的顶层代码块组成：<span class="tag">&lt;<span class="name">template</span>&gt;</span>、<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"> 与 <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-xml">：</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="language-handlebars"></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="language-handlebars">- <span class="tag">&lt;<span class="name">template</span>&gt;</span> 部分定义了组件的模板。</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="language-handlebars"></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="language-handlebars">- <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"> 部分是一个标准的JavaScript 模块。它应该导出一个Vue 组件定义作为其默认导出。</span></span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-xml"><span class="language-handlebars"></span></span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-xml"><span class="language-handlebars">- <span class="tag">&lt;<span class="name">style</span>&gt;</span> 部分定义了与此组件关联的CSS。</span></span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-xml"><span class="language-handlebars"></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<p><img src="/images/C9327FF100D04729949477E00A06AAD1clipboard.png" alt></p>
<h2 id="使用">使用</h2>
<p>使用具体流程：</p>
<p>1、在src/components目录里开发一个组件文件（首字母大写）</p>
<p>2、在父组件里引用子组件import xxx from‘xxx’</p>
<p>3、在默认导出里注册组件</p>
<p>4、在template模板里使用组件</p>
<p><img src="/images/CB37F38D79B4478592BAB8082A901C85clipboard.png" alt></p>
<h2 id="注册">注册</h2>
<p>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类 型：全局注册和局部注册。上述是局部注册，只能在当前模板中使用。</p>
<ul>
<li>
<p>全局注册：声明一次，在任何vue文件模板中使用，一般使用该组件的地方多时使用</p>
</li>
<li>
<p>局部注册：在使用组件的vue文件中声明和使用，一般只需要解耦代码时使用</p>
</li>
</ul>
<p>全局注册：在main.js文件</p>
<p><img src="/images/1522D5007F7E4955BC7422BF8F09CC12clipboard.png" alt></p>
<p>全局注册后，在任意.vue文件里可使用该组件： views/Home.vue</p>
<p><img src="/images/E15162D15C514E0A8516A054B5D8614Dclipboard.png" alt></p>
<h2 id="传参">传参</h2>
<p>学习了组件用法，就像一种嵌套引用关系，在这个关系中，经常会涉及相互传数据的需 求，即父组件传子组件，子组件传父组件。</p>
<p>父、子组件的关系可以总结为：prop 向下传递，事件向上传递。</p>
<p>父组件通过prop 给子组件下发数据，子组件通过事件给父组件发送消息，如右图所示：</p>
<p><img src="/images/AB47C72AF5AD4E36B0174290E3E5774Eclipboard.png" alt></p>
<p>父传子：在默认页面中，也用到了父传子，在父组件Home.vue中给引用 的组件传入一个静态的值，子组件通过props属性接收，并在模板中使用。</p>
<p><img src="/images/EC271154665E410597D86C5AFF220467clipboard.png" alt></p>
<p>也可以通过v-bind或者简写：动态赋值，例如：</p>
<p><img src="/images/A358E18EACEB48D0B0545651A2E28D10clipboard.png" alt></p>
<p>子传父：</p>
<p><img src="/images/47C885B18F104181AFBD020D39899A07clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue常用指令之流程控制</title>
    <url>/2024/06/04/vue%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="v-if">v-if</h2>
<p><img src="/images/5F730C9479B54B699DE474EF4B7A7F9Eclipboard.png" alt></p>
<p>这里，v-if 指令将根据表达式seen 的值的真假来插入/移除元素。</p>
<p>v-if指令必须将它添加到一个元素上。如果想切换多个元素呢？</p>
<p>示例：添加一个else块此时可以把一个<template>元素当做不可见的包裹元素，并在上面使用v-if。最终的渲染结果将不包含<template>元素。</template></template></p>
<p><img src="/images/38591824AEDF4276B3BD2D674D39FBB9clipboard.png" alt></p>
<p>v-else-fi多分支：</p>
<p><img src="/images/055C10B8FB2D4C37B0F5C228101816EEclipboard.png" alt></p>
<h2 id="v-show">v-show</h2>
<p>v-show：另一个用于条件性展示元素的指令，与v-if不同的是，v-show的元素始终会被渲 染并保留再DOM中，所以v-show只是简单地切换元素的display CSS属性。</p>
<p><img src="/images/AE19C6C41C1541D2A94E0851181D87E7clipboard.png" alt></p>
<h2 id="v-for">v-for</h2>
<p>可以用v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用item in items 形式 的特殊语法，其中items 是源数据数组，而item 则是被迭代的数组元素的别名。</p>
<p><img src="/images/68112A71FF9C4BEDB13B77FBDE6FC3F3clipboard.png" alt></p>
<p>当Vue 正在更新使用v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数 据项的顺序被改变，Vue 将不会移动DOM 元素来匹配数据项的顺序，而是就地更新每个 元素，并且确保它们在每个索引位置正确渲染。</p>
<p>为了给Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你 需要为每项提供一个唯一的key 属性：</p>
<p><img src="/images/EB87EA8B640A43B4B3EA8010C8649FF3clipboard.png" alt></p>
<p>获取用户选择并赋值另一个变量再实时展示：</p>
<p><img src="/images/FE9D80B96FCB40C8AAF62852599DD9AAclipboard.png" alt></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>python自定义模块及导入方法</title>
    <url>/2024/02/22/python%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E5%8F%8A%E5%AF%BC%E5%85%A5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="自定义模块">自定义模块</h2>
<p>一个较大的程序一般应分为若干个程序块，若个程序块称为模块，每个模块用来实现一部分特定的功能。 这样做的目的是为了将代码有组织的存放在一起，方便管理和重复使用。</p>
<p>定义一个模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi mym.py </span></span><br><span class="line">name = <span class="string">&quot;amei&quot;</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">a, b</span>): </span><br><span class="line">    result = a * b </span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;a&#125;</span>与<span class="subst">&#123;b&#125;</span>的乘积是: <span class="subst">&#123;result&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用模块的方法：</p>
<p>import &lt;模块名称&gt;</p>
<p>from &lt;模块名称&gt; import &lt;方法名&gt;</p>
<p>from &lt;模块名称&gt; as &lt;别名&gt;</p>
<p>注：模块名称即py文件名称</p>
<h2 id="name-“main”-作用"><strong>name</strong>==“<strong>main</strong>” 作用</h2>
<p>mym.py作为一个模块，我们希望保留末尾测试代码，即上面调用函数 和类，但也不希望再导入模块的时候执行。该怎么办呢？</p>
<p>可以利用Python文件的一个内置属性__name__实现，如果直接运行 Python文件，__name__的值是&quot;<strong>mian</strong>&quot;，如果import一个模块，那 么模块的__name__的值是&quot;文件名&quot;。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi mym.py</span></span><br><span class="line">name = <span class="string">&quot;amei&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">a, b</span>):</span><br><span class="line">    result = a * b</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;a&#125;</span>与<span class="subst">&#123;b&#125;</span>的乘积是: <span class="subst">&#123;result&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我在手动执行这个程序&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(count(<span class="number">6</span>,<span class="number">6</span>))</span><br><span class="line">    <span class="built_in">print</span>(name)        </span><br></pre></td></tr></table></figure>
<h2 id="模块帮助文档">模块帮助文档</h2>
<p>我们知道，在定义函数或者类时，可以为其添加说明文档，以方便用 户清楚的知道该函数或者类的功能。自定义模块也不例外，也可以添 加说明文档，与函数或类的添加方法相同，即只需在模块开头的位置 定义一个字符串即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi mym.py </span></span><br><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">count()函数用于计算两个数值乘积</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">a, b</span>):</span><br><span class="line">    result = a * b</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;a&#125;</span>与<span class="subst">&#123;b&#125;</span>的乘积是: <span class="subst">&#123;result&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">查看模块帮助文档：</span><br><span class="line">方式<span class="number">1</span>：</span><br><span class="line"><span class="built_in">print</span>(mym.__doc__)</span><br><span class="line">方式<span class="number">2</span>：</span><br><span class="line"><span class="built_in">help</span>(mym)    </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>vue路由vue-router</title>
    <url>/2024/06/10/vue%E8%B7%AF%E7%94%B1vue-router/</url>
    <content><![CDATA[<h2 id="介绍">介绍</h2>
<p>Vue Router 是 Vue.js (opens new window)官方的路由管理器。它和 Vue.js 的 核心深度集成，包含的功能有：</p>
<ul>
<li>
<p>嵌套的路由/视图表</p>
</li>
<li>
<p>模块化的、基于组件的路由配置</p>
</li>
<li>
<p>路由参数、查询、通配符</p>
</li>
<li>
<p>基于Vue.js 过渡系统的视图过渡效果</p>
</li>
<li>
<p>细粒度的导航控制</p>
</li>
</ul>
<h2 id="使用">使用</h2>
<p>在用脚手架创建项目时已经选择安装上了，如果刚开始没有，通过npm安装：</p>
<p>npm install vue-router@4</p>
<p>安装完后会有router目录：</p>
<p><img src="/images/C23C554144144CFEA8AAE1FBFA85FD86clipboard.png" alt></p>
<p>使用流程：</p>
<ol>
<li>
<p>开发页面（组件）</p>
</li>
<li>
<p>定义路由</p>
</li>
<li>
<p>组件使用路由</p>
</li>
</ol>
<p><img src="/images/03DE8A90C97741C58A7A1352889584F3clipboard.png" alt></p>
<p><img src="/images/BFB82C65F0B746A594F361EB1F54BA03clipboard.png" alt></p>
<h2 id="路由传参">路由传参</h2>
<p>URL传参：一般用于页面跳转，将当前数据传递到新页面，例如详情页</p>
<p>params传参</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- 配置路由：&#123;path: &#x27;/user/:id&#x27;, component: about&#125;</span><br><span class="line"></span><br><span class="line">- 传递方式：<span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/user/6/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- 传递后路径：/user/6</span><br><span class="line"></span><br><span class="line">- 接收参数：$route.params.id</span><br></pre></td></tr></table></figure>
<p>query传参</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- 配置路由：&#123;path: &#x27;/user/&#x27;, component: about&#125;</span><br><span class="line"></span><br><span class="line">-  传递方式：<span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;&#123;path: &#x27;/about &#x27;, query:&#123;id:6&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">-  传递后路径：/user?id=6</span><br><span class="line"></span><br><span class="line">-  接收参数：$route.query.id</span><br></pre></td></tr></table></figure>
<h2 id="导航守卫">导航守卫</h2>
<p>正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。 简单来说，就是在路由跳转时候的一些钩子，当从一个页面跳转到另一个页面时， 可以在跳转前、中、后做一些事情。</p>
<p>你可以使用router.beforeEach 注册一个全局前置守卫：</p>
<p><img src="/images/3AFEA1B9E3AD441E8305546A749E9725clipboard.png" alt></p>
<p>当一个导航触发时，就会异步执行这个回调函数。</p>
<p>每个守卫方法接收参数：</p>
<ul>
<li>
<p>to：即将要进入的目标，是一个路由对象</p>
</li>
<li>
<p>from：当前导航正要离开的路由，也是一个路由对象</p>
</li>
<li>
<p>next：可选，是一个方法</p>
</li>
</ul>
<p>可以返回的值如下：</p>
<ul>
<li>
<p>false：取消当前的导航。如果浏览器的URL 改变了(可能 是用户手动或者浏览器后退按钮)，那么URL 地址会重置 到from 路由对应的地址。</p>
</li>
<li>
<p>一个路由地址：通过一个路由地址跳转到一个不同的地址。</p>
</li>
</ul>
<p>在网站开发中，使用导航守卫一个普遍需求：登录验证，即在没 有登录的情况下，访问任何页面都跳转到登录页面。</p>
<p><img src="/images/A054CB0CA74A412D92EF6354BD3710CDclipboard.png" alt></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端数据交互axios</title>
    <url>/2024/06/09/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92axios/</url>
    <content><![CDATA[<h2 id="介绍">介绍</h2>
<p>在前端页面展示的数据大多数都是通过访问一个API获取的，做这件事的方法有好几种，例如 jquery ajax、vue-resource、axios，而vue-resource是vue插件，但3版本不再更新，目前官方 推荐主流的axios，aixos是一个http请求库。</p>
<p>官方文档：<a href="http://www.axios-js.com/zh-cn/docs/">http://www.axios-js.com/zh-cn/docs/</a></p>
<h2 id="使用">使用</h2>
<p>使用流程：</p>
<p>1、安装axios：npm install axios</p>
<p>2、在main.js文件中全局注册</p>
<p>3、在组件中使用</p>
<p><img src="/images/60F13B5F05F04C7F8B585A834F73FF1Fclipboard.png" alt></p>
<p>如果打开页面就自动渲染，可以放到mounted生命周期钩子 中获取数据并赋值：</p>
<p><img src="/images/C7D4536D45F84F44B8141C51E8C70EA4clipboard.png" alt></p>
<p><img src="/images/C5D1B21B60C641C2A504542E9DB34E57clipboard.png" alt></p>
<h2 id="异常处理">异常处理</h2>
<p>很多时候我们可能并没有从API 获取想要的数据。这可能是由于很多种因素引起的，比如axios 调用可能由于多种原因而失败，包括但不限于：</p>
<ul>
<li>
<p>API 不工作了；</p>
</li>
<li>
<p>请求发错了；</p>
</li>
<li>
<p>API 没有按我们预期的格式返回信息。</p>
</li>
</ul>
<p>可以使用catch异常处理这些问题。</p>
<p>模拟连接一个未存在的地址，前端给出提示：</p>
<p><img src="/images/1AE67C4EBD754254AB6A704335FA93D1clipboard.png" alt></p>
<h2 id="全局默认值">全局默认值</h2>
<p>在实际开发中，几乎每个组件都会用到axios发起数据请求，如果每次都填写完整的请求路径，不 利于后期维护。这时可以设置全局axios默认值。</p>
<p><img src="/images/800323776846408DA8CD53C7B128D45Cclipboard.png" alt></p>
<h2 id="自定义实例默认值">自定义实例默认值</h2>
<p>有时候服务端接口有多个地址，就会涉及请求的域名不同、配置不同等，这时自定义实例可以很好解决。</p>
<p><img src="/images/DC172FED78C2492385CBAEFDEE720E79clipboard.png" alt></p>
<h2 id="拦截器">拦截器</h2>
<p>拦截器可以拦截每一次请求和响应，然后进行相应的处理。</p>
<p>请求拦截应用场景：</p>
<ul>
<li>
<p>发起请求前添加header 响应拦截应用场景：</p>
</li>
<li>
<p>统一处理API响应状态码200或非200的提示消息</p>
</li>
<li>
<p>统一处理catch异常提示信息</p>
</li>
</ul>
<p><img src="/images/A906B59FC1FA4D6282D7E4AC3A9A62EBclipboard.png" alt></p>
<p><img src="/images/89FDA87EC5FF41F6931FA012C82392A2clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈有状态应用部署：StatefulSet控制器</title>
    <url>/2022/07/13/%E5%86%8D%E8%B0%88%E6%9C%89%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2statefulset%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="无状态与有状态">无状态与有状态</h2>
<p>Deployment控制器设计原则：管理的所有Pod一模一样，提供同一个服务，也不考虑在哪台Node 运行，可随意扩容和缩容。这种应用称为“无状态”，例如Web服务</p>
<p>在实际的场景中，并不能满足所有应用，尤其是分布式应用，会部署多个实例，这些实例之间往往有 依赖关系，例如主从关系、主备关系，这种应用称为“有状态”，例如MySQL主从、Etcd集群</p>
<h2 id="StatefulSet-控制器概述">StatefulSet 控制器概述</h2>
<p>StatefulSet控制器用于部署有状态应用，满足一些有状态应 用的需求：</p>
<ul>
<li>
<p>Pod有序的部署、扩容、删除和停止</p>
</li>
<li>
<p>Pod分配一个稳定的且唯一的网络标识</p>
</li>
<li>
<p>Pod分配一个独享的存储</p>
</li>
</ul>
<h2 id="StatefulSet-控制器：网络标识">StatefulSet 控制器：网络标识</h2>
<p>稳定的网络标识：使用Headless Service（相比普通Service只是将spec.clusterIP定义为None）来维 护Pod网络身份，会为每个Pod分配一个数字编号并且按照编号顺序部署。还需要在StatefulSet添加 serviceName: “nginx”字段指定StatefulSet控制器要使用这个Headless Service。</p>
<p>稳定主要体现在主机名和Pod A记录：</p>
<p>主机名：&lt;statefulset名称&gt;-&lt;编号&gt;</p>
<p>Pod DNS A记录：&lt;statefulset名称-编号&gt;.<service-name>.<namespace>.svc.cluster.local</namespace></service-name></p>
<p>部署statefulset控制器</p>
<p>vim statefulset-web.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: statefulset-web</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">&quot;handless-service&quot;</span></span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>部署handless-service</p>
<p>vim handless-service.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: handless-service</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 9376</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f statefulset-web.yaml</span><br><span class="line">kubectl apply -f handless-service.yaml </span><br><span class="line">kubectl get pod,svc</span><br><span class="line">kubectl get statefulsets.apps </span><br></pre></td></tr></table></figure>
<p>查看Pod创建顺序：</p>
<p><img src="/images/80B71B676C07446E9B2AA1C978F26318clipboard.png" alt></p>
<p>查看主机名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> statefulset-web-0 -- hostname</span><br><span class="line">kubectl <span class="built_in">exec</span> statefulset-web-1 -- hostname</span><br><span class="line">kubectl <span class="built_in">exec</span> statefulset-web-2 -- hostname</span><br></pre></td></tr></table></figure>
<p><img src="/images/755E9E6EDA8941558B1745290F2D917Cclipboard.png" alt></p>
<p>测试A记录解析：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run -it dns-test --<span class="built_in">rm</span> --image=busybox:1.28.4 -- sh</span><br><span class="line">nslookup handless-service </span><br></pre></td></tr></table></figure>
<p>解析出对应的三个Pod IP记录，其他Pod可使用这个名称访问：</p>
<p><img src="/images/FAC6C069723344C2A0DB0C8F849AE00Dclipboard.png" alt></p>
<h2 id="StatefulSet-控制器：独享存储">StatefulSet 控制器：独享存储</h2>
<p>独享存储：StatefulSet的存储卷使用VolumeClaimTemplate创建，称为卷申请模板，当StatefulSet使用 VolumeClaimTemplate创建一个PersistentVolume时，同样也会为每个Pod分配并创建一个编号的PVC， 每个PVC绑定对应的PV，从而保证每个Pod都拥有独立的存储。</p>
<p>部署nfs</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装nfs安装包（每个k8s节点都要安装）</span></span><br><span class="line">yum install nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建nfs共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改nfs配置文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/nfs/kubernetes *(rw,no_root_squash)</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动nfs并加入开机自启</span></span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#尝试在别的K8s节点挂载nfs共享目录</span></span><br><span class="line">mount -t nfs 192.168.0.13:/nfs/kubernetes /mnt/</span><br></pre></td></tr></table></figure>
<p>部署nfs-storage</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-incubator/external-storage </span><br><span class="line"><span class="built_in">cd</span> nfs-client/deploy </span><br><span class="line">kubectl apply -f rbac.yaml <span class="comment"># 授权访问apiserver </span></span><br><span class="line">kubectl apply -f deployment.yaml <span class="comment"># 部署插件，需修改里面NFS服务器地址与共享目录 </span></span><br><span class="line">kubectl apply -f class.yaml <span class="comment"># 创建存储类</span></span><br><span class="line"></span><br><span class="line">kubectl get sc  <span class="comment"># 查看存储类</span></span><br></pre></td></tr></table></figure>
<p>部署statefulset控制器</p>
<p>vim statefulset-web.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: statefulset-web</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">&quot;handless-service&quot;</span></span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: www</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: www</span><br><span class="line">    spec:</span><br><span class="line">      storageClassName: <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">      accessModes:</span><br><span class="line">      - ReadWriteOnce</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1G</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete -f statefulset-web.yaml </span><br><span class="line">kubectl apply -f statefulset-web.yaml </span><br></pre></td></tr></table></figure>
<p><img src="/images/050E337CBA4347278B9D0F4B2D7BBB2Aclipboard.png" alt></p>
<p>nfs服务器共享目录</p>
<p><img src="/images/BD3FFB854BCE4CEF8A11A7EE1B494B72clipboard.png" alt></p>
<p>测试在这三个pv目录下创建三个不同内容的index.html页面，然后访问对应不同的Pod的IP</p>
<p><img src="/images/BDD71F15C8FF4D99B2BC00D24806B61Dclipboard.png" alt></p>
<p>验证访问</p>
<p><img src="/images/127B91087C4C4170B0479529BD161B90clipboard.png" alt></p>
<p>从上面图中，我们可以看到每个pod的数据都是独立存储的。</p>
<p>测试删除statefulset控制器</p>
<p><img src="/images/F37B91C5C39D4B548C6632FF7971A806clipboard.png" alt></p>
<p>从上图可以看出，当我们删除pod的时候，并没有删除对应pvc和pv，而是做了数据的持久化。</p>
<p>再次重建测试能否访问之前的数据</p>
<p><img src="/images/907C87901FA54AF4A7B760C74CB4BBF7clipboard.png" alt></p>
<p><img src="/images/AF4D65A9A4C84C3DB178061646047519clipboard.png" alt></p>
<p>从上图可以看出，重建之后，数据还是之前的数据，每个pvc对应绑定每个pv，pod的IP发生了变化。</p>
<p>kubernetes根据pod的编号找同样编号的pvc去挂载，从而实现了数据持久化。</p>
<p>通过编号保证每个pod的启动顺序</p>
<p>通过编号为每个pod创建不同的主机名以及dns A记录</p>
<p>通过编号为每个pod创建独立的pvc</p>
<h2 id="StatefulSet-控制器：小结">StatefulSet 控制器：小结</h2>
<p>StatefulSet与Deployment区别：有身份的！</p>
<p>身份三要素：</p>
<ul>
<li>
<p>域名</p>
</li>
<li>
<p>主机名</p>
</li>
<li>
<p>存储（PVC）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>告警触发流程</title>
    <url>/2021/09/07/%E5%91%8A%E8%AD%A6%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/images/579170C3770A4A4D9A1B876D6BC18494clipboard.png" alt></p>
<p>在prometheus配置里面创建告警规则</p>
<p>判断当前实例的状态是否正常，up=1代表正常，up=0代表失联，不正常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">groups</span>:</span><br><span class="line">- name: general.rules</span><br><span class="line">  rules:</span><br><span class="line">  - alert: InstanceDown</span><br><span class="line">    <span class="built_in">expr</span>: up == 0</span><br><span class="line">    <span class="keyword">for</span>: 2m</span><br><span class="line">    labels:</span><br><span class="line">      severity: error</span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;Instance &#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; 停止工作&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125;: job &#123;&#123; <span class="variable">$labels</span>.job &#125;&#125; 已经停止5分钟以上.&quot;</span></span><br></pre></td></tr></table></figure>
<p>统计cpu，内存，文件系统的使用率，超过80%发送告警</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">groups</span>:</span><br><span class="line">- name: node.rules</span><br><span class="line">  rules:</span><br><span class="line">  - alert: NodeFilesystemUsage</span><br><span class="line">    <span class="built_in">expr</span>: 100 - (node_filesystem_free_bytes&#123;fstype=~<span class="string">&quot;ext4|xfs&quot;</span>&#125; / node_filesystem_size_bytes&#123;fstype=~<span class="string">&quot;ext4|xfs&quot;</span>&#125; * 100) &gt; 80</span><br><span class="line">    <span class="keyword">for</span>: 2m</span><br><span class="line">    labels:</span><br><span class="line">      severity: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: &#123;&#123;<span class="variable">$labels</span>.mountpoint &#125;&#125; 分区使用过高&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: &#123;&#123;<span class="variable">$labels</span>.mountpoint &#125;&#125; 分区使用大于 80% (当前值: &#123;&#123; <span class="variable">$value</span> &#125;&#125;)&quot;</span></span><br><span class="line">  - alert: NodeMemoryUsage</span><br><span class="line">    <span class="built_in">expr</span>: 100 - (node_memory_MemFree_bytes+node_memory_Cached_bytes+node_memory_Buffers_bytes) / node_memory_MemTotal_bytes * 100 &gt; 80</span><br><span class="line">    <span class="keyword">for</span>: 2m</span><br><span class="line">    labels:</span><br><span class="line">      severity: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: 内存使用过高&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: 内存使用大于 80% (当前值: &#123;&#123; <span class="variable">$value</span> &#125;&#125;)&quot;</span></span><br><span class="line">  - alert: NodeCPUUsage</span><br><span class="line">    <span class="built_in">expr</span>: 100 - (avg(irate(node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>&#125;[5m])) by (instance) * 100) &gt; 80</span><br><span class="line">    <span class="keyword">for</span>: 2m</span><br><span class="line">    labels:</span><br><span class="line">      severity: warning</span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: CPU使用过高&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: CPU使用大于 80% (当前值: &#123;&#123; <span class="variable">$value</span> &#125;&#125;)&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>进入for评估周期中</p>
<p><img src="/images/B669B2EB89C642E5A6CFD07DAD009F59clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>zabbix监控服务器</title>
    <url>/2024/08/28/zabbix%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="环境准备">环境准备</h2>
<p>1.操作系统版本</p>
<p><img src="/images/8B00B45CBD5D418FAF6C61D9D6EF7332clipboard.png" alt></p>
<p>2.关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>
<p>3.关闭selinux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<p>4.永久关闭selinux，修改完保存退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>
<p>5.下载安装包</p>
<p>百度网盘链接: <a href="https://pan.baidu.com/s/1oCNdwR7is_-gbCD0nTlyow">https://pan.baidu.com/s/1oCNdwR7is_-gbCD0nTlyow</a> 提取码: caj8</p>
<h2 id="yum安装依赖离线包">yum安装依赖离线包</h2>
<p>若通外网，可以直接yum在线安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install pcre-devel gcc make nginx </span><br></pre></td></tr></table></figure>
<p>1.拷贝zabbix_agent.zip包到服务器root家目录</p>
<p>2.解压安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip zabbix_agent.zip </span><br></pre></td></tr></table></figure>
<p>3.安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd zabbix_agent</span><br><span class="line">yum localinstall *.rpm -y</span><br></pre></td></tr></table></figure>
<h2 id="安装zabbix客户端">安装zabbix客户端</h2>
<p>1.拷贝zabbix-7.0.3.tar.gz到服务器root家目录</p>
<p>2.解压安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxf zabbix-7.0.3.tar.gz</span><br></pre></td></tr></table></figure>
<p>3.创建zabbix账号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd --system zabbix</span><br><span class="line">useradd --system -g zabbix -d /usr/lib/zabbix -s /sbin/nologin -c &quot;Zabbix Monitoring System&quot; zabbix</span><br></pre></td></tr></table></figure>
<p>4.创建zabbix目录并授权</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -m u=rwx,g=rwx,o= -p /usr/lib/zabbix</span><br><span class="line">chown zabbix:zabbix /usr/lib/zabbix</span><br></pre></td></tr></table></figure>
<p>5.编译安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/zabbix-7.0.3</span><br><span class="line">./configure --enable-agent --prefix=/usr/local/zabbix</span><br><span class="line">make install </span><br></pre></td></tr></table></figure>
<p><img src="/images/698F2C571D1648989759EAAE545B4ED3clipboard.png" alt></p>
<p>6.修改zabbix客户端配置文件并保存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/zabbix/etc/zabbix_agentd.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改以下配置</span></span><br><span class="line">Server=192.168.7.120   #指定zabbix-server ip地址</span><br><span class="line">ServerActive=192.168.7.120   #指定zabbix-server ip地址</span><br><span class="line">HostMetadataItem=system.uname</span><br></pre></td></tr></table></figure>
<p>7.配置zabbix-agent启动文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/zabbix-agent.service</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加下面内容</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Zxbbix agent</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/zabbix/sbin/zabbix_agentd -f</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存并启动</span></span><br><span class="line">systemctl start zabbix-agent</span><br><span class="line">systemctl enable zabbix-agent</span><br></pre></td></tr></table></figure>
<h2 id="监控服务器端口和进程">监控服务器端口和进程</h2>
<p>注意： zabbix服务端和客户端时间需保持同步！</p>
<p>1.被监控端启动nginx（仅用于测试监控nginx服务端口和进程，若需要监控其它服务步骤类似）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>
<p>2.创建主机</p>
<p><img src="/images/311D8B23097E47A887374855E7AFB2FBclipboard.png" alt></p>
<p><img src="/images/FA55C537CCD64A548F9F9207E40C119Eclipboard.png" alt></p>
<p>稍等几秒查看状态，变绿就是正常了</p>
<p><img src="/images/3A332576B59647A28484BCC874C50320clipboard.png" alt></p>
<p>3.监听端口</p>
<p>配置监控项</p>
<p><img src="/images/452ED5D82FF04E1398A3FF09FD356A09clipboard.png" alt></p>
<p>创建监控项</p>
<p><img src="/images/75C561C972094B85AB327056D14C64ACclipboard.png" alt></p>
<p><img src="/images/FD1CC41A9E0A449B87A6558527E1D161clipboard.png" alt></p>
<p><img src="/images/199FADB04392488890D7CDFF4D6CF0ACclipboard.png" alt></p>
<p>添加成功后可以查看到刚刚添加的监控项</p>
<p><img src="/images/4F08F4EF697B4317AB3D90EB6A3805B6clipboard.png" alt></p>
<p>配置触发器</p>
<p><img src="/images/9476D9C99D7949FD83946EB711F82201clipboard.png" alt></p>
<p>创建触发器</p>
<p><img src="/images/6533B4BD37724AC78317EFC40FB0EE36clipboard.png" alt></p>
<p><img src="/images/0E88B062A89F49D391C0683A55D0CEEAclipboard.png" alt></p>
<p>添加成功后可以查看到刚刚添加的触发器</p>
<p><img src="/images/AED940F243E24F92B877844359834013clipboard.png" alt></p>
<p>4.监听进程</p>
<p>配置监控项（步骤与上面类似）</p>
<p><img src="/images/E787EEE73F164FB7930D027E8EFBD8D3clipboard.png" alt></p>
<p>以下是对nginx进程的监控配置，key中的参数说明</p>
<p>name：进程名字，不需要填，填了可能监控不准确</p>
<p>user： 进程用户名</p>
<p>state： 进程状态</p>
<p>cmdline：进程名中包含的字符</p>
<p>获取值并进行测试</p>
<p><img src="/images/320A7190DAC94AC4903FF254398608B9clipboard.png" alt></p>
<p>添加成功后可以查看到刚刚添加的监控项</p>
<p><img src="/images/80F311C2F2184F0D974FE3504AAB64C6clipboard.png" alt></p>
<p>配置触发器</p>
<p><img src="/images/4EAED43D3CE745EEAA579F70DE52B9F5clipboard.png" alt></p>
<p>添加成功后可以查看到刚刚添加的触发器</p>
<p><img src="/images/5C2C5327EE7A4DA3A6042CED3CD9904Dclipboard.png" alt></p>
<p>这个时候停止被监控端上面的nginx服务，可以看到控制台已经触发了，因为检测不到端口和进程了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop nginx</span><br></pre></td></tr></table></figure>
<p><img src="/images/5AD759CF8D8C463792D88526765194F2clipboard.png" alt></p>
<p>再次启动nginx，可以查看到控制已经没有了，说明nginx服务正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>
<p><img src="/images/F79240ACEA13463FBA2E1E6563AFDBE5clipboard.png" alt></p>
<h2 id="配置邮件报警">配置邮件报警</h2>
<p>这里使用163邮箱进行实验</p>
<p>1.开启SMTP服务和POP3服务，会生成一个授权码，需要记住这个授权码</p>
<p><img src="/images/09530EACFCA24981A434ED3FBFDED8C6clipboard.png" alt></p>
<p>2.创建媒介</p>
<p><img src="/images/028BBDE657884F06819E904A78A8CA60clipboard.png" alt></p>
<p>电子邮件和用户名称都填自己的邮箱账号，这里的密码指的是上面生成的授权码</p>
<p><img src="/images/0C8430BA0CCA493786B59C8EAE350510clipboard.png" alt></p>
<p>3.为用户指定报警媒介</p>
<p><img src="/images/F4A0362FE84A43F5AC91963DE2717181clipboard.png" alt></p>
<p><img src="/images/34636D7CB88E4EF9BC4ACCFA88084473clipboard.png" alt></p>
<p>记得点击更新</p>
<p><img src="/images/CC48ECF19F684AEE96100BCC9B371DB1clipboard.png" alt></p>
<p>4.测试发送邮件</p>
<p><img src="/images/F9FCD9E76D2E486D93D30DAD811CD0D8clipboard.png" alt></p>
<p>可以看到收到邮件了</p>
<p><img src="/images/7CD902E630DA4DC59FE7A5F4334AF47Fclipboard.png" alt></p>
<p>5.添加动作-nginx端口</p>
<p><img src="/images/AF91D6CD7E62455DB379638D38F9D761clipboard.png" alt></p>
<p><img src="/images/EB77A2E7574C48B681A5C27EE00AA9DFclipboard.png" alt></p>
<p>触发器选择自己之前创建的触发器</p>
<p><img src="/images/60FAF675594440CFB3FDE2CB5033FCE5clipboard.png" alt></p>
<p>添加操作</p>
<p><img src="/images/903BC2ADD01540459FCEA0CB87E12609clipboard.png" alt></p>
<p>添加恢复操作</p>
<p><img src="/images/DBD8ED7F1AAE41C5B5EB24E43739E418clipboard.png" alt></p>
<p><img src="/images/58B229AE2A9244949CCBEE53CA19FEC1clipboard.png" alt></p>
<p>6.添加动作-nginx进程</p>
<p><img src="/images/8641FD724DB8451FA9E36C4590668245clipboard.png" alt></p>
<p>添加操作</p>
<p><img src="/images/91B43F6F411441BF8D402FF9E4DD3A57clipboard.png" alt></p>
<p>添加恢复操作</p>
<p><img src="/images/A6A9DC8FD40444A9BDD1071DF48B5128clipboard.png" alt></p>
<p>可以看到刚才创建的两个动作</p>
<p><img src="/images/1458F81D99E84EB4AEDB577244D0C277clipboard.png" alt></p>
<p>7.测试</p>
<p>再次停止nginx服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop nginx</span><br></pre></td></tr></table></figure>
<p>查看是否收到两份异常邮件</p>
<p><img src="/images/7B3B127A3C594B14A369C2AD2BEF04C9clipboard.png" alt></p>
<p><img src="/images/A5D13BE7C98D468F872F101FADCFA731clipboard.png" alt></p>
<p>再次启动nginx服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>
<p>查看是否收到两份恢复邮件</p>
<p><img src="/images/ECA8C4652C8D47158332B921A1547BAAclipboard.png" alt></p>
<p><img src="/images/B9A90BE5DAD74FE3BA883134CF976796clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>回滚设计—pipeline集合ansible发布多台web服务器</title>
    <url>/2021/05/22/%E5%9B%9E%E6%BB%9A%E8%AE%BE%E8%AE%A1%E2%80%94pipeline%E9%9B%86%E5%90%88ansible%E5%8F%91%E5%B8%83%E5%A4%9A%E5%8F%B0web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>回滚方案：</p>
<p>一般回滚方案：</p>
<p>• 重新走一步流程发布上一次版本代码</p>
<p>• 部署之前备份程序文件</p>
<p>回滚流程设计：</p>
<p><img src="/images/A723E37ACDC841C9BF5C5BD83BE9802Eclipboard.png" alt></p>
<p>回滚实现步骤：</p>
<p>安装Extended Choice Parameter插件并配置生成对应的语法</p>
<p><img src="/images/6F1B52C6EB2545958C18C87B95C778241.JPG" alt></p>
<p><img src="/images/26F146C7C5084D39A1420855D01B2AAE2.JPG" alt></p>
<p><img src="/images/E6B0C6F405284904BCBA145390EDDA4D3.JPG" alt></p>
<p>生成连接Jenkins服务器用户名和密码语法</p>
<p><img src="/images/0C6CE50DD55C4F0EBB9546590C9AF20Fclipboard.png" alt></p>
<p><img src="/images/7F56EB571C194AFEBBF743027864EC47clipboard.png" alt></p>
<p>此处是使用下面参数生成的凭据语法（避免脚本中用户名密码的敏感信息泄露）</p>
<p><img src="/images/5030CE289848459BB31AB985E75A83CAclipboard.png" alt></p>
<p><img src="/images/A03A588B8D284E698EBA0F6E7B3B739Bclipboard.png" alt></p>
<p>1、在原有Pipeline脚本中增加生成“备份版本记录文件”脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">备份的文件名格式最好是统一规范的，例如：项目名-文件名-日期-构建编号</span><br><span class="line">项目名：当前创建的项目</span><br><span class="line">文件名：部署war包的名称（ROOT.war)</span><br><span class="line">日期:<span class="built_in">date</span> +%F</span><br><span class="line">构建编号：jenkins自带的变量(build_number)   </span><br><span class="line"></span><br><span class="line"><span class="comment">#备份版本记录文件的生成:</span></span><br><span class="line"><span class="built_in">ls</span> /data/backup |awk <span class="string">&#x27;&#123;print $0&#125;&#x27;</span></span><br><span class="line"><span class="built_in">ls</span> /data/backup |awk <span class="string">&#x27;&#123;print $0&quot;,&quot;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">ls</span> /data/backup |awk <span class="string">&#x27;&#123;printf $0&quot;,&quot;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">ls</span> /data/backup |awk <span class="string">&#x27;BEGIN&#123;printf &quot;abc=&quot;&#125;&#123;printf $0&quot;,&quot;&#125;&#x27;</span></span><br><span class="line"><span class="comment">#\转义,不让jenkins解析变量，而是shell本身的变量</span></span><br><span class="line"><span class="built_in">ls</span> /data/backup |awk <span class="string">&#x27;BEGIN&#123;printf &quot;abc=&quot;&#125;&#123;printf \$0&quot;,&quot;&#125;&#x27;</span> &gt; /tmp/backup_version.txt </span><br><span class="line"><span class="built_in">ls</span> /data/backup |<span class="built_in">sort</span> -t - -k 6 -nr |<span class="built_in">head</span> -n 3|awk <span class="string">&#x27;BEGIN&#123;printf &quot;abc=&quot;&#125;&#123;printf \$0&quot;,&quot;&#125;&#x27;</span> &gt; /tmp/backup_version.txt  </span><br><span class="line"></span><br><span class="line"><span class="comment">#ssh实现免交互推送backup_version.txt文件到jenkins服务器</span></span><br><span class="line">sshpass -p<span class="string">&quot;123.com&quot;</span> scp /tmp/backup_version.tx t root@x.x.x.x:/opt/jenkins_home/</span><br></pre></td></tr></table></figure>
<p>新建项目–&gt;配置–&gt;最下面配置流水线脚本进行发布项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        label <span class="string">&quot;task1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    environment &#123;</span><br><span class="line">        git_address = <span class="string">&quot;http://gitlab.ctnrs.com/my-group/ansible.git&quot;</span></span><br><span class="line">        git_password = <span class="string">&quot;4cfc8d8f-489b-4c29-9f10-4a1b265e0cb3&quot;</span></span><br><span class="line">        ansible_ssh_auth = <span class="string">&quot;a14ad8a7-5ad6-43de-bac6-221000c8015c&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">        gitParameter branch: <span class="string">&#x27;&#x27;</span>, branchFilter: <span class="string">&#x27;.*&#x27;</span>, defaultValue: <span class="string">&#x27;master&#x27;</span>, description: <span class="string">&#x27;请选择你要发布的分支&#x27;</span>, name: <span class="string">&#x27;branch&#x27;</span>, quickFilterEnabled: <span class="literal">false</span>, selectedValue: <span class="string">&#x27;NONE&#x27;</span>, sortMode: <span class="string">&#x27;NONE&#x27;</span>, tagFilter: <span class="string">&#x27;*&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;PT_BRANCH&#x27;</span></span><br><span class="line">        choice choices: [<span class="string">&#x27;webservers1&#x27;</span>, <span class="string">&#x27;webservers2&#x27;</span>, <span class="string">&#x27;webservers3&#x27;</span>], description: <span class="string">&#x27;&#x27;</span><span class="string">&#x27;灰度发布策略，分批次部署</span></span><br><span class="line"><span class="string">        webservers1</span></span><br><span class="line"><span class="string">        192.168.0.2</span></span><br><span class="line"><span class="string">        192.168.0.5</span></span><br><span class="line"><span class="string">        webservers2</span></span><br><span class="line"><span class="string">        192.168.0.2</span></span><br><span class="line"><span class="string">        webservers3</span></span><br><span class="line"><span class="string">        192.168.0.5&#x27;</span><span class="string">&#x27;&#x27;</span>, name: <span class="string">&#x27;ENV&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">   triggers &#123;</span><br><span class="line">    pollSCM <span class="string">&#x27;*/1 * * * * &#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&quot;<span class="variable">$&#123;params.branch&#125;</span>&quot;</span>]], doGenerateSubmoduleConfigurations: <span class="literal">false</span>, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$git_password</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$git_address</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;编译构建&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&quot;/usr/local/maven/bin/mvn clean package -Dmaven.test.skip=true&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;拷贝构建文件到远程主机并部署&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                // 读取连接Jenkins服务器用户名和密码</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&#x27;ad3b7fb3-897e-4dc3-a7cf-0975ffc7b4ec&#x27;</span>, passwordVariable: <span class="string">&#x27;jenkinspass&#x27;</span>, usernameVariable: <span class="string">&#x27;jenkinsroot&#x27;</span>)]) &#123;</span><br><span class="line">                // ===========================================</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">###################### 主机清单文件 ############################</span></span><br><span class="line"><span class="string">cat &gt; /opt/jenkins/.hosts &lt;&lt; EOF</span></span><br><span class="line"><span class="string">[webservers1]</span></span><br><span class="line"><span class="string">192.168.0.2</span></span><br><span class="line"><span class="string">192.168.0.5</span></span><br><span class="line"><span class="string">[webservers2]</span></span><br><span class="line"><span class="string">192.168.0.2</span></span><br><span class="line"><span class="string">[webservers3]</span></span><br><span class="line"><span class="string">192.168.0.5</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">###################### Playbook文件 ############################</span></span><br><span class="line"><span class="string">cat &gt; /opt/jenkins/.playbook.yaml &lt;&lt; &quot;</span>EOF<span class="string">&quot;</span></span><br><span class="line"><span class="string">- hosts: <span class="variable">$ENV</span>   # Jenkins参数化变量 </span></span><br><span class="line"><span class="string">  gather_facts: no</span></span><br><span class="line"><span class="string">  vars:    # 定义playbook变量，下面&#123;&#123;&#125;&#125;引用这里的变量</span></span><br><span class="line"><span class="string">    workspace: <span class="variable">$WORKSPACE</span>   # WORKSPACE和BUILD_NUMBER引用Jenkins变量</span></span><br><span class="line"><span class="string">    build_number: <span class="variable">$BUILD_NUMBER</span></span></span><br><span class="line"><span class="string">    tomcat_dir: &quot;</span>/usr/local/tomcat<span class="string">&quot;  # 自定义变量</span></span><br><span class="line"><span class="string">    backup_dir: &quot;</span>/data/backup<span class="string">&quot;</span></span><br><span class="line"><span class="string">    backup_filename: &quot;</span>demo-ROOT-\$(<span class="built_in">date</span> +%F)-&#123;&#123; build_number &#125;&#125;.war<span class="string">&quot;  # 格式：项目名-文件名-日期-构建编号</span></span><br><span class="line"><span class="string">    jenkins_ip: &quot;</span>192.168.0.4<span class="string">&quot;</span></span><br><span class="line"><span class="string">    username: <span class="variable">$jenkinsroot</span></span></span><br><span class="line"><span class="string">    password: <span class="variable">$jenkinspass</span></span></span><br><span class="line"><span class="string">  tasks:</span></span><br><span class="line"><span class="string">  - name: 推送部署包到远程服务器</span></span><br><span class="line"><span class="string">    copy: src=&quot;</span>&#123;&#123; item &#125;&#125;<span class="string">&quot; dest=&#123;&#123; tomcat_dir &#125;&#125;/webapps</span></span><br><span class="line"><span class="string">    with_fileglob:</span></span><br><span class="line"><span class="string">      - &quot;</span>&#123;&#123; workspace &#125;&#125;/target/*.war<span class="string">&quot;</span></span><br><span class="line"><span class="string">  - name: 部署新程序并重启Tomcat</span></span><br><span class="line"><span class="string">    shell: |   </span></span><br><span class="line"><span class="string">       cd &#123;&#123; tomcat_dir &#125;&#125;/webapps</span></span><br><span class="line"><span class="string">       mv ROOT.war &#123;&#123; backup_dir &#125;&#125;/&#123;&#123; backup_filename &#125;&#125;</span></span><br><span class="line"><span class="string">       mv *.war ROOT.war</span></span><br><span class="line"><span class="string">       pid=\$(ps -ef |grep &#123;&#123; tomcat_dir &#125;&#125; |egrep -v &#x27;grep&#x27; |awk &#x27;&#123;print \$2&#125;&#x27;)</span></span><br><span class="line"><span class="string">       [ -n &quot;</span>\<span class="variable">$pid</span><span class="string">&quot; ] &amp;&amp; kill -9 \$pid</span></span><br><span class="line"><span class="string">       export JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">       nohup &#123;&#123; tomcat_dir &#125;&#125;/bin/startup.sh</span></span><br><span class="line"><span class="string">       ls /data/backup |sort -t - -k 6 -nr |head -n 3|awk &#x27;BEGIN&#123;printf &quot;</span>abc=<span class="string">&quot;&#125;&#123;printf \$0&quot;</span>,<span class="string">&quot;&#125;&#x27; &gt; /tmp/backup_version.txt </span></span><br><span class="line"><span class="string">       sshpass -p&#123;&#123; password &#125;&#125; scp /tmp/backup_version.txt &#123;&#123; username &#125;&#125;@&#123;&#123; jenkins_ip &#125;&#125;:/opt/jenkins_home/</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                // ===========================================</span><br><span class="line">                &#125;</span><br><span class="line">            	ansiblePlaybook( </span><br><span class="line">                playbook: <span class="string">&#x27;/opt/jenkins/.playbook.yaml&#x27;</span>,</span><br><span class="line">                inventory: <span class="string">&#x27;/opt/jenkins/.hosts&#x27;</span>, </span><br><span class="line">                credentialsId: <span class="string">&quot;<span class="variable">$&#123;ansible_ssh_auth&#125;</span>&quot;</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、在Jenkins创建一个独立的回滚项目</p>
<p>新建项目–&gt;配置–&gt;最下面配置流水线脚本（回滚项目中部署脚本只做根据选择的备份版本名称重新部署）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        label <span class="string">&quot;task1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    environment &#123;</span><br><span class="line">        ansible_ssh_auth = <span class="string">&quot;a14ad8a7-5ad6-43de-bac6-221000c8015c&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">        extendedChoice description: <span class="string">&#x27;请选择你要回滚的版本&#x27;</span>, multiSelectDelimiter: <span class="string">&#x27;,&#x27;</span>, name: <span class="string">&#x27;RollbackVersion&#x27;</span>, propertyFile: <span class="string">&#x27;/var/jenkins_home/backup_version.txt&#x27;</span>, propertyKey: <span class="string">&#x27;abc&#x27;</span>, quoteValue: <span class="literal">false</span>, saveJSONParameterToFile: <span class="literal">false</span>, <span class="built_in">type</span>: <span class="string">&#x27;PT_SINGLE_SELECT&#x27;</span>, visibleItemCount: 5</span><br><span class="line">        choice choices: [<span class="string">&#x27;webservers1&#x27;</span>, <span class="string">&#x27;webservers2&#x27;</span>, <span class="string">&#x27;webservers3&#x27;</span>], description: <span class="string">&#x27;&#x27;</span><span class="string">&#x27;灰度发布策略，分批次部署</span></span><br><span class="line"><span class="string">        webservers1</span></span><br><span class="line"><span class="string">        192.168.0.2</span></span><br><span class="line"><span class="string">        192.168.0.5</span></span><br><span class="line"><span class="string">        webservers2</span></span><br><span class="line"><span class="string">        192.168.0.2</span></span><br><span class="line"><span class="string">        webservers3</span></span><br><span class="line"><span class="string">        192.168.0.5&#x27;</span><span class="string">&#x27;&#x27;</span>, name: <span class="string">&#x27;ENV&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拷贝构建文件到远程主机并部署&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">               </span><br><span class="line">                // ===========================================</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">###################### 主机清单文件 ############################</span></span><br><span class="line"><span class="string">cat &gt; /opt/jenkins/.hosts &lt;&lt; EOF</span></span><br><span class="line"><span class="string">[webservers1]</span></span><br><span class="line"><span class="string">192.168.0.2</span></span><br><span class="line"><span class="string">192.168.0.5</span></span><br><span class="line"><span class="string">[webservers2]</span></span><br><span class="line"><span class="string">192.168.0.2</span></span><br><span class="line"><span class="string">[webservers3]</span></span><br><span class="line"><span class="string">192.168.0.5</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">###################### Playbook文件 ############################</span></span><br><span class="line"><span class="string">cat &gt; /opt/jenkins/.playbook.yaml &lt;&lt; &quot;</span>EOF<span class="string">&quot;</span></span><br><span class="line"><span class="string">- hosts: <span class="variable">$ENV</span>   # Jenkins参数化变量 </span></span><br><span class="line"><span class="string">  gather_facts: no</span></span><br><span class="line"><span class="string">  vars:    # 定义playbook变量，下面&#123;&#123;&#125;&#125;引用这里的变量</span></span><br><span class="line"><span class="string">    workspace: <span class="variable">$WORKSPACE</span>   # WORKSPACE和BUILD_NUMBER引用Jenkins变量</span></span><br><span class="line"><span class="string">    tomcat_dir: &quot;</span>/usr/local/tomcat<span class="string">&quot;  # 自定义变量</span></span><br><span class="line"><span class="string">    backup_dir: &quot;</span>/data/backup<span class="string">&quot;</span></span><br><span class="line"><span class="string">    backup_filename: <span class="variable">$RollbackVersion</span></span></span><br><span class="line"><span class="string">  tasks:</span></span><br><span class="line"><span class="string">  - name: 恢复备份程序并重启tomcat</span></span><br><span class="line"><span class="string">    # 脚本中\$必须转义，否则会认为是Jenkins变量</span></span><br><span class="line"><span class="string">    shell: |   </span></span><br><span class="line"><span class="string">       cd &#123;&#123; tomcat_dir &#125;&#125;/webapps</span></span><br><span class="line"><span class="string">       [ ! -d &#123;&#123; backup_dir &#125;&#125; ] &amp;&amp; mkdir &#123;&#123; backup_dir &#125;&#125; -p </span></span><br><span class="line"><span class="string">       [ ! -d /tmp/new_root ] &amp;&amp; mkdir /tmp/new_root </span></span><br><span class="line"><span class="string">       mv ROOT.war /tmp/new_root</span></span><br><span class="line"><span class="string">       mv &#123;&#123; backup_dir &#125;&#125;/&#123;&#123; backup_filename &#125;&#125; ROOT.war</span></span><br><span class="line"><span class="string">       pid=\$(ps -ef |grep &#123;&#123; tomcat_dir &#125;&#125; |egrep -v &#x27;grep&#x27; |awk &#x27;&#123;print \$2&#125;&#x27;)</span></span><br><span class="line"><span class="string">       [ -n &quot;</span>\<span class="variable">$pid</span><span class="string">&quot; ] &amp;&amp; kill -9 \$pid</span></span><br><span class="line"><span class="string">       export JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">       nohup &#123;&#123; tomcat_dir &#125;&#125;/bin/startup.sh</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                // ===========================================</span><br><span class="line">            	ansiblePlaybook( </span><br><span class="line">                playbook: <span class="string">&#x27;/opt/jenkins/.playbook.yaml&#x27;</span>,</span><br><span class="line">                inventory: <span class="string">&#x27;/opt/jenkins/.hosts&#x27;</span>, </span><br><span class="line">                credentialsId: <span class="string">&quot;<span class="variable">$&#123;ansible_ssh_auth&#125;</span>&quot;</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终实现如下：</p>
<p><img src="/images/745F05BF5C64435BAC10D759F43CEA24clipboard.png" alt></p>
<p>3.验证结果：</p>
<p>模拟场景：公司一套软件要发布上线，代码测试后发布开始构建部署，此次代码版本稳定运行。后期更新了新的功能，要开始第二次的构建部署（代码更新），发布上线后出现了严重的bug，需要回退到上一个版本，那么此时进入回滚项目，选择要回滚的代码版本即可回滚到上一个版本，保障业务能够正常运行。</p>
<p>①发布一次构建代码(查看页面功能）—&gt;②修改代码—&gt;再次构建代码（查看页面功能出现了严重bug）—&gt;③开始回滚—&gt;选择要回滚的上一次的代码版本—&gt;开始构建</p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ansible监控100台机器</title>
    <url>/2021/09/10/%E5%9F%BA%E4%BA%8Eansible%E7%9B%91%E6%8E%A7100%E5%8F%B0%E6%9C%BA%E5%99%A8/</url>
    <content><![CDATA[<p><img src="/images/937F544327594D01A636D97EB3BEC61Dclipboard.png" alt></p>
<p>consul服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基于consul的服务发现</span></span><br><span class="line"><span class="comment">#Consul是一个分布式的服务发现和键/值存储系统。</span></span><br><span class="line"><span class="comment">#Docker部署Consul：（任意机器部署，只要prometheus和被监控端能够和consul通信即可</span></span><br><span class="line">docker run --name consul -d -p 8500:8500 consul</span><br></pre></td></tr></table></figure>
<p>prometheus服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务端配置</span></span><br><span class="line">vim /opt/monitor/prometheus/prometheus.yml</span><br><span class="line">scrape_configs:</span><br><span class="line">   - job_name: <span class="string">&#x27;webservers&#x27;</span>   <span class="comment">#job名称，一般定义一个分组的名称</span></span><br><span class="line">     basic_auth:</span><br><span class="line">        username: prometheus      <span class="comment">#指定被监控端接口指标的用户名</span></span><br><span class="line">        password: 123.com         <span class="comment">#指定被监控端接口指标的密码</span></span><br><span class="line">     consul_sd_configs:</span><br><span class="line">     - server: 192.168.0.11:8500   <span class="comment">#consul服务发现的地址及端口</span></span><br><span class="line">      services: [<span class="string">&#x27;webservers&#x27;</span>]     <span class="comment">#consul中显示服务名</span></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"><span class="comment">#配置完成后，使用promtool工具检查配置文件是否有误</span></span><br><span class="line"><span class="built_in">cd</span> /opt/monitor/prometheus</span><br><span class="line">./promtool check config ./prometheus.yml </span><br><span class="line"><span class="comment">#查看prometheus的进程id,上面修改配置进行热加载配置</span></span><br><span class="line">ps -ef |grep prometheus</span><br><span class="line"><span class="built_in">kill</span> -HUP 62291 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ansible服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#部署ansible</span></span><br><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install ansible</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个目录，存放ansible执行相关的文件，部署包等</span></span><br><span class="line"><span class="built_in">mkdir</span> ansible</span><br><span class="line"><span class="built_in">cd</span> ansible</span><br><span class="line"><span class="comment">#这个目录下有以下文件：  </span></span><br><span class="line">1.node_exporter-1.0.1.linux-amd64.tar.gz   <span class="comment">#采集器部署包</span></span><br><span class="line">2.node_exporter.service  <span class="comment">#将node_exporter纳入system管理的系统服务</span></span><br><span class="line">3.config.yml    <span class="comment">#用于存放用户名密码认证的文件</span></span><br><span class="line">4.consul-register.sh   <span class="comment">#被监控端注册到consul的脚本信息</span></span><br><span class="line">5.hosts    <span class="comment">#用户存放ansible管理的主机组信息，资产清单</span></span><br><span class="line">6.playbook.yaml  <span class="comment">#用于存放ansible执行的相关的操作具体步骤，相当于说明书</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以上文件准备好后，开始执行部署</span></span><br><span class="line">ansible-playbook -i hosts playbook.yaml -u root -k</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面进行对以上文件进行详细介绍</p>
<p>1.准备采集器部署包</p>
<p>2.node_exporter.service</p>
<p>解释：</p>
<p>–web.config：指定的是用户名密码配置文件</p>
<p>–collector.systemd：采集systemd管理的系统服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat node_exporter.service </span></span><br><span class="line">[Unit]</span><br><span class="line">Description=node_exporter</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/node_exporter/node_exporter --web.config=/usr/local/node_exporter/config.yml --collector.systemd --collector.systemd.unit-whitelist=(docker|sshd|nginx).service </span><br><span class="line">ExecReload=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.config.yml</p>
<p>下面的密码是用httpd-tools工具生成的</p>
<p>yum install httpd-tools –y</p>
<p>htpasswd -nBC 12 ‘’ | tr -d ‘:\n’</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat config.yml </span></span><br><span class="line">basic_auth_users:</span><br><span class="line">  prometheus: $2y$12<span class="variable">$ctQIqhh5l4qcSFAenR30eubhiVg4O71KHzl5N9MkuqTua72P7KPuy</span> </span><br></pre></td></tr></table></figure>
<p><a href="http://4.consul-register.sh">4.consul-register.sh</a></p>
<p>定义位置参数</p>
<p>$1 在shell中传入“位置参数”，表示传入的第一个参数，以此类推</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat consul-register.sh </span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#service_name表示的是consul中定义的服务名</span></span><br><span class="line">service_name=<span class="variable">$1</span></span><br><span class="line"><span class="comment">#instance_id表示的是consul中定义的实例名</span></span><br><span class="line">instance_id=<span class="variable">$2</span></span><br><span class="line">ip=<span class="variable">$3</span></span><br><span class="line">port=<span class="variable">$4</span></span><br><span class="line"></span><br><span class="line">curl -X PUT -d <span class="string">&#x27;&#123;&quot;id&quot;: &quot;&#x27;</span><span class="string">&quot;<span class="variable">$instance_id</span>&quot;</span><span class="string">&#x27;&quot;,&quot;name&quot;: &quot;&#x27;</span><span class="string">&quot;<span class="variable">$service_name</span>&quot;</span><span class="string">&#x27;&quot;,&quot;address&quot;: &quot;&#x27;</span><span class="string">&quot;<span class="variable">$ip</span>&quot;</span><span class="string">&#x27;&quot;,&quot;port&quot;: &#x27;</span><span class="string">&quot;<span class="variable">$port</span>&quot;</span><span class="string">&#x27;,&quot;tags&quot;: [&quot;&#x27;</span><span class="string">&quot;<span class="variable">$service_name</span>&quot;</span><span class="string">&#x27;&quot;],&quot;checks&quot;: [&#123;&quot;http&quot;: &quot;http://&#x27;</span><span class="string">&quot;<span class="variable">$ip</span>&quot;</span><span class="string">&#x27;:&#x27;</span><span class="string">&quot;<span class="variable">$port</span>&quot;</span><span class="string">&#x27;&quot;,&quot;interval&quot;: &quot;5s&quot;&#125;]&#125;&#x27;</span> http://192.168.0.11:8500/v1/agent/service/register</span><br></pre></td></tr></table></figure>
<p>5.hosts</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat hosts </span></span><br><span class="line">[webservers]</span><br><span class="line">192.168.0.12 name=web1</span><br><span class="line">192.168.0.13 name=web2</span><br><span class="line"><span class="comment">########################################</span></span><br><span class="line"><span class="comment">#可以定义多个组，分组的形式去监控</span></span><br><span class="line">[dbbservers]</span><br><span class="line">192.168.0.12 name=db1</span><br><span class="line">192.168.0.13 name=db2</span><br><span class="line">[loadbalances]</span><br><span class="line">192.168.0.12 name=lb1</span><br><span class="line">192.168.0.13 name=lb2</span><br></pre></td></tr></table></figure>
<p>6.playbook.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat playbook.yaml </span></span><br><span class="line">- hosts: webservers</span><br><span class="line">  gather_facts: no</span><br><span class="line">  tasks:</span><br><span class="line">  - name: stop firewalld</span><br><span class="line">    systemd: name=firewalld state=stopped </span><br><span class="line">  - name: 推送二进制文件</span><br><span class="line">    unarchive: src=node_exporter-1.0.1.linux-amd64.tar.gz dest=/usr/local</span><br><span class="line">  - name: 重命名</span><br><span class="line">    shell: |</span><br><span class="line">         ntpdate ntp1.aliyun.com</span><br><span class="line">         <span class="built_in">cd</span> /usr/local</span><br><span class="line">         <span class="keyword">if</span> [ ! -d node_exporter ];<span class="keyword">then</span></span><br><span class="line">             <span class="built_in">mv</span> node_exporter-1.0.1.linux-amd64 node_exporter</span><br><span class="line">         <span class="keyword">fi</span></span><br><span class="line">  - name: 推送配置文件</span><br><span class="line">    copy: src=config.yml dest=/usr/local/node_exporter</span><br><span class="line">  - name: 拷贝systemd文件</span><br><span class="line">    copy: src=node_exporter.service dest=/usr/lib/systemd/system</span><br><span class="line">  - name: 启动服务</span><br><span class="line">    systemd: name=node_exporter state=restarted enabled=<span class="built_in">yes</span> daemon_reload=<span class="built_in">yes</span></span><br><span class="line">  - name: 推送注册脚本</span><br><span class="line">    copy: src=consul-register.sh dest=/usr/local/bin/</span><br><span class="line">  - name: 注册当前节点   </span><br><span class="line">    <span class="comment"># 服务名 实例名 IP 端口 </span></span><br><span class="line">    shell: /bin/bash /usr/local/bin/consul-register.sh &#123;&#123; group_names[0] &#125;&#125; &#123;&#123; name &#125;&#125; &#123;&#123; inventory_hostname &#125;&#125; 9100    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>web服务器---------&gt;要监控的web服务器</p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Docker构建企业Jenkins平台</title>
    <url>/2022/05/27/%E5%9F%BA%E4%BA%8Edocker%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9Ajenkins%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<p>CI/CD概述</p>
<p>持续集成（Continuous Integration，CI）：代码合并、构建、部署、测试都在一起，不断地执行这个过程，并对结果反馈。</p>
<p>持续部署（Continuous Deployment，CD）：部署到测试环境、预生产环境、生产环境。</p>
<p>持续交付（Continuous Delivery，CD）：将最终产品发布到生产环境，给用户使用。</p>
<p><img src="/images/D06234A999FE473FBA13400A79F2390Aclipboard.png" alt></p>
<p>CI工作流程设计</p>
<p><img src="/images/3C3FFAC3EFE24641B2E3746166FFDD5Eclipboard.png" alt></p>
<p>开发者提交代码到gitlab仓库，gitlab随后触发jenkins代码编译，构建镜像以及推送镜像到harbor仓库，紧接着Jenkins部署到docker主机（从harbor仓库拉取镜像到本地部署启动）。</p>
<table>
<thead>
<tr>
<th>gitlab主机</th>
<th>jenkins主机</th>
<th>harbor主机</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.0.11/24</td>
<td>192.168.0.13/24</td>
<td>192.168.0.12/24</td>
</tr>
</tbody>
</table>
<pre><code>                                                       项目环境表
</code></pre>
<p>1、部署Gitlab</p>
<p>1.1 部署Gitlab</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> gitlab</span><br><span class="line"><span class="built_in">cd</span> gitlab</span><br><span class="line">docker run -d \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  -p 8443:443 \</span><br><span class="line">  -p 9999:80 \</span><br><span class="line">  -p 9998:22 \</span><br><span class="line">  -v <span class="variable">$PWD</span>/config:/etc/gitlab \</span><br><span class="line">  -v <span class="variable">$PWD</span>/logs:/var/log/gitlab \</span><br><span class="line">  -v <span class="variable">$PWD</span>/data:/var/opt/gitlab \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  --restart=always \</span><br><span class="line">  lizhenliang/gitlab-ce-zh:latest</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://IP:9999">http://IP:9999</a></p>
<p>初次会先设置管理员密码 ，然后登陆，默认管理员用户名root，密码就是刚设置的。</p>
<p>1.2 创建项目，提交测试代码</p>
<p>进入后先创建项目，提交代码，以便后面测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip tomcat-java-demo-master.zip</span><br><span class="line"><span class="built_in">cd</span> tomcat-java-demo-master</span><br><span class="line">git init</span><br><span class="line">git remote add origin http://192.168.0.11:9999/root/java-demo.git</span><br><span class="line">git add .</span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git commit -m <span class="string">&#x27;all&#x27;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>2、部署Harbor镜像仓库</p>
<p>2.1 安装docker与docker-compose</p>
<p>2.2 解压离线包部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar zxvf harbor-offline-installer-v2.0.0.tgz</span></span><br><span class="line"><span class="comment"># cd harbor</span></span><br><span class="line"><span class="comment"># cp harbor.yml.tmpl harbor.yml</span></span><br><span class="line"><span class="comment"># vi harbor.yml</span></span><br><span class="line">hostname: reg.ctnrs.com</span><br><span class="line">https:   <span class="comment"># 先注释https相关配置</span></span><br><span class="line">harbor_admin_password: Harbor12345</span><br><span class="line"><span class="comment"># ./prepare</span></span><br><span class="line"><span class="comment"># ./install.sh</span></span><br></pre></td></tr></table></figure>
<p>2.3 在Jenkins主机配置Docker可信任，如果是HTTPS需要拷贝证书</p>
<p>由于habor未配置https，还需要在docker配置可信任。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/docker/daemon.json </span></span><br><span class="line">&#123;<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.0.12&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<p>2.4 构建tomcat镜像并上传到harbor仓库上（供jenkinsfile脚本调用）</p>
<p>#准备的安装包（apache-tomcat-8.5.43.tar.gz）和Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.ctnrs.com</span><br><span class="line"></span><br><span class="line">ENV VERSION=8.5.43</span><br><span class="line"></span><br><span class="line">RUN yum install java-1.8.0-openjdk wget curl unzip iproute net-tools -y &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span>.tar.gz /usr/local/</span><br><span class="line">RUN <span class="built_in">mv</span> /usr/local/apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span> /usr/local/tomcat &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">&#x27;1a JAVA_OPTS=&quot;-Djava.security.egd=file:/dev/./urandom&quot;&#x27;</span> /usr/local/tomcat/bin/catalina.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/tomcat/bin</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/local/tomcat</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [<span class="string">&quot;catalina.sh&quot;</span>, <span class="string">&quot;run&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构建并上传到harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t 192.168.0.12/library/tomcat:v1 .</span><br><span class="line">docker login 192.168.0.12</span><br><span class="line">docker /images</span><br><span class="line">docker push 192.168.0.12/library/tomcat:v1</span><br></pre></td></tr></table></figure>
<p><img src="/images/725360157F1C4DF0B88A2EDA4C641CA8clipboard.png" alt></p>
<p>3、部署Jenkins</p>
<p>3.1 准备JDK和Maven环境</p>
<p>将二进制包上传到服务器并解压到工作目录，用于让Jenkins容器挂载使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar zxvf jdk-8u45-linux-x64.tar.gz</span></span><br><span class="line"><span class="comment"># mv jdk1.8.0_45 /usr/local/jdk</span></span><br><span class="line"><span class="comment"># tar zxf apache-maven-3.5.0-bin.tar.gz</span></span><br><span class="line"><span class="comment"># mv apache-maven-3.5.0 /usr/local/maven</span></span><br></pre></td></tr></table></figure>
<p>修改Maven源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/local/maven/conf/setting.xml</span><br><span class="line"></span><br><span class="line">&lt;mirrors&gt;</span><br><span class="line"></span><br><span class="line">&lt;mirror&gt;     </span><br><span class="line">  &lt;<span class="built_in">id</span>&gt;central&lt;/id&gt;     </span><br><span class="line">  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;     </span><br><span class="line">  &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;     </span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure>
<p>部署jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name jenkins -p 80:8080 -p 50000:50000 -u root  \</span><br><span class="line">   -v /opt/jenkins_home:/var/jenkins_home \</span><br><span class="line">   -v /var/run/docker.sock:/var/run/docker.sock   \</span><br><span class="line">   -v /usr/bin/docker:/usr/bin/docker \</span><br><span class="line">   -v /usr/local/maven:/usr/local/maven \</span><br><span class="line">   -v /usr/local/jdk:/usr/local/jdk \</span><br><span class="line">   -v /etc/localtime:/etc/localtime \</span><br><span class="line">   --restart=always \</span><br><span class="line">   --name jenkins jenkins/jenkins</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://IP">http://IP</a></p>
<p>3.2 安装插件</p>
<p>管理Jenkins-&gt;系统配置–&gt;管理插件**–&gt;搜索git/pipeline，选中点击安装。</p>
<p>默认从国外网络下载插件，会比较慢，建议修改国内源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/jenkins_home/updates</span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27;</span> default.json &amp;&amp; \</span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27;</span> default.json</span><br><span class="line"></span><br><span class="line">docker restart jenkins</span><br></pre></td></tr></table></figure>
<p>3.3 Jenkins Pipeline介绍</p>
<p>Jenkins Pipeline是一套插件，支持在Jenkins中实现集成和持续交付管道；</p>
<p>Pipeline通过特定语法对简单到复杂的传输管道进行建模；</p>
<p>声明式：遵循与Groovy相同语法。pipeline { }</p>
<p>脚本式：支持Groovy大部分功能，也是非常表达和灵活的工具。node { }</p>
<p>Jenkins Pipeline的定	义被写入一个文本文件，称为Jenkinsfile。</p>
<p><img src="/images/A721BDDA11234FEFBB2D6AFBA3C673CAclipboard.png" alt></p>
<p><img src="/images/3EAC878934A84E509B25BFCF9A463E62clipboard.png" alt></p>
<p><img src="/images/A3A3BF02751C4D79B7ACEC54F86C0CDFclipboard.png" alt></p>
<p>注意： 发布之前可以在jenkins主机上测试一下是否能登录harbor仓库</p>
<p>如果不能登录报错为连接443拒绝，那么请使用以下方式解决：</p>
<p>修改Docker启动文件添加“–insecure-registry 192.168.0.12”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service </span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry 192.168.0.12</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>4、发布测试</p>
<p>4.1添加连接git仓库凭据和harbor仓库凭据</p>
<p>管理Jenkins-&gt;安全–&gt;管理凭据-&gt;Jnekins-&gt;添加凭据-&gt;Username with password</p>
<ul>
<li>
<p>Username：用户名</p>
</li>
<li>
<p>Password：密码</p>
</li>
<li>
<p>ID：留空</p>
</li>
<li>
<p>Description：描述</p>
</li>
</ul>
<p>分别添加连接git和harbor凭据，并修改脚本为实际凭据ID。</p>
<p><img src="/images/028FE8C5C63C44E19CBEECC88334DC65clipboard.png" alt></p>
<p>4.2 创建项目并配置</p>
<p>New Item -&gt; Pipeline -&gt; This project is parameterized -&gt; String Parameter</p>
<ul>
<li>
<p>Name：Branch    # 变量名，下面脚本中调用</p>
</li>
<li>
<p>Default Value：master   # 默认分支</p>
</li>
<li>
<p>Description：发布的代码分支  # 描述</p>
</li>
</ul>
<p><img src="/images/7A9EA62F8A9F4D97991A4AB427F6EDC5clipboard.png" alt></p>
<p>4.3 Pipeline脚本（在Jenkins本地机器上部署并启动容器）</p>
<p>一. 添加注释方便查看使用说明（添加注释到jenkins执行会报错，请使用第二个构建）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line"></span><br><span class="line">def registry = <span class="string">&quot;192.168.0.12&quot;</span>      <span class="comment">#harbor仓库地址</span></span><br><span class="line">def project = <span class="string">&quot;dev&quot;</span>                <span class="comment">#harbor仓库项目名</span></span><br><span class="line">def app_name = <span class="string">&quot;java-demo&quot;</span>         <span class="comment">#镜像的应用名</span></span><br><span class="line">def image_name = <span class="string">&quot;<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/<span class="variable">$&#123;app_name&#125;</span>:<span class="variable">$&#123;Branch&#125;</span>-<span class="variable">$&#123;BUILD_NUMBER&#125;</span>&quot;</span>  <span class="comment">#Branch代表引用的分支名</span></span><br><span class="line">                                                                                 <span class="comment">#BUILD_NUMBER代表构建编号</span></span><br><span class="line">def git_address = <span class="string">&quot;http://192.168.0.11:9999/root/java-demo.git&quot;</span>        <span class="comment">#git仓库连接地址</span></span><br><span class="line">def docker_registry_auth = <span class="string">&quot;30fae7e1-22c4-4083-848f-a5e90eff9e1f&quot;</span>      <span class="comment">#harbor仓库认证（用户名和密码）</span></span><br><span class="line">def git_auth = <span class="string">&quot;05750892-5303-49ab-a6d0-33a78ef6c839&quot;</span>                  <span class="comment">#git仓库认证（用户名和密码）</span></span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">              checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;$&#123;Branch&#125;&#x27;</span>]], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_auth&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_address&#125;</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;代码编译&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">             sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                pwd</span></span><br><span class="line"><span class="string">                ls</span></span><br><span class="line"><span class="string">                JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">                PATH=<span class="variable">$JAVA_HOME</span>/bin:/usr/local/maven/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="string">                mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span> </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;构建镜像&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&quot;<span class="variable">$&#123;docker_registry_auth&#125;</span>&quot;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  echo &#x27;</span></span><br><span class="line"><span class="string">                    FROM <span class="variable">$&#123;registry&#125;</span>/library/tomcat:v1</span></span><br><span class="line"><span class="string">                    LABEL maitainer liuzhe</span></span><br><span class="line"><span class="string">                    RUN rm -rf /usr/local/tomcat/webapps/*</span></span><br><span class="line"><span class="string">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">                  &#x27; &gt; Dockerfile</span></span><br><span class="line"><span class="string">                  docker build -t <span class="variable">$&#123;image_name&#125;</span> .</span></span><br><span class="line"><span class="string">                  docker login -u <span class="variable">$&#123;username&#125;</span> -p &#x27;<span class="variable">$&#123;password&#125;</span>&#x27; <span class="variable">$&#123;registry&#125;</span></span></span><br><span class="line"><span class="string">                  docker push <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;部署到Docker&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">              sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">              docker rm -f tomcat-java-demo |true</span></span><br><span class="line"><span class="string">              docker container run -d --name tomcat-java-demo -p 88:8080 <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">              &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二.请使用这个pipeline脚本构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line"></span><br><span class="line">def registry = <span class="string">&quot;192.168.0.12&quot;</span>      </span><br><span class="line">def project = <span class="string">&quot;dev&quot;</span>                </span><br><span class="line">def app_name = <span class="string">&quot;java-demo&quot;</span>        </span><br><span class="line">def image_name = <span class="string">&quot;<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/<span class="variable">$&#123;app_name&#125;</span>:<span class="variable">$&#123;Branch&#125;</span>-<span class="variable">$&#123;BUILD_NUMBER&#125;</span>&quot;</span>                                                                                </span><br><span class="line">def git_address = <span class="string">&quot;http://192.168.0.11:9999/root/java-demo.git&quot;</span>      </span><br><span class="line">def docker_registry_auth = <span class="string">&quot;30fae7e1-22c4-4083-848f-a5e90eff9e1f&quot;</span>     </span><br><span class="line">def git_auth = <span class="string">&quot;05750892-5303-49ab-a6d0-33a78ef6c839&quot;</span>                  </span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">              checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;$&#123;Branch&#125;&#x27;</span>]], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_auth&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_address&#125;</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;代码编译&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">             sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                pwd</span></span><br><span class="line"><span class="string">                ls</span></span><br><span class="line"><span class="string">                JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">                PATH=<span class="variable">$JAVA_HOME</span>/bin:/usr/local/maven/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="string">                mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span> </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;构建镜像&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&quot;<span class="variable">$&#123;docker_registry_auth&#125;</span>&quot;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  echo &#x27;</span></span><br><span class="line"><span class="string">                    FROM <span class="variable">$&#123;registry&#125;</span>/library/tomcat:v1</span></span><br><span class="line"><span class="string">                    LABEL maitainer liuzhe</span></span><br><span class="line"><span class="string">                    RUN rm -rf /usr/local/tomcat/webapps/*</span></span><br><span class="line"><span class="string">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">                  &#x27; &gt; Dockerfile</span></span><br><span class="line"><span class="string">                  docker build -t <span class="variable">$&#123;image_name&#125;</span> .</span></span><br><span class="line"><span class="string">                  docker login -u <span class="variable">$&#123;username&#125;</span> -p &#x27;<span class="variable">$&#123;password&#125;</span>&#x27; <span class="variable">$&#123;registry&#125;</span></span></span><br><span class="line"><span class="string">                  docker push <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;部署到Docker&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">              sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">              docker rm -f tomcat-java-demo |true</span></span><br><span class="line"><span class="string">              docker container run -d --name tomcat-java-demo -p 88:8080 <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">              &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述脚本中，docker_registry_auth 和git_auth变量的值为Jenkins凭据ID，添加凭据后修改。</p>
<p>4.4 Pipeline脚本（ 在其他的Docker主机上部署并启动容器）</p>
<p>安装jenkins插件</p>
<p>插件名称： SSH Pipeline Steps</p>
<p>使用说明: <a href="https://github.com/jenkinsci/ssh-steps-plugin#pipeline-steps">https://github.com/jenkinsci/ssh-steps-plugin#pipeline-steps</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line"></span><br><span class="line">def registry = <span class="string">&quot;192.168.0.12&quot;</span>      </span><br><span class="line">def project = <span class="string">&quot;dev&quot;</span>                </span><br><span class="line">def app_name = <span class="string">&quot;java-demo&quot;</span>        </span><br><span class="line">def image_name = <span class="string">&quot;<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/<span class="variable">$&#123;app_name&#125;</span>:<span class="variable">$&#123;Branch&#125;</span>-<span class="variable">$&#123;BUILD_NUMBER&#125;</span>&quot;</span>                                                                                </span><br><span class="line">def git_address = <span class="string">&quot;http://192.168.0.11:9999/root/java-demo.git&quot;</span>      </span><br><span class="line">def docker_registry_auth = <span class="string">&quot;30fae7e1-22c4-4083-848f-a5e90eff9e1f&quot;</span>     </span><br><span class="line">def git_auth = <span class="string">&quot;05750892-5303-49ab-a6d0-33a78ef6c839&quot;</span>   </span><br><span class="line">def remote = [:]</span><br><span class="line">    remote.name = <span class="string">&quot;test&quot;</span></span><br><span class="line">    remote.host = <span class="string">&quot;192.168.0.12&quot;</span></span><br><span class="line">    remote.user = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">    remote.password = <span class="string">&#x27;123.com&#x27;</span></span><br><span class="line">    remote.allowAnyHosts = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">              checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;$&#123;Branch&#125;&#x27;</span>]], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_auth&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_address&#125;</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;代码编译&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">             sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                pwd</span></span><br><span class="line"><span class="string">                ls</span></span><br><span class="line"><span class="string">                JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">                PATH=<span class="variable">$JAVA_HOME</span>/bin:/usr/local/maven/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="string">                mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span> </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;构建镜像&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&quot;<span class="variable">$&#123;docker_registry_auth&#125;</span>&quot;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  echo &#x27;</span></span><br><span class="line"><span class="string">                    FROM <span class="variable">$&#123;registry&#125;</span>/library/tomcat:v1</span></span><br><span class="line"><span class="string">                    LABEL maitainer liuzhe</span></span><br><span class="line"><span class="string">                    RUN rm -rf /usr/local/tomcat/webapps/*</span></span><br><span class="line"><span class="string">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">                  &#x27; &gt; Dockerfile</span></span><br><span class="line"><span class="string">                  docker build -t <span class="variable">$&#123;image_name&#125;</span> .</span></span><br><span class="line"><span class="string">                  docker login -u <span class="variable">$&#123;username&#125;</span> -p &#x27;<span class="variable">$&#123;password&#125;</span>&#x27; <span class="variable">$&#123;registry&#125;</span></span></span><br><span class="line"><span class="string">                  docker push <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;部署到Docker&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                sshCommand remote: remote, <span class="built_in">command</span>: <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                ip a</span></span><br><span class="line"><span class="string">                docker rm -f tomcat-java-demo |true</span></span><br><span class="line"><span class="string">                docker pull <span class="variable">$&#123;image_name&#125;</span> </span></span><br><span class="line"><span class="string">                docker container run -d --name tomcat-java-demo -p 88:8080 <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">               &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">           &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<p>1.访问harbor仓库查看是否有上传的镜像    <a href="http://192.168.0.12/">http://192.168.0.12/</a></p>
<p><img src="/images/04418B7661DC49D1AD92114AC38F5A64clipboard.png" alt></p>
<p>2.docker主机上运行的项目镜像容器</p>
<p><img src="/images/03E31D0090E748B5B3B8416B4C4EEC4Cclipboard.png" alt></p>
<p>3.访问部署java-demo示例     <a href="http://192.168.0.13:88/">http://192.168.0.13:88/</a></p>
<p><img src="/images/5DF2722940214B15AB62A6AA70E96839clipboard.png" alt></p>
<p>CI/CD收益</p>
<p>高效的CI/CD环境可以获得：</p>
<p>1.及时发现问题</p>
<p>2.大幅度减少故障率</p>
<p>3.加快迭代速度</p>
<p>4.减少时间成本</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Jenkins发布微服务</title>
    <url>/2021/10/02/%E5%9F%BA%E4%BA%8Ejenkins%E5%8F%91%E5%B8%83%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p><img src="/images/38E37D9AE37B4AE0A516F9D23F6B4FB8clipboard.png" alt></p>
<p>ansible-yum源：</p>
<p>wget -O /etc/yum.repos.d/epel.repo <a href="http://mirrors.aliyun.com/repo/epel-7.repo">http://mirrors.aliyun.com/repo/epel-7.repo</a></p>
<p>1.安装相关的插件</p>
<p>pipeline、git、git parameter 、extended choice parameter、ansible</p>
<p>2.生成相关插件的语法：</p>
<p>git parameter</p>
<p><img src="/images/A378D5F638884B04B75B74FB98903F93clipboard.png" alt></p>
<p>extended choice parameter</p>
<p><img src="/images/E245E8D05142429D9E69B929CA50A8BAclipboard.png" alt></p>
<p>choice选项参数</p>
<p><img src="/images/3992492938B147ED90FD3CD1C5A8049Eclipboard.png" alt></p>
<p>git</p>
<p><img src="/images/162EB39984224B9598AA25D28A787DE5clipboard.png" alt></p>
<p>3.编写流水线脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        label <span class="string">&quot;test1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    environment &#123;</span><br><span class="line">        git_address = <span class="string">&quot;http://192.168.0.11/my-group/ms.git&quot;</span></span><br><span class="line">        git_password = <span class="string">&quot;c601674b-44e0-45a2-aaba-3f476e2c3c51&quot;</span></span><br><span class="line">        ansible_ssh_auth = <span class="string">&quot;242dbf20-4e53-4fa1-b8e7-1479e0a51572&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">        gitParameter branch: <span class="string">&#x27;&#x27;</span>, branchFilter: <span class="string">&#x27;origin/(.*)&#x27;</span>, defaultValue: <span class="string">&#x27;origin/master&#x27;</span>, description: <span class="string">&#x27;请选择你要发布的分支：&#x27;</span>, name: <span class="string">&#x27;branch&#x27;</span>, quickFilterEnabled: <span class="literal">false</span>, selectedValue: <span class="string">&#x27;NONE&#x27;</span>, sortMode: <span class="string">&#x27;NONE&#x27;</span>, tagFilter: <span class="string">&#x27;*&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;PT_BRANCH&#x27;</span></span><br><span class="line">        extendedChoice description: <span class="string">&#x27;请选择你要发布的微服务:&#x27;</span>, multiSelectDelimiter: <span class="string">&#x27;,&#x27;</span>, name: <span class="string">&#x27;Service&#x27;</span>, quoteValue: <span class="literal">false</span>, saveJSONParameterToFile: <span class="literal">false</span>, <span class="built_in">type</span>: <span class="string">&#x27;PT_CHECKBOX&#x27;</span>, value: <span class="string">&#x27;portal,gateway,product,stock,order&#x27;</span>, visibleItemCount: 5</span><br><span class="line">        choice choices: [<span class="string">&#x27;webservers1&#x27;</span>, <span class="string">&#x27;webservers2&#x27;</span>], description: <span class="string">&#x27;&#x27;</span><span class="string">&#x27;请选择你要发布的服务器组：</span></span><br><span class="line"><span class="string">        [webservers1]</span></span><br><span class="line"><span class="string">        192.168.0.14</span></span><br><span class="line"><span class="string">        [webservers2]</span></span><br><span class="line"><span class="string">        192.168.0.15&#x27;</span><span class="string">&#x27;&#x27;</span>, name: <span class="string">&#x27;Servers&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉去取代码&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">             checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&quot;<span class="variable">$&#123;params.branch&#125;</span>&quot;</span>]], extensions: [], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_password&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_address&#125;</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;编译构建&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&quot;export JAVA_HOME=/usr/local/jdk&quot;</span></span><br><span class="line">                sh <span class="string">&quot;/usr/local/maven/bin/mvn clean package -Dmaven.skip.test=true&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;部署并启动&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                 // 将用户选择的微服务的构建文件拷贝到临时目录，以便ansible统一推送</span><br><span class="line">                // Service=portal,gateway,product,stock,order</span><br><span class="line">                script &#123;</span><br><span class="line">                    def tmp_dir = <span class="string">&quot;<span class="variable">$WORKSPACE</span>/tmp&quot;</span></span><br><span class="line">                    def services = <span class="string">&quot;<span class="variable">$Service</span>&quot;</span>.<span class="built_in">split</span>(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                    <span class="keyword">for</span>(name <span class="keyword">in</span> services) &#123;</span><br><span class="line">                        sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                        echo <span class="variable">$name</span></span></span><br><span class="line"><span class="string">                        pwd</span></span><br><span class="line"><span class="string">                        ls</span></span><br><span class="line"><span class="string">                        mkdir <span class="variable">$tmp_dir</span> |true</span></span><br><span class="line"><span class="string">                        cd <span class="variable">$name</span>-service</span></span><br><span class="line"><span class="string">                        if ls |grep biz &amp;&gt;/dev/null;then</span></span><br><span class="line"><span class="string">                           cd <span class="variable">$name</span>-service-biz</span></span><br><span class="line"><span class="string">                        fi</span></span><br><span class="line"><span class="string">                        mv target/*.jar <span class="variable">$tmp_dir</span></span></span><br><span class="line"><span class="string">                        ls <span class="variable">$tmp_dir</span></span></span><br><span class="line"><span class="string">                        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 生成主机清单文件和playbook</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">cat &gt; /opt/jenkins/.hosts &lt;&lt; EOF</span></span><br><span class="line"><span class="string">[webservers1]</span></span><br><span class="line"><span class="string">192.168.0.14</span></span><br><span class="line"><span class="string">[webservers2]</span></span><br><span class="line"><span class="string">192.168.0.15</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">cat &gt; /opt/jenkins/.playbook.yaml &lt;&lt;EOF</span></span><br><span class="line"><span class="string">- hosts: <span class="variable">$Servers</span></span></span><br><span class="line"><span class="string">  gather_facts: no</span></span><br><span class="line"><span class="string">  vars:</span></span><br><span class="line"><span class="string">    workspace: <span class="variable">$WORKSPACE</span></span></span><br><span class="line"><span class="string">    work_dir: &quot;</span>/data/ms<span class="string">&quot;</span></span><br><span class="line"><span class="string">    service_name: <span class="variable">$Service</span>  # Service=portal,gateway,product,stock,order</span></span><br><span class="line"><span class="string">  tasks:</span></span><br><span class="line"><span class="string">  - name: 推送构建文件 </span></span><br><span class="line"><span class="string">    copy:</span></span><br><span class="line"><span class="string">      src=&#123;&#123; item &#125;&#125;</span></span><br><span class="line"><span class="string">      dest=&#123;&#123; work_dir &#125;&#125;/&#123;&#123; item.split(&quot;</span>/<span class="string">&quot;)[-1].split(&quot;</span>-<span class="string">&quot;)[0] &#125;&#125;           #取的是最后一个数组中的第一个字符串</span></span><br><span class="line"><span class="string">    with_fileglob:</span></span><br><span class="line"><span class="string">      - &quot;</span>&#123;&#123; workspace &#125;&#125;/tmp/*.jar<span class="string">&quot;      #/opt/jenkins/workspace/weifuwu为工作目录</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  - name: 重启服务</span></span><br><span class="line"><span class="string">    systemd: name=&#123;&#123; item &#125;&#125; state=restarted</span></span><br><span class="line"><span class="string">    loop: &quot;</span>&#123;&#123; service_name.split(<span class="string">&#x27;,&#x27;</span>) &#125;&#125;<span class="string">&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                ansiblePlaybook(</span><br><span class="line">                  playbook: <span class="string">&quot;/opt/jenkins/.playbook.yaml&quot;</span>,</span><br><span class="line">                  inventory: <span class="string">&quot;/opt/jenkins/.hosts&quot;</span>,</span><br><span class="line">                  credentialsId: <span class="string">&quot;<span class="variable">$&#123;ansible_ssh_auth&#125;</span>&quot;</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终效果图如下：</p>
<p><img src="/images/9872827C3AEA48E7AC16CA0095DADAE6clipboard.png" alt></p>
<p>根据用户选择的微服务进行发布升级等操作。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Jenkins构建微服务发布平台</title>
    <url>/2023/12/15/%E5%9F%BA%E4%BA%8Ejenkins%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h2 id="发布流程设计">发布流程设计</h2>
<p><img src="/images/B2F7E8D287EA48A3925A323A7330F159clipboard.png" alt></p>
<h2 id="准备基础环境：Harbor、Gitlab、Jenkins">准备基础环境：Harbor、Gitlab、Jenkins</h2>
<h3 id="Harbor镜像仓库">Harbor镜像仓库</h3>
<p>项目地址：<a href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p>
<p>1.安装docker与docker-compose</p>
<p>2.解压离线包部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar zxvf harbor-offline-installer-v2.0.0.tgz</span></span><br><span class="line"><span class="comment"># cd harbor</span></span><br><span class="line"><span class="comment"># cp harbor.yml.tmpl harbor.yml</span></span><br><span class="line"><span class="comment"># vi harbor.yml</span></span><br><span class="line">hostname: 192.168.0.14</span><br><span class="line">https:   <span class="comment"># 先注释https相关配置</span></span><br><span class="line">harbor_admin_password: Harbor12345</span><br><span class="line"><span class="comment"># ./prepare</span></span><br><span class="line"><span class="comment"># ./install.sh --with-chartmuseum</span></span><br><span class="line"><span class="comment"># docker-compose ps</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在Jenkins主机配置Docker可信任，如果是HTTPS需要拷贝证书</li>
</ol>
<p>由于habor未配置https，还需要在docker配置可信任。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/docker/daemon.json </span></span><br><span class="line">&#123;<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.0.12&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<h3 id="Gitlab代码仓库">Gitlab代码仓库</h3>
<p>在Gitlab创建一个项目，然后提交微服务项目代码。</p>
<p>如果没有Gitlab可以使用Docker启动一个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt/gitlab </span><br><span class="line">GITLAB_HOME=/opt/gitlab <span class="comment"># 数据持久化目录</span></span><br><span class="line">docker run --detach \</span><br><span class="line">--publish 443:443 \</span><br><span class="line">--publish 88:80 \</span><br><span class="line">--publish 2222:22 \</span><br><span class="line">--name gitlab \</span><br><span class="line">--restart always \</span><br><span class="line">--volume <span class="variable">$GITLAB_HOME</span>/config:/etc/gitlab \</span><br><span class="line">--volume <span class="variable">$GITLAB_HOME</span>/logs:/var/log/gitlab \</span><br><span class="line">--volume <span class="variable">$GITLAB_HOME</span>/data:/var/opt/gitlab \</span><br><span class="line">gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://IP:88">http://IP:88</a></p>
<p>初次会先设置管理员密码 ，然后登陆，默认管理员用户名 root，密码就是刚设置的。</p>
<p><img src="/images/8A7782825408485B8DA8EE01B54B7C6Fclipboard.png" alt></p>
<h3 id="Jenkins-发布系统">Jenkins 发布系统</h3>
<p><img src="/images/8500E07205C24CC18CCB45F93929FA11clipboard.png" alt></p>
<p>Jenkins是一款开源 CI&amp;CD 系统，用于自动化各种任务，包括构建、测试和部署。</p>
<p>Jenkins官方提供了镜像：<a href="https://hub.docker.com/r/jenkins/jenkins">https://hub.docker.com/r/jenkins/jenkins</a></p>
<p>使用Deployment来部署这个镜像，会暴露两个端口：8080 Web访问端口，50000 Slave通 信端口，容器启动后Jenkins数据存储在/var/jenkins_home目录，所以需要将该目录使用 PV持久化存储。</p>
<p>配置PV持久化存储：</p>
<p>1、部署NFS共享服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装nfs安装包（每个k8s节点都要安装）</span></span><br><span class="line">yum install nfs-utils</span><br></pre></td></tr></table></figure>
<p>2、找一个节点作为NFS共享存储服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建nfs共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /ifs/kubernetes/jenkins-data</span><br><span class="line"><span class="comment">#修改nfs配置文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/ifs/kubernetes 192.168.0.0/24(rw,no_root_squash)</span><br><span class="line"><span class="comment">#启动nfs并加入开机自启</span></span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"><span class="comment">#在别的节点验证是否能挂载成功</span></span><br><span class="line">mount -t nfs 192.168.0.13:/ifs/kubernetes /mnt/</span><br><span class="line">umount /mnt/</span><br></pre></td></tr></table></figure>
<p>3、为Jenkins准备PV</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi pv.yaml</span></span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv0001</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  accessModes: [<span class="string">&quot;ReadWriteOnce&quot;</span>]</span><br><span class="line">  nfs:</span><br><span class="line">    path: /ifs/kubernetes/jenkins-data</span><br><span class="line">    server: 192.168.0.13</span><br><span class="line">    </span><br><span class="line"><span class="comment">#kubectl apply -f pv.yaml</span></span><br></pre></td></tr></table></figure>
<p>在k8s中部署jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f jenkins.yml </span><br></pre></td></tr></table></figure>
<p>先安装后面所需的插件：</p>
<p>Jenkins下载插件默认服务器在国外，会比较慢，建议修改国内源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 进入到nfs共享目录</span></span><br><span class="line"><span class="built_in">cd</span> /ifs/kubernetes/jenkins-data</span><br><span class="line">sed -i <span class="string">&#x27;s/https:\/\/updates.jenkins.io\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27;</span> default.json </span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27;</span> default.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除pod重建，pod名称改成你实际的</span></span><br><span class="line">kubectl delete pod jenkins-d58f4db66-9cthj -n ops</span><br></pre></td></tr></table></figure>
<p>管理Jenkins-&gt;系统配置–&gt;管理插件–&gt;分别搜索Git Parameter/Git/Pipeline/kubernetes/Config File Provider， 选中点击安装。</p>
<ul>
<li>
<p>Git：拉取代码</p>
</li>
<li>
<p>Git Parameter：Git参数化构建</p>
</li>
<li>
<p>Pipeline：流水线</p>
</li>
<li>
<p>kubernetes：连接Kubernetes动态创建Slave代理</p>
</li>
<li>
<p>Config File Provider：存储配置文件</p>
</li>
<li>
<p>Extended Choice Parameter：扩展选择框参数，支持多选</p>
</li>
</ul>
<h2 id="Jenkins在K8s中动态创建代理">Jenkins在K8s中动态创建代理</h2>
<h3 id="Jenkins主从架构介绍">Jenkins主从架构介绍</h3>
<p><img src="/images/7F27157BF99A4F6B8BF5BCDE5C165B64clipboard.png" alt></p>
<p>Jenkins Master/Slave架构，Master（Jenkins本身）提供Web页面 让用户来管理项目和从节点（Slave），项目任务可以运行在Master 本机或者分配到从节点运行，一个Master可以关联多个Slave，这样 好处是可以让Slave分担Master工作压力和隔离构建环境。</p>
<p><img src="/images/EB9F74AB19714BC68A48BF040F27BAFAclipboard.png" alt></p>
<p>当触发Jenkins任务时，Jenkins会调用Kubernetes API 创建Slave Pod，Pod启动后会连接Jenkins，接受任务 并处理。</p>
<h3 id="Kubernetes插件配置">Kubernetes插件配置</h3>
<p>Kubernetes插件：用于Jenkins在Kubernetes集群中运行动态代理</p>
<p>插件介绍：<a href="https://github.com/jenkinsci/kubernetes-plugin">https://github.com/jenkinsci/kubernetes-plugin</a></p>
<p>配置插件：管理Jenkins-&gt;管理Nodes和云-&gt;管理云-&gt;添加Kubernetes</p>
<p><img src="/images/64DF0CDB13A542678BB863158428C832clipboard.png" alt></p>
<h3 id="自定义Jenkins-Slave镜像">自定义Jenkins Slave镜像</h3>
<p><img src="/images/2306CE36027E44559E61F897D61DC8C4clipboard.png" alt></p>
<p><a href="/attachments/2F46856C2A2540D8A87DCF2C081ADF24jenkins-slave.zip">jenkins-slave.zip</a></p>
<p>构建salve镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip jenkins-slave.zip </span><br><span class="line"><span class="built_in">cd</span> jenkins-slave/</span><br></pre></td></tr></table></figure>
<p>课件目录里涉及六个文件：</p>
<ul>
<li>
<p>Dockerfile：构建镜像</p>
</li>
<li>
<p>jenkins-slave：shell脚本启动slave.jar，下载地址：<a href="https://github.com/jenkinsci/docker-jnlpslave/blob/master/jenkins-slave">https://github.com/jenkinsci/docker-jnlpslave/blob/master/jenkins-slave</a></p>
</li>
<li>
<p>settings.xml：修改maven官方源为阿里云源</p>
</li>
<li>
<p>slave.jar：agent程序，接受master下发的任务，下载地址:<a href="http://jenkinsip">http://jenkinsip</a>:port/jnlpJars/slave.jar</p>
</li>
<li>
<p>helm和kubectl客户端工具</p>
</li>
</ul>
<p>构建并推送到镜像仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t 192.168.0.14/library/jenkins-slave-jdk:1.8 .</span><br><span class="line">docker push 192.168.0.14/library/jenkins-slave-jdk:1.8</span><br></pre></td></tr></table></figure>
<p><img src="/images/4F2E0C1FDB52491EB084D555FB5714DCclipboard.png" alt></p>
<h3 id="测试主从架构是否正常">测试主从架构是否正常</h3>
<p>新建项目-&gt;流水线-&gt;Pipeline脚本（可生成示例）</p>
<p><img src="/images/3164AADF3CAF40CFA508FCC5C9C1495Aclipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        kubernetes &#123;</span><br><span class="line">            label <span class="string">&quot;jenkins-slave&quot;</span></span><br><span class="line">            yaml <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: jenkins-slave</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  containers:</span></span><br><span class="line"><span class="string">  - name: jnlp</span></span><br><span class="line"><span class="string">    image: &quot;192.168.0.14/library/jenkins-slave-jdk:1.8&quot;</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Main&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;hostname&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Jenkins-Pipeline流水线">Jenkins Pipeline流水线</h2>
<h3 id="Jenkins-Pipeline-介绍">Jenkins Pipeline 介绍</h3>
<p>Jenkins Pipeline是一套运行工作流框架，将原本独立运行单个或者多个节点的任 务链接起来，实现单个任务难以完成的复杂流程编排和可视化。</p>
<ul>
<li>
<p>Jenkins Pipeline是一套插件，支持在Jenkins中实现持续集成和持续交付；</p>
</li>
<li>
<p>Pipeline通过特定语法对简单到复杂的传输管道进行建模；</p>
</li>
<li>
<p>Jenkins Pipeline的定义被写入一个文本文件，称为Jenkinsfile。</p>
</li>
</ul>
<p><img src="/images/7A0E7C80DA0F49268AE4F87D00FE7796clipboard.png" alt></p>
<h3 id="Jenkins-Pipeline-语法">Jenkins Pipeline 语法</h3>
<p><img src="/images/6922CBDC75314869BF4EC5D6B8B586CCclipboard.png" alt></p>
<h3 id="Jenkins-Pipeline-示例">Jenkins Pipeline 示例</h3>
<ul>
<li>
<p>Stages 是 Pipeline 中最主要的组成部分，Jenkins 将会按照 Stages 中描述的顺序 从上往下的执行。</p>
</li>
<li>
<p>Stage：阶段，一个 Pipeline 可以划分为若干个 Stage，每个 Stage 代表一组操作， 比如：Build、Test、Deploy</p>
</li>
<li>
<p>Steps：步骤，Steps 是最基本的操作单元，可以是打印一句话，也可以是构建一 个 Docker 镜像，由各类 Jenkins 插件提供，比如命令：sh ‘mvn’，就相当于我 们平时 shell 终端中执行 mvn命令一样。</p>
</li>
</ul>
<p><img src="/images/D039E5F0FBA7457D81054CA87A761043clipboard.png" alt></p>
<h2 id="流水线自动发布微服务项目">流水线自动发布微服务项目</h2>
<h3 id="发布需求">发布需求</h3>
<p>在将微服务项目自动化部署到K8s平台会有这些需求：</p>
<ul>
<li>
<p>尽量完全自动化部署，无需过多人工干预</p>
</li>
<li>
<p>可以选择升级某个、某些微服务</p>
</li>
<li>
<p>在部署、升级微服务时，可对微服务某些特性做配置，例如命名 空间、副本数量</p>
</li>
</ul>
<p><img src="/images/C157478FA8444B3C8BC50AB432519AC3clipboard.png" alt></p>
<p><img src="/images/F8769BAA03AA41BCAF7F8A7FBE101D13clipboard.png" alt></p>
<h3 id="实现思路">实现思路</h3>
<p>Pipeline编写思路：</p>
<p>在微服务架构中，会涉及几个、几十个微服务，如果每个服务都创建一个item，势必 给运维维护成本增加很大，因此需要编写一个通用Pipeline脚本，将这些微服务部署 差异化部分使用Jenkins参数化，人工交互确认发布的微服务、环境配置等。 但这只是解决用户交互层面，在K8s实际部署项目用YAML创建对应资源，现在问题是 如何接收用户交互参数，自动化生成YAML文件，这就会用到Helm完成YAML文件高 效复用和微服务部署。</p>
<p>部署一个微服务项目，每个微服务的差异化部分在哪里？</p>
<ul>
<li>
<p>服务名称</p>
</li>
<li>
<p>代码版本</p>
</li>
<li>
<p>镜像</p>
</li>
<li>
<p>端口</p>
</li>
<li>
<p>副本数</p>
</li>
<li>
<p>标签</p>
</li>
<li>
<p>域名</p>
</li>
</ul>
<p><img src="/images/41CB808D432741CEADC62C7EC31B02CFclipboard.png" alt></p>
<p><img src="/images/5725CE9936DC44278AB0F3D50A9C0043clipboard.png" alt></p>
<h3 id="编写Pipeline流水线脚本">编写Pipeline流水线脚本</h3>
<p>对于课件中的Pipeline脚本，重点修改这几个变量：</p>
<p><img src="/images/BBB9C34FC8074B8B8F2A8593A0D069D9clipboard.png" alt></p>
<p>1、将harbor认证和gitlab认证保存到Jenkins凭据</p>
<p>管理Jenkins-&gt;安全–&gt;管理凭据-&gt;Jnekins-&gt;添加凭据-&gt;Username with password</p>
<p>分别添加连接gitlab和harbor的用户名到Jenkins凭据，然后获取该凭据ID替换到脚本中docker_registry_auth和git_auth变量的值。</p>
<p><img src="/images/1038F7245A06447F8D9087E37A05849Bclipboard.png" alt></p>
<p>2、将kubeconfig存储在Jenkins，用于slave镜像里kubectl连接k8s集群</p>
<p>管理Jenkins-&gt; Managed files-&gt;Add-&gt;Custom file -&gt;Content字段内容是kubeconfig（kubeadm部署k8s默认路径在master节点 /root/.kube/config，如果你是二进制部署，需要自己生成，参考下面），然后复制ID替换上述脚本中k8s_auth变量的值。</p>
<p>说明：将kubectl、helm工具封装到Slave镜像中，并通过Config File Provider插件存储连接K8s集群的kubeconfig认证文件，然后挂载到 Slave容器中，这样就能用kubectl apply deploy.yaml --kubeconfig=config管理K8s应用了，为提高安全性，kubeconfig文件可分配权限。</p>
<p><img src="/images/8E0858A3DE2A4C5B8F819C098461D101clipboard.png" alt></p>
<p>3.上传 helm chart包到镜像仓库</p>
<p><a href="/attachments/0D60374F19514E8F9EE6A7B512555D72ms-0.1.0.tgz">ms-0.1.0.tgz</a></p>
<p><img src="/images/22F701F84D6D4280B76FE0E49F0002F6clipboard.png" alt></p>
<p>创建命名空间并部署eureka和MySQL服务（记得还要部署ingress控制器）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create namespace ms</span><br><span class="line">kubectl apply -f mysql.yaml</span><br><span class="line"><span class="comment">#启动部署(修改eureka-service微服务yaml文件中的requests，请求资源设置小一点0.2)</span></span><br><span class="line">./docker_build.sh eureka-service</span><br><span class="line">kubectl apply -f ingress-controller.yaml </span><br></pre></td></tr></table></figure>
<p>jenkinsfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line">// 所需插件: Git Parameter/Git/Pipeline/Config File Provider/kubernetes/Extended Choice Parameter</span><br><span class="line">// 公共</span><br><span class="line">def registry = <span class="string">&quot;192.168.0.14&quot;</span></span><br><span class="line">// 项目</span><br><span class="line">def project = <span class="string">&quot;microservice&quot;</span></span><br><span class="line">def git_url = <span class="string">&quot;http://192.168.0.14:88/root/k8s-microservice.git&quot;</span></span><br><span class="line">def gateway_domain_name = <span class="string">&quot;gateway.ctnrs.com&quot;</span></span><br><span class="line">def portal_domain_name = <span class="string">&quot;portal.ctnrs.com&quot;</span></span><br><span class="line">// 认证</span><br><span class="line">def image_pull_secret = <span class="string">&quot;registry-pull-secret&quot;</span></span><br><span class="line">def harbor_auth = <span class="string">&quot;dc8877f5-3238-407f-a9fb-96932501a9b0&quot;</span></span><br><span class="line">def git_auth = <span class="string">&quot;8d022667-0d69-4e5c-a6f8-6d0ac532f596&quot;</span></span><br><span class="line">// ConfigFileProvider ID</span><br><span class="line">def k8s_auth = <span class="string">&quot;cf3c93bc-dc97-4305-8379-53a669a2b2b7&quot;</span></span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">  agent &#123;</span><br><span class="line">    kubernetes &#123;</span><br><span class="line">        label <span class="string">&quot;jenkins-slave&quot;</span></span><br><span class="line">        yaml <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: jenkins-slave</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  containers:</span></span><br><span class="line"><span class="string">  - name: jnlp</span></span><br><span class="line"><span class="string">    image: &quot;</span><span class="variable">$&#123;registry&#125;</span>/library/jenkins-slave-jdk:1.8<span class="string">&quot;</span></span><br><span class="line"><span class="string">    imagePullPolicy: Always</span></span><br><span class="line"><span class="string">    volumeMounts:</span></span><br><span class="line"><span class="string">      - name: docker-cmd</span></span><br><span class="line"><span class="string">        mountPath: /usr/bin/docker</span></span><br><span class="line"><span class="string">      - name: docker-sock</span></span><br><span class="line"><span class="string">        mountPath: /var/run/docker.sock</span></span><br><span class="line"><span class="string">      - name: maven-cache</span></span><br><span class="line"><span class="string">        mountPath: /root/.m2</span></span><br><span class="line"><span class="string">  volumes:</span></span><br><span class="line"><span class="string">    - name: docker-cmd</span></span><br><span class="line"><span class="string">      hostPath:</span></span><br><span class="line"><span class="string">        path: /usr/bin/docker</span></span><br><span class="line"><span class="string">    - name: docker-sock</span></span><br><span class="line"><span class="string">      hostPath:</span></span><br><span class="line"><span class="string">        path: /var/run/docker.sock</span></span><br><span class="line"><span class="string">    - name: maven-cache</span></span><br><span class="line"><span class="string">      hostPath:</span></span><br><span class="line"><span class="string">        path: /tmp/m2</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">        gitParameter branch: <span class="string">&#x27;&#x27;</span>, branchFilter: <span class="string">&#x27;.*&#x27;</span>, defaultValue: <span class="string">&#x27;origin/master&#x27;</span>, description: <span class="string">&#x27;选择发布的分支&#x27;</span>, name: <span class="string">&#x27;Branch&#x27;</span>, quickFilterEnabled: <span class="literal">false</span>, selectedValue: <span class="string">&#x27;NONE&#x27;</span>, sortMode: <span class="string">&#x27;NONE&#x27;</span>, tagFilter: <span class="string">&#x27;*&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;PT_BRANCH&#x27;</span>        </span><br><span class="line">        extendedChoice defaultValue: <span class="string">&#x27;none&#x27;</span>, description: <span class="string">&#x27;选择发布的微服务&#x27;</span>, \</span><br><span class="line">          multiSelectDelimiter: <span class="string">&#x27;,&#x27;</span>, name: <span class="string">&#x27;Service&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;PT_CHECKBOX&#x27;</span>, \</span><br><span class="line">          value: <span class="string">&#x27;gateway-service:9999,portal-service:8080,product-service:8010,order-service:8020,stock-service:8030&#x27;</span></span><br><span class="line">        choice (choices: [<span class="string">&#x27;ms&#x27;</span>, <span class="string">&#x27;demo&#x27;</span>], description: <span class="string">&#x27;部署模板&#x27;</span>, name: <span class="string">&#x27;Template&#x27;</span>)</span><br><span class="line">        choice (choices: [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;7&#x27;</span>], description: <span class="string">&#x27;副本数&#x27;</span>, name: <span class="string">&#x27;ReplicaCount&#x27;</span>)</span><br><span class="line">        choice (choices: [<span class="string">&#x27;ms&#x27;</span>], description: <span class="string">&#x27;命名空间&#x27;</span>, name: <span class="string">&#x27;Namespace&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, </span><br><span class="line">                branches: [[name: <span class="string">&quot;<span class="variable">$&#123;params.Branch&#125;</span>&quot;</span>]], </span><br><span class="line">                extensions: [], </span><br><span class="line">                userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_auth&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_url&#125;</span>&quot;</span>]]</span><br><span class="line">                ])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;代码编译&#x27;</span>) &#123;</span><br><span class="line">            // 编译指定服务</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;构建镜像&#x27;</span>) &#123;</span><br><span class="line">          steps &#123;</span><br><span class="line">              withCredentials([usernamePassword(credentialsId: <span class="string">&quot;<span class="variable">$&#123;harbor_auth&#125;</span>&quot;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                 docker login -u <span class="variable">$&#123;username&#125;</span> -p &#x27;<span class="variable">$&#123;password&#125;</span>&#x27; <span class="variable">$&#123;registry&#125;</span></span></span><br><span class="line"><span class="string">                 for service in \$(echo <span class="variable">$&#123;Service&#125;</span> |sed &#x27;s/,/ /g&#x27;); do</span></span><br><span class="line"><span class="string">                    service_name=\$&#123;service%:*&#125;</span></span><br><span class="line"><span class="string">                    image_name=<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/\$&#123;service_name&#125;:<span class="variable">$&#123;BUILD_NUMBER&#125;</span></span></span><br><span class="line"><span class="string">                    cd \$&#123;service_name&#125;</span></span><br><span class="line"><span class="string">                    if ls |grep biz &amp;&gt;/dev/null; then</span></span><br><span class="line"><span class="string">                        cd \$&#123;service_name&#125;-biz</span></span><br><span class="line"><span class="string">                    fi</span></span><br><span class="line"><span class="string">                    docker build -t \$&#123;image_name&#125; .</span></span><br><span class="line"><span class="string">                    docker push \$&#123;image_name&#125;</span></span><br><span class="line"><span class="string">                    cd <span class="variable">$&#123;WORKSPACE&#125;</span></span></span><br><span class="line"><span class="string">                  done</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                configFileProvider([configFile(fileId: <span class="string">&quot;<span class="variable">$&#123;k8s_auth&#125;</span>&quot;</span>, targetLocation: <span class="string">&quot;admin.kubeconfig&quot;</span>)])&#123;</span><br><span class="line">                    sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                    # 添加镜像拉取认证</span></span><br><span class="line"><span class="string">                    kubectl create secret docker-registry <span class="variable">$&#123;image_pull_secret&#125;</span> --docker-username=<span class="variable">$&#123;username&#125;</span> --docker-password=<span class="variable">$&#123;password&#125;</span> --docker-server=<span class="variable">$&#123;registry&#125;</span> -n <span class="variable">$&#123;Namespace&#125;</span> --kubeconfig admin.kubeconfig |true</span></span><br><span class="line"><span class="string">                    # 添加私有chart仓库</span></span><br><span class="line"><span class="string">                    helm repo add  --username <span class="variable">$&#123;username&#125;</span> --password <span class="variable">$&#123;password&#125;</span> myrepo http://<span class="variable">$&#123;registry&#125;</span>/chartrepo/<span class="variable">$&#123;project&#125;</span></span></span><br><span class="line"><span class="string">                    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Helm部署到K8S&#x27;</span>) &#123;</span><br><span class="line">          steps &#123;</span><br><span class="line">              sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">              common_args=&quot;</span>-n <span class="variable">$&#123;Namespace&#125;</span> --kubeconfig admin.kubeconfig<span class="string">&quot;</span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">              for service in  \$(echo <span class="variable">$&#123;Service&#125;</span> |sed &#x27;s/,/ /g&#x27;); do</span></span><br><span class="line"><span class="string">                service_name=\$&#123;service%:*&#125;</span></span><br><span class="line"><span class="string">                service_port=\$&#123;service#*:&#125;</span></span><br><span class="line"><span class="string">                image=<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/\$&#123;service_name&#125;</span></span><br><span class="line"><span class="string">                tag=<span class="variable">$&#123;BUILD_NUMBER&#125;</span></span></span><br><span class="line"><span class="string">                helm_args=&quot;</span>\<span class="variable">$&#123;service_name&#125;</span> --<span class="built_in">set</span> image.repository=\<span class="variable">$&#123;image&#125;</span> --<span class="built_in">set</span> image.tag=\<span class="variable">$&#123;tag&#125;</span> --<span class="built_in">set</span> replicaCount=<span class="variable">$&#123;replicaCount&#125;</span> --<span class="built_in">set</span> imagePullSecrets[0].name=<span class="variable">$&#123;image_pull_secret&#125;</span> --<span class="built_in">set</span> service.targetPort=\<span class="variable">$&#123;service_port&#125;</span> myrepo/<span class="variable">$&#123;Template&#125;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                # 判断是否为新部署</span></span><br><span class="line"><span class="string">                if helm history \$&#123;service_name&#125; \$&#123;common_args&#125; &amp;&gt;/dev/null;then</span></span><br><span class="line"><span class="string">                  action=upgrade</span></span><br><span class="line"><span class="string">                else</span></span><br><span class="line"><span class="string">                  action=install</span></span><br><span class="line"><span class="string">                fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                # 针对服务启用ingress</span></span><br><span class="line"><span class="string">                if [ \$&#123;service_name&#125; == &quot;</span>gateway-service<span class="string">&quot; ]; then</span></span><br><span class="line"><span class="string">                  helm \$&#123;action&#125; \$&#123;helm_args&#125; \</span></span><br><span class="line"><span class="string">                  --set ingress.enabled=true \</span></span><br><span class="line"><span class="string">                  --set ingress.host=<span class="variable">$&#123;gateway_domain_name&#125;</span> \</span></span><br><span class="line"><span class="string">                   \$&#123;common_args&#125;</span></span><br><span class="line"><span class="string">                elif [ \$&#123;service_name&#125; == &quot;</span>portal-service<span class="string">&quot; ]; then</span></span><br><span class="line"><span class="string">                  helm \$&#123;action&#125; \$&#123;helm_args&#125; \</span></span><br><span class="line"><span class="string">                  --set ingress.enabled=true \</span></span><br><span class="line"><span class="string">                  --set ingress.host=<span class="variable">$&#123;portal_domain_name&#125;</span> \</span></span><br><span class="line"><span class="string">                   \$&#123;common_args&#125;</span></span><br><span class="line"><span class="string">                else</span></span><br><span class="line"><span class="string">                  helm \$&#123;action&#125; \$&#123;helm_args&#125; \$&#123;common_args&#125;</span></span><br><span class="line"><span class="string">                fi</span></span><br><span class="line"><span class="string">              done</span></span><br><span class="line"><span class="string">              # 查看Pod状态</span></span><br><span class="line"><span class="string">              sleep 10</span></span><br><span class="line"><span class="string">              kubectl get pods \$&#123;common_args&#125;</span></span><br><span class="line"><span class="string">              &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终效果图：</p>
<p><img src="/images/2C996A5FE9374972B3F1C34D6C139C33clipboard.png" alt></p>
<h3 id="流水线脚本与源代码一起版本管理">流水线脚本与源代码一起版本管理</h3>
<p>Jenkinsfile文件建议与源代码一起版本管理，实现流水线即 代码（Pipeline as Code）。</p>
<p>这样做的好处：</p>
<ul>
<li>
<p>自动为所有分支创建流水线脚本</p>
</li>
<li>
<p>方便流水线代码复查、追踪、迭代</p>
</li>
<li>
<p>可被项目成员查看和编辑</p>
</li>
</ul>
<p><img src="/images/1CB58EC278494B95B4CF18806EC80C36clipboard.png" alt></p>
<p><img src="/images/857EAC3742DE4C009FB7B571FB68F768clipboard.png" alt></p>
<h2 id="小结">小结</h2>
<p>使用Jenkins的插件</p>
<ul>
<li>
<p>Git &amp; gitParameter</p>
</li>
<li>
<p>Kubernetes</p>
</li>
<li>
<p>Pipeline</p>
</li>
<li>
<p>Config File Provider</p>
</li>
<li>
<p>Extended Choice Parameter</p>
</li>
</ul>
<p>CI/CD环境特点</p>
<ul>
<li>
<p>Slave弹性伸缩</p>
</li>
<li>
<p>基于镜像隔离构建环境</p>
</li>
<li>
<p>流水线发布，易维护</p>
</li>
</ul>
<p>Jenkins参数化构建可帮助你完成更复杂环境CI/CD</p>
<p>回滚思路：</p>
<p>1.使用kubectl rollout ,将资源名称和命名空间等参数化传入</p>
<p>2.每次发布记录发布的镜像版本写到一个历史文件中，Extended choice Parameter从历史文件中作为选择项</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Jenkins构建持续集成（CI）平台</title>
    <url>/2023/07/10/%E5%9F%BA%E4%BA%8Ejenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90ci%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h2 id="发布流程">发布流程</h2>
<p><img src="/images/B8B091A03DF44FACA92CA9079CCF4F6Eclipboard.png" alt></p>
<h2 id="使用-Gitlab-作为代码仓库-使用-Harbor-作为镜像仓库">使用 Gitlab 作为代码仓库 &amp; 使用 Harbor 作为镜像仓库</h2>
<p>1.部署gitlab</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> gitlab</span><br><span class="line"><span class="built_in">cd</span> gitlab</span><br><span class="line">docker run -d \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  -p 8443:443 \</span><br><span class="line">  -p 9999:80 \</span><br><span class="line">  -p 9998:22 \</span><br><span class="line">  -v <span class="variable">$PWD</span>/config:/etc/gitlab \</span><br><span class="line">  -v <span class="variable">$PWD</span>/logs:/var/log/gitlab \</span><br><span class="line">  -v <span class="variable">$PWD</span>/data:/var/opt/gitlab \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  --restart=always \</span><br><span class="line">  lizhenliang/gitlab-ce-zh:latest</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://IP:9999">http://IP:9999</a></p>
<p>初次会先设置管理员密码 ，然后登陆，默认管理员用户名root，密码就是刚设置的。</p>
<p>创建项目，提交测试代码</p>
<p>进入后先创建项目，提交代码，以便后面测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip tomcat-java-demo-master.zip</span><br><span class="line"><span class="built_in">cd</span> tomcat-java-demo-master</span><br><span class="line">git init</span><br><span class="line">git remote add origin http://192.168.0.13:9999/root/java-demo.git</span><br><span class="line">git add .</span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git commit -m <span class="string">&#x27;all&#x27;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>2、部署Harbor镜像仓库</p>
<p>2.1 安装docker与docker-compose</p>
<p>2.2 解压离线包部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar zxvf harbor-offline-installer-v2.0.0.tgz</span></span><br><span class="line"><span class="comment"># cd harbor</span></span><br><span class="line"><span class="comment"># cp harbor.yml.tmpl harbor.yml</span></span><br><span class="line"><span class="comment"># vi harbor.yml</span></span><br><span class="line">hostname: reg.ctnrs.com</span><br><span class="line">https:   <span class="comment"># 先注释https相关配置</span></span><br><span class="line">harbor_admin_password: Harbor12345</span><br><span class="line"><span class="comment"># ./prepare</span></span><br><span class="line"><span class="comment"># ./install.sh</span></span><br></pre></td></tr></table></figure>
<p>2.3 在Jenkins主机配置Docker可信任，如果是HTTPS需要拷贝证书</p>
<p>由于habor未配置https，还需要在docker配置可信任。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/docker/daemon.json </span></span><br><span class="line">&#123;<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.0.12&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<h2 id="在Kubernetes平台部署Jenkins">在Kubernetes平台部署Jenkins</h2>
<p><img src="/images/C37831EBEEC44A3490C93047DA63180Bclipboard.png" alt></p>
<p>部署nfs-pv自动供给</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装nfs安装包（每个k8s节点都要安装）</span></span><br><span class="line">yum install nfs-utils</span><br><span class="line"><span class="comment">#创建nfs共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/kubernetes</span><br><span class="line"><span class="comment">#修改nfs配置文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/nfs/kubernetes *(rw,no_root_squash)</span><br><span class="line"><span class="comment">#启动nfs并加入开机自启</span></span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署NFS实现自动创建PV插件：</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-incubator/external-storage </span><br><span class="line"><span class="built_in">cd</span> nfs-client/deploy </span><br><span class="line">kubectl apply -f rbac.yaml <span class="comment"># 授权访问apiserver </span></span><br><span class="line">kubectl apply -f deployment.yaml <span class="comment"># 部署插件，需修改里面NFS服务器地址与共享目录 </span></span><br><span class="line">kubectl apply -f class.yaml <span class="comment"># 创建存储类</span></span><br><span class="line">kubectl get sc  <span class="comment"># 查看存储类</span></span><br></pre></td></tr></table></figure>
<p>3.部署Jenkins</p>
<p>需要提前准备好PV自动供给，为Jenkins持久化数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> jenkins </span><br><span class="line">kubectl apply -f jenkins.yaml </span><br><span class="line">kubectl get pods,svc -n ops -o wide</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://NodePort:30008">http://NodePort:30008</a></p>
<p>第一次部署会进行初始化：</p>
<p><img src="/images/806FCD61A4E74AE69DE24E9C44C5DC94clipboard.png" alt></p>
<p><img src="/images/902A866F027F444A9BAA5672C31CD3F6clipboard.png" alt></p>
<p>点无，不安装任何插件</p>
<p><img src="/images/30C5816DF5894B72B53F2C3DA2325B56clipboard.png" alt></p>
<p><img src="/images/33560ADB6FA64551B3AC680A423F5455clipboard.png" alt></p>
<p>4.安装插件</p>
<p>默认从国外网络下载插件，会比较慢，建议修改国内源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入到nfs共享目录</span></span><br><span class="line"><span class="built_in">cd</span> /nfs/kubernetes/ops-jenkins-pvc-0b76f611-9e06-433d-a666-8e7d0e9f1138/updates</span><br><span class="line">sed -i <span class="string">&#x27;s/https:\/\/updates.jenkins.io\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27;</span> default.json </span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27;</span> default.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除pod重建，pod名称改成你实际的</span></span><br><span class="line">kubectl delete pod jenkins-d58f4db66-9cthj -n ops</span><br></pre></td></tr></table></figure>
<p><a href="http://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json">http://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p>
<p>管理Jenkins-&gt;系统配置–&gt;管理插件–&gt;分别搜索Git Parameter/Git/Pipeline/kubernetes/Config File Provider，选中点击安装。</p>
<ul>
<li>
<p>Git Parameter：Git参数化构建</p>
</li>
<li>
<p>Git：拉取代码</p>
</li>
<li>
<p>Pipeline：流水线</p>
</li>
<li>
<p>kubernetes：连接Kubernetes动态创建Slave代理</p>
</li>
<li>
<p>Config File Provider：存储kubectl用于连接k8s集群的kubeconfig配置文件</p>
</li>
</ul>
<p>5、添加kubernetes集群</p>
<p>管理Jenkins-&gt;Manage Nodes and Clouds-&gt;configureClouds-&gt;Add</p>
<p><img src="/images/03D97C8EA28540C7BE60448E07D9ACC4clipboard.png" alt></p>
<p><img src="/images/ACCA74693EC542C7A7ED689ED3549A49clipboard.png" alt></p>
<p><img src="/images/661104035E1B475BA10156494C4999F4clipboard.png" alt></p>
<h2 id="构建Jenkins-Slave镜像">构建Jenkins-Slave镜像</h2>
<p><img src="/images/D60FD3F26D354454B8D2AA9C7966C5ECclipboard.png" alt></p>
<p><a href="/attachments/46211E5639224A3F86BBD7CCA0561FB5jenkins-slave.zip">jenkins-slave.zip</a></p>
<p>6.构建Slave镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> jenkins-slave</span><br></pre></td></tr></table></figure>
<p>课件目录里涉及四个文件：</p>
<ul>
<li>
<p>Dockerfile：构建镜像</p>
</li>
<li>
<p>jenkins-slave：shell脚本启动slave.jar</p>
</li>
<li>
<p>settings.xml：修改maven官方源为阿里云源</p>
</li>
<li>
<p>slave.jar：agent程序，接受master下发的任务</p>
</li>
</ul>
<p>构建并推送到镜像仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t 192.168.0.12/library/jenkins-slave-jdk:1.8 .</span><br><span class="line">docker push 192.168.0.12/library/jenkins-slave-jdk:1.8</span><br></pre></td></tr></table></figure>
<h2 id="Jenkins在K8S中动态创建代理">Jenkins在K8S中动态创建代理</h2>
<p><img src="/images/4DFDC1E497AA4C26A3CC93DEFDFCCDB2clipboard.png" alt></p>
<p><img src="/images/F64A137138EC46E5AD60B4687BDCCB70clipboard.png" alt></p>
<p>Kubernetes插件：Jenkins在Kubernetes集群中运行动态代理</p>
<p>插件介绍：<a href="https://github.com/jenkinsci/kubernetes-plugin">https://github.com/jenkinsci/kubernetes-plugin</a></p>
<p><img src="/images/EADEC438404748B7B6F9B46B13AD34D7clipboard.png" alt></p>
<h2 id="Jenkins-Pipeline-介绍">Jenkins Pipeline 介绍</h2>
<p>Jenkins Pipeline是一套运行工作流框架，将原本独立运行单个或者多个节点的任 务链接起来，实现单个任务难以完成的复杂流程编排和可视化。</p>
<ul>
<li>
<p>Jenkins Pipeline是一套插件，支持在Jenkins中实现持续集成和持续交付；</p>
</li>
<li>
<p>Pipeline通过特定语法对简单到复杂的传输管道进行建模；</p>
</li>
<li>
<p>Jenkins Pipeline的定义被写入一个文本文件，称为Jenkinsfile。</p>
</li>
</ul>
<p><img src="/images/BB3AD16EE1E946D8ADEAC37E3A017C1Cclipboard.png" alt></p>
<p><img src="/images/662F7E09DE044DC4B7C04757AA644DBFclipboard.png" alt></p>
<ul>
<li>
<p>Stages 是 Pipeline 中最主要的组成部分，Jenkins 将会按照 Stages 中描述的顺序 从上往下的执行。</p>
</li>
<li>
<p>Stage：阶段，一个 Pipeline 可以划分为若干个 Stage，每个 Stage 代表一组操作， 比如：Build、Test、Deploy</p>
</li>
<li>
<p>Steps：步骤，Steps 是最基本的操作单元，可以是打印一句话，也可以是构建一 个 Docker 镜像，由各类 Jenkins 插件提供，比如命令：sh ‘mvn’，就相当于我 们平时 shell 终端中执行 mvn命令一样。</p>
</li>
</ul>
<p><img src="/images/DEC96708F922425299860AF5C06A3528clipboard.png" alt></p>
<h2 id="Jenkins在Kubernetes中持续部署">Jenkins在Kubernetes中持续部署</h2>
<p>自动部署应用（yaml）：</p>
<p>将kubectl工具封装到Slave镜像中，并通过Config File Provider插件存储连接K8s集群的kubeconfig认证文件，然后 挂载到Slave容器中，这样就能用kubectl apply deploy.yaml --kubeconfig=config</p>
<p>注：为提高安全性，kubeconfig文件应分配权限</p>
<p>除了上述方式，还可以使用Kubernetes Continuous Deploy插件，将资源配置（YAML）部署到Kubernetes，这种 不是很灵活性</p>
<p>7.编写Pipeline脚本</p>
<p><img src="/images/D6F97AAB41B947219B5A23754BFDA7E1clipboard.png" alt></p>
<p><img src="/images/9D8F0EBA6330492589D80F9D4BEE2DFAclipboard.png" alt></p>
<p><img src="/images/10DD9C8133BF4D04AD2B944E26046C11clipboard.png" alt></p>
<p><img src="/images/C868CD38CD0545628DF7234A2B80F8ADclipboard.png" alt></p>
<p>创建命名空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create ns dev</span><br><span class="line">kubectl create ns <span class="built_in">test</span></span><br><span class="line">kubectl create ns prod</span><br></pre></td></tr></table></figure>
<p>将镜像仓库认证凭据保存在K8s Secret中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry registry-pull-secret --docker-username=admin --docker-password=Harbor12345 --docker-server=192.168.0.12 -n dev</span><br><span class="line">kubectl create secret docker-registry registry-pull-secret --docker-username=admin --docker-password=Harbor12345 --docker-server=192.168.0.12 -n <span class="built_in">test</span></span><br><span class="line">kubectl create secret docker-registry registry-pull-secret --docker-username=admin --docker-password=Harbor12345 --docker-server=192.168.0.12 -n prod</span><br></pre></td></tr></table></figure>
<p>部署文件：deploy.yaml （将部署文件跟git仓库文件放在一起）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  replicas: REPLICAS</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: java</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: java</span><br><span class="line">    spec:</span><br><span class="line">      imagePullSecrets:</span><br><span class="line">      - name: SECRET_NAME</span><br><span class="line">      containers:</span><br><span class="line">      - image: IMAGE_NAME</span><br><span class="line">        name: java-demo</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 0.5</span><br><span class="line">            memory: 500Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 1</span><br><span class="line">            memory: 1Gi</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /</span><br><span class="line">            port: 8080</span><br><span class="line">          initialDelaySeconds: 40</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /</span><br><span class="line">            port: 8080</span><br><span class="line">          initialDelaySeconds: 40</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: java</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br><span class="line">  <span class="built_in">type</span>: NodePort </span><br></pre></td></tr></table></figure>
<p>创建项目-&gt;流水线-&gt;Pipeline脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 公共</span><br><span class="line">def registry = <span class="string">&quot;192.168.0.12&quot;</span></span><br><span class="line">// 项目</span><br><span class="line">def project = <span class="string">&quot;demo&quot;</span></span><br><span class="line">def app_name = <span class="string">&quot;java-demo&quot;</span></span><br><span class="line">def image_name = <span class="string">&quot;<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/<span class="variable">$&#123;app_name&#125;</span>:<span class="variable">$&#123;BUILD_NUMBER&#125;</span>&quot;</span></span><br><span class="line">def git_address = <span class="string">&quot;http://192.168.0.13:9999/root/java-demo.git&quot;</span></span><br><span class="line">// 认证</span><br><span class="line">def secret_name = <span class="string">&quot;registry-pull-secret&quot;</span></span><br><span class="line">def docker_registry_auth = <span class="string">&quot;e2c15e7c-766e-4961-bddb-2160e6e1859b&quot;</span></span><br><span class="line">def git_auth = <span class="string">&quot;d17ea255-ade3-4623-b2ce-0b40b87e7164&quot;</span></span><br><span class="line">def k8s_auth = <span class="string">&quot;6f488843-b5e2-49ca-949b-eccb75b54f6c&quot;</span></span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">  agent &#123;</span><br><span class="line">    kubernetes &#123;</span><br><span class="line">        label <span class="string">&quot;jenkins-slave&quot;</span></span><br><span class="line">        yaml <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: jenkins-slave</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  containers:</span></span><br><span class="line"><span class="string">  - name: jnlp</span></span><br><span class="line"><span class="string">    image: &quot;</span><span class="variable">$&#123;registry&#125;</span>/library/jenkins-slave-jdk:1.8<span class="string">&quot;</span></span><br><span class="line"><span class="string">    imagePullPolicy: Always</span></span><br><span class="line"><span class="string">    volumeMounts:</span></span><br><span class="line"><span class="string">      - name: docker-cmd</span></span><br><span class="line"><span class="string">        mountPath: /usr/bin/docker</span></span><br><span class="line"><span class="string">      - name: docker-sock</span></span><br><span class="line"><span class="string">        mountPath: /var/run/docker.sock</span></span><br><span class="line"><span class="string">      - name: maven-cache</span></span><br><span class="line"><span class="string">        mountPath: /root/.m2</span></span><br><span class="line"><span class="string">  volumes:</span></span><br><span class="line"><span class="string">    - name: docker-cmd</span></span><br><span class="line"><span class="string">      hostPath:</span></span><br><span class="line"><span class="string">        path: /usr/bin/docker</span></span><br><span class="line"><span class="string">    - name: docker-sock</span></span><br><span class="line"><span class="string">      hostPath:</span></span><br><span class="line"><span class="string">        path: /var/run/docker.sock</span></span><br><span class="line"><span class="string">    - name: maven-cache</span></span><br><span class="line"><span class="string">      hostPath:</span></span><br><span class="line"><span class="string">        path: /tmp/m2</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">    parameters &#123;    </span><br><span class="line">        gitParameter branch: <span class="string">&#x27;&#x27;</span>, branchFilter: <span class="string">&#x27;.*&#x27;</span>, defaultValue: <span class="string">&#x27;master&#x27;</span>, description: <span class="string">&#x27;选择发布的分支&#x27;</span>, name: <span class="string">&#x27;Branch&#x27;</span>, quickFilterEnabled: <span class="literal">false</span>, selectedValue: <span class="string">&#x27;NONE&#x27;</span>, sortMode: <span class="string">&#x27;NONE&#x27;</span>, tagFilter: <span class="string">&#x27;*&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;PT_BRANCH&#x27;</span></span><br><span class="line">        choice (choices: [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;7&#x27;</span>], description: <span class="string">&#x27;副本数&#x27;</span>, name: <span class="string">&#x27;ReplicaCount&#x27;</span>)</span><br><span class="line">        choice (choices: [<span class="string">&#x27;dev&#x27;</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;prod&#x27;</span>], description: <span class="string">&#x27;命名空间&#x27;</span>, name: <span class="string">&#x27;Namespace&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, </span><br><span class="line">                branches: [[name: <span class="string">&quot;<span class="variable">$&#123;params.Branch&#125;</span>&quot;</span>]], </span><br><span class="line">                doGenerateSubmoduleConfigurations: <span class="literal">false</span>, </span><br><span class="line">                extensions: [], submoduleCfg: [], </span><br><span class="line">                userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_auth&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_address&#125;</span>&quot;</span>]]</span><br><span class="line">                ])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;代码编译&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">             sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span> </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;构建镜像&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&quot;<span class="variable">$&#123;docker_registry_auth&#125;</span>&quot;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  echo &#x27;</span></span><br><span class="line"><span class="string">                    FROM lizhenliang/tomcat</span></span><br><span class="line"><span class="string">                    LABEL maitainer lizhenliang</span></span><br><span class="line"><span class="string">                    RUN rm -rf /usr/local/tomcat/webapps/*</span></span><br><span class="line"><span class="string">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">                  &#x27; &gt; Dockerfile</span></span><br><span class="line"><span class="string">                  docker build -t <span class="variable">$&#123;image_name&#125;</span> .</span></span><br><span class="line"><span class="string">                  docker login -u <span class="variable">$&#123;username&#125;</span> -p &#x27;<span class="variable">$&#123;password&#125;</span>&#x27; <span class="variable">$&#123;registry&#125;</span></span></span><br><span class="line"><span class="string">                  docker push <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;部署到K8S平台&#x27;</span>)&#123;</span><br><span class="line">          steps &#123;</span><br><span class="line">              configFileProvider([configFile(fileId: <span class="string">&quot;<span class="variable">$&#123;k8s_auth&#125;</span>&quot;</span>, targetLocation: <span class="string">&quot;admin.kubeconfig&quot;</span>)])&#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  sed -i &#x27;s#IMAGE_NAME#<span class="variable">$&#123;image_name&#125;</span>#&#x27; deploy.yaml</span></span><br><span class="line"><span class="string">                  sed -i &#x27;s#SECRET_NAME#<span class="variable">$&#123;secret_name&#125;</span>#&#x27; deploy.yaml</span></span><br><span class="line"><span class="string">                  sed -i &#x27;s#REPLICAS#<span class="variable">$&#123;ReplicaCount&#125;</span>#&#x27; deploy.yaml</span></span><br><span class="line"><span class="string">                  kubectl apply -f deploy.yaml -n <span class="variable">$&#123;Namespace&#125;</span> --kubeconfig=admin.kubeconfig</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述脚本中，registry变量值改成你的镜像仓库地址。</p>
<p>将之前部署该项目涉及的yaml合并到一个名为deploy.yaml文件中，并提交到该项目代码仓库，与 pom.xml同级目录，用于上述脚本自动部署使用。</p>
<p>1、将harbor认证和gitlab认证保存到Jenkins凭据</p>
<p>管理Jenkins-&gt;安全–&gt;管理凭据-&gt;Jnekins-&gt;添加凭据-&gt;Username with password</p>
<ul>
<li>
<p>Username：用户名</p>
</li>
<li>
<p>Password：密码 ID：留空</p>
</li>
<li>
<p>Description：描述</p>
</li>
</ul>
<p>分别添加连接git和harbor凭据，并修改上面脚本docker_registry_auth 和git_auth变量的值为Jenkins 凭据ID。</p>
<p>2、将kubeconfig存储在Jenkins，用于slave镜像里kubectl连接k8s集群</p>
<p>管理Jenkins-&gt; Managed files-&gt;Add-&gt;Custom file -&gt;Content字段内容是kubeconfig（默认路径在 master节点/root/.kube/config），然后复制ID替换上述脚本中k8s_auth变量的值。</p>
<p>8.构建测试</p>
<p><img src="/images/A267258D41844B6F9E91E9818FCCB372clipboard.png" alt></p>
<p><img src="/images/88A6511809824849B7B75F287740A29Cclipboard.png" alt></p>
<h2 id="流水线脚本与源代码一起版本管理">流水线脚本与源代码一起版本管理</h2>
<p>Jenkinsfile文件建议与源代码一起版本管理，实现流水线即代码（Pipeline as Code）。 这样做的好处：</p>
<ul>
<li>
<p>自动为所有分支创建流水线脚本</p>
</li>
<li>
<p>方便流水线代码复查、追踪、迭代</p>
</li>
<li>
<p>可被项目成员查看和编辑</p>
</li>
</ul>
<p><img src="/images/83655B267EAF4BECB3EDA8DCA742EB78clipboard.png" alt></p>
<p><img src="/images/9454B5F4500646AAA91EBEF5ECA338DAclipboard.png" alt></p>
<p>参考链接：<a href="https://www.cnblogs.com/u1s1/p/14231196.html">https://www.cnblogs.com/u1s1/p/14231196.html</a></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>实例生命周期钩子</title>
    <url>/2024/06/06/%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</url>
    <content><![CDATA[<p>生命周期是指Vue实例从创建到销毁的过程。就是vue实例从开始创建、 初始化数据、编译模板、挂载Dom、渲染-&gt;更新-&gt;渲染、卸载等⼀系 列过程，在vue⽣命周期中提供了⼀系列的⽣命周期函数，如图所⽰。</p>
<p><img src="/images/6CDF32DA88A543E9B3074F77CEB0EA9Dclipboard.png" alt></p>
<p><img src="/images/865F99A2A16347A7BBAE9935887C9EB4clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>实现Docker容器多主机通信</title>
    <url>/2022/05/26/%E5%AE%9E%E7%8E%B0docker%E5%AE%B9%E5%99%A8%E5%A4%9A%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>跨主机网络：实现Docker容器多主机通信</p>
<p>Flannel是CoreOS维护的一个网络组件，在每个主机上运行守护 进程负责维护本地路由转发，Flannel使用ETCD来存储容器网络 与主机之前的关系。</p>
<p>其他主流容器跨主机网络方案：</p>
<p>• Weave</p>
<p>• Calico</p>
<p>• OpenvSwitch</p>
<p><img src="/images/10B81BDFE6B2495FB1B335FAC555BF8Dclipboard.png" alt></p>
<p>1、etcd安装并配置（任意找一台节点安装即可）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install etcd</span><br><span class="line">vim /etc/etcd/etcd.conf </span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://192.168.0.11:2379&quot;</span></span><br><span class="line">ETCD_NAME=<span class="string">&quot;default&quot;</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://192.168.0.11:2379&quot;</span></span><br><span class="line">systemctl start etcd</span><br><span class="line">systemctl <span class="built_in">enable</span> etcd</span><br><span class="line">ss -anpt |grep 2379</span><br></pre></td></tr></table></figure>
<p>2、flanneld安装并配置（两台跨主机的docker主机安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install flannel</span><br><span class="line">vim /etc/sysconfig/flanneld</span><br><span class="line">FLANNEL_ETCD_ENDPOINTS=<span class="string">&quot;http://192.168.0.11:2379&quot;</span></span><br><span class="line">FLANNEL_ETCD_PREFIX=<span class="string">&quot;/atomic.io/network&quot;</span></span><br></pre></td></tr></table></figure>
<p>3、向etcd写入子网启动并flanneld服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdctl --endpoints=<span class="string">&quot;http://192.168.0.11:2379&quot;</span> <span class="built_in">set</span> /atomic.io/network/config <span class="string">&#x27;&#123; &quot;Network&quot;:&quot;172.17.0.0/16&quot;, &quot;Backend&quot;: &#123;&quot;Type&quot;: &quot;vxlan&quot;&#125;&#125; &#x27;</span></span><br><span class="line">etcdctl --endpoints=<span class="string">&quot;http://192.168.0.11:2379&quot;</span> get /atomic.io/network/config </span><br><span class="line">systemctl start flanneld.service  </span><br><span class="line">systemctl <span class="built_in">enable</span> flanneld.service </span><br></pre></td></tr></table></figure>
<p>4、配置Docker使用flannel生成的网络信息 (两台跨主机的docker主机配置）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br><span class="line">EnvironmentFile=/var/run/flannel/docker</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock <span class="variable">$DOCKER_NETWORK_OPTIONS</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker </span><br><span class="line">ps -ef |grep docker</span><br></pre></td></tr></table></figure>
<p>5.两台跨主机的docker主机设置iptable转发策略为允许并重启服务（按顺序启动）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">systemctl restart flanneld.service </span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>
<p>6、在两台主机创建容器相互ping验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it busybox sh</span><br><span class="line">ifconfig </span><br></pre></td></tr></table></figure>
<p>防火墙学习：</p>
<p><a href="https://www.cnblogs.com/shijiaqi1066/p/3812510.html">https://www.cnblogs.com/shijiaqi1066/p/3812510.html</a></p>
<p><a href="http://www.zsythink.net/archives/1199">http://www.zsythink.net/archives/1199</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>如何自己写metrice接口?</title>
    <url>/2021/09/13/%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%86%99metrice%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.自己写metrice接口，要遵循数据模型</span><br><span class="line">  1） 先知道怎么收集你要的监控指标</span><br><span class="line">  2） 集成官方的客户端或者自己写的数据格式，暴露出来</span><br><span class="line">2.使用社区维护的exporter（采集器，以数据模型暴露metrice接口）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如何自动化监控100台服务器？</span><br><span class="line">传统的方式：</span><br><span class="line">1.要在这100台机器上安装node_exporter（采集器）</span><br><span class="line">2.在prometheus配置文件里面增加这100台机器的配置</span><br><span class="line"></span><br><span class="line">自动化部署：</span><br><span class="line">1.使用ansible批量部署安装node_exporter</span><br><span class="line">2.基于consul服务发现机制</span><br><span class="line">3.将node_exporter所在机器的IP和端口注册到consul服务发现里面</span><br><span class="line">4.prometheus从consul里面获取所有的IP和端口自动的加入监控</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">100台： web服务器   db服务器  负载均衡服务器  消息队列服务器</span><br><span class="line">实际运维中会把他们进行分组管理</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;id&quot;</span>: <span class="string">&quot;web1&quot;</span>,<span class="string">&quot;name&quot;</span>: <span class="string">&quot;webservers&quot;</span></span><br><span class="line"><span class="string">&quot;id&quot;</span>: <span class="string">&quot;web2&quot;</span>,<span class="string">&quot;name&quot;</span>: <span class="string">&quot;webservers&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;id&quot;</span>: <span class="string">&quot;db1&quot;</span>,<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dbservers&quot;</span></span><br><span class="line"><span class="string">&quot;id&quot;</span>: <span class="string">&quot;db2&quot;</span>,<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dbservers&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>实际项目部署案例</title>
    <url>/2022/07/16/%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>部署项目前的梳理：</p>
<p>1.项目的代码构成，什么语言开发的</p>
<p>2.项目的依赖环境</p>
<p>3.项目的配置文件在哪里</p>
<p>4.项目的端口清单</p>
<p>5.项目有没有做数据的持久化</p>
<h2 id="容器交付流程">容器交付流程</h2>
<p><img src="/images/7327EAB29F8F4C73A7B379DF9D660DDEclipboard.png" alt></p>
<h2 id="在K8s平台部署项目流程">在K8s平台部署项目流程</h2>
<p><img src="/images/0749CCA49C9444DA9A410901C5F3C4B8clipboard.png" alt></p>
<h2 id="在K8s平台部署Java网站项目">在K8s平台部署Java网站项目</h2>
<p>阿里云maven源地址： <a href="https://maven.aliyun.com/mvn/guide">https://maven.aliyun.com/mvn/guide</a></p>
<p>第一步：制作镜像</p>
<p><img src="/images/1506058D05CA4D20B52B277B065B60ABclipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk maven git -y</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/lizhenliang/tomcat-java-demo</span><br><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span> <span class="comment"># 代码编译构建</span></span><br><span class="line">unzip target/*.war -d target/ROOT <span class="comment"># 解压构建文件</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM lizhenliang/tomcat </span><br><span class="line">LABEL maintainer www.ctnrs.com</span><br><span class="line">RUN <span class="built_in">rm</span> -rf /usr/local/tomcat/webapps/*</span><br><span class="line">COPY target/ROOT /usr/local/tomcat/webapps/ROOT</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t image:tag .</span><br><span class="line">docker push &lt;镜像仓库地址&gt;/&lt;项目名&gt;/image:tag</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d image:tag</span><br></pre></td></tr></table></figure>
<p>使用镜像仓库（私有仓库、公共仓库）：</p>
<p>1、配置可信任（如果仓库是HTTPS访问不用配置）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">    insecure-registries<span class="string">&quot;: [&quot;</span>192.168.0.13<span class="string">&quot;]</span></span><br><span class="line"><span class="string">&#125;    </span></span><br></pre></td></tr></table></figure>
<p>2、将镜像仓库认证凭据保存在K8s Secret中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry registry-auth --docker-username=admin --docker-password=Harbor12345 --docker-server=192.168.0.13</span><br></pre></td></tr></table></figure>
<p>3、在yaml中使用这个认证凭据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">imagePullSecrets:</span><br><span class="line">- name: registry-auth</span><br></pre></td></tr></table></figure>
<p><img src="/images/06ED566FF1074B42A72AF5B779FE1C3Aclipboard.png" alt></p>
<p>配置认证的的原因是部署的harbor是私有仓库，k8s的每个节点每次去拉取镜像都必须登录harbor仓库，比较麻烦，通过在yaml配置文件指定docker登录认证凭据，这样docker每次部署的时候就会自动去拉取镜像了。</p>
<p>第二步：使用控制器部署镜像</p>
<p><img src="/images/335EB09272114DD3BF1BC4A424A77A7Dclipboard.png" alt></p>
<p><img src="/images/64A3856A336D42DFA7B90B914E97D60Dclipboard.png" alt></p>
<p>注意：在pod中挂载configmap配置文件时，如果指定容器内挂载的目录不是空目录，那么会覆盖原来目录下的内容。</p>
<p>部署configmap</p>
<p>vim configmap.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo-config</span><br><span class="line">data:</span><br><span class="line">    application.yml: |</span><br><span class="line">        server:</span><br><span class="line">          port: 8080</span><br><span class="line">        spring:</span><br><span class="line">          datasource:</span><br><span class="line">            url: jdbc:mysql://java-demo-db:3306/k8s?characterEncoding=utf-8</span><br><span class="line">            username: azhe</span><br><span class="line">            password: 123456</span><br><span class="line">            driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">          freemarker:</span><br><span class="line">            allow-request-override: <span class="literal">false</span></span><br><span class="line">            cache: <span class="literal">true</span></span><br><span class="line">            check-template-location: <span class="literal">true</span></span><br><span class="line">            charset: UTF-8</span><br><span class="line">            content-type: text/html; charset=utf-8</span><br><span class="line">            expose-request-attributes: <span class="literal">false</span></span><br><span class="line">            expose-session-attributes: <span class="literal">false</span></span><br><span class="line">            expose-spring-macro-helpers: <span class="literal">false</span></span><br><span class="line">            suffix: .ftl</span><br><span class="line">            template-loader-path:</span><br><span class="line">              - classpath:/templates/</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>部署deployment</p>
<p>vim deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: java</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: java</span><br><span class="line">    spec:</span><br><span class="line">      imagePullSecrets:</span><br><span class="line">      - name: registry-auth</span><br><span class="line">      containers:</span><br><span class="line">      - image: 192.168.0.13/demo/java-demo:v1</span><br><span class="line">        name: java-demo</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 0.5</span><br><span class="line">            memory: 500Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 1</span><br><span class="line">            memory: 1Gi</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /</span><br><span class="line">            port: 8080</span><br><span class="line">          initialDelaySeconds: 40</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /</span><br><span class="line">            port: 8080</span><br><span class="line">          initialDelaySeconds: 40</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: config</span><br><span class="line">          mountPath: <span class="string">&quot;/usr/local/tomcat/webapps/ROOT/WEB-INF/classes/application.yml&quot;</span></span><br><span class="line">          subPath: <span class="string">&quot;application.yml&quot;</span></span><br><span class="line">      volumes:</span><br><span class="line">      - name: config</span><br><span class="line">        configMap:</span><br><span class="line">          name: java-demo-config</span><br><span class="line">          items:</span><br><span class="line">          - key: <span class="string">&quot;application.yml&quot;</span></span><br><span class="line">            path: <span class="string">&quot;application.yml&quot;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f configmap.yaml </span><br><span class="line">kubectl apply -f deployment.yaml </span><br></pre></td></tr></table></figure>
<p>第三步：对外暴露应用</p>
<p><img src="/images/CE03F82EDAB4453B93B6E5C1B62E92E4clipboard.png" alt></p>
<p>部署service</p>
<p>vim service.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: java</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>部署ingress（首先部署nginx-ingress-controller，监听端口是80和443)</p>
<p>vim ingress.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: java.ctnrs.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">        - path: /</span><br><span class="line">          pathType: Prefix</span><br><span class="line">          backend:</span><br><span class="line">            service:</span><br><span class="line">              name: java-demo</span><br><span class="line">              port:</span><br><span class="line">                number: 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>部署mysql数据库（1.部署NFS实现自动创建PV插件 2.导入表到k8s数据库）</p>
<p><a href="/attachments/AD05901F881F482EAC2E9A51FE4E8E13nfs-client.zip">nfs-client.zip</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装nfs安装包（每个k8s节点都要安装）</span></span><br><span class="line">yum install nfs-utils</span><br><span class="line"><span class="comment">#创建nfs共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/kubernetes</span><br><span class="line"><span class="comment">#修改nfs配置文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/nfs/kubernetes *(rw,no_root_squash)</span><br><span class="line"><span class="comment">#启动nfs并加入开机自启</span></span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署NFS实现自动创建PV插件：</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-incubator/external-storage </span><br><span class="line"><span class="built_in">cd</span> nfs-client/deploy </span><br><span class="line">kubectl apply -f rbac.yaml <span class="comment"># 授权访问apiserver </span></span><br><span class="line">kubectl apply -f deployment.yaml <span class="comment"># 部署插件，需修改里面NFS服务器地址与共享目录 </span></span><br><span class="line">kubectl apply -f class.yaml <span class="comment"># 创建存储类</span></span><br><span class="line">kubectl get sc  <span class="comment"># 查看存储类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入表到k8s数据库</span></span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl <span class="built_in">cp</span> tables_ly_tomcat.sql java-demo-db-6c775c4d4b-7xfgc:/</span><br><span class="line">kubectl <span class="built_in">exec</span> -it java-demo-db-6c775c4d4b-7xfgc -- bash</span><br><span class="line">mysql -u root -p<span class="variable">$MYSQL_ROOT_PASSWORD</span></span><br><span class="line">show databses;</span><br><span class="line">use k8s;</span><br><span class="line"><span class="built_in">source</span> /tables_ly_tomcat.sql;</span><br></pre></td></tr></table></figure>
<p>vim mysql.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo-db </span><br><span class="line">  namespace: default</span><br><span class="line"><span class="built_in">type</span>: Opaque</span><br><span class="line">data:</span><br><span class="line">  mysql-root-password: <span class="string">&quot;MTIzNDU2&quot;</span></span><br><span class="line">  mysql-password: <span class="string">&quot;MTIzNDU2&quot;</span></span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo-db </span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      project: www</span><br><span class="line">      app: mysql</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        project: www</span><br><span class="line">        app: mysql</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: db</span><br><span class="line">        image: mysql:5.7.30</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 500m</span><br><span class="line">            memory: 512Mi</span><br><span class="line">          limits: </span><br><span class="line">            cpu: 500m</span><br><span class="line">            memory: 512Mi</span><br><span class="line">        <span class="built_in">env</span>:</span><br><span class="line">        - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">          valueFrom:</span><br><span class="line">            secretKeyRef:</span><br><span class="line">              name: java-demo-db</span><br><span class="line">              key: mysql-root-password</span><br><span class="line">        - name: MYSQL_PASSWORD</span><br><span class="line">          valueFrom:</span><br><span class="line">            secretKeyRef:</span><br><span class="line">              name: java-demo-db</span><br><span class="line">              key: mysql-password</span><br><span class="line">        - name: MYSQL_USER</span><br><span class="line">          value: <span class="string">&quot;azhe&quot;</span></span><br><span class="line">        - name: MYSQL_DATABASE</span><br><span class="line">          value: <span class="string">&quot;k8s&quot;</span></span><br><span class="line">        ports:</span><br><span class="line">        - name: mysql</span><br><span class="line">          containerPort: 3306</span><br><span class="line">        livenessProbe:</span><br><span class="line">          <span class="built_in">exec</span>:</span><br><span class="line">            <span class="built_in">command</span>:</span><br><span class="line">            - sh</span><br><span class="line">            - -c</span><br><span class="line">            - <span class="string">&quot;mysqladmin ping -u root -p<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span>&quot;</span></span><br><span class="line">          initialDelaySeconds: 30</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">        readinessProbe:</span><br><span class="line">          <span class="built_in">exec</span>:</span><br><span class="line">            <span class="built_in">command</span>:</span><br><span class="line">            - sh</span><br><span class="line">            - -c</span><br><span class="line">            - <span class="string">&quot;mysqladmin ping -u root -p<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span>&quot;</span></span><br><span class="line">          initialDelaySeconds: 5</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: data</span><br><span class="line">          mountPath: /var/lib/mysql</span><br><span class="line">        </span><br><span class="line">      volumes:</span><br><span class="line">      - name: data</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: java-demo-db</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo-db </span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">  accessModes:</span><br><span class="line">    - <span class="string">&quot;ReadWriteOnce&quot;</span></span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: <span class="string">&quot;8Gi&quot;</span></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo-db</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">  - name: mysql</span><br><span class="line">    port: 3306</span><br><span class="line">    targetPort: mysql</span><br><span class="line">  selector:</span><br><span class="line">    project: www</span><br><span class="line">    app: mysql </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service.yaml </span><br><span class="line">kubectl apply -f ingress.yaml </span><br><span class="line">kubectl apply -f mysql.yaml </span><br></pre></td></tr></table></figure>
<p><a href="http://xn--java-pr9l020c.ctnrs.com">访问java.ctnrs.com</a>，添加用户验证数据库是否可用</p>
<p>第四步：增加公网负载均衡器</p>
<p><img src="/images/FF2962E0EEF647ECBE7499D744E04A67clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream java-demo &#123;</span><br><span class="line">      server 192.168.0.12:80;</span><br><span class="line">      server 192.168.0.13:80;</span><br><span class="line">    &#125;</span><br><span class="line">      server &#123;</span><br><span class="line">         listen 81;</span><br><span class="line">         server_name java.ctnrs.com;</span><br><span class="line">         location / &#123;</span><br><span class="line">            proxy_pass http://java-demo;</span><br><span class="line">            proxy_set_header Host <span class="variable">$Host</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="http://xn--java-pr9l020c.ctnrs.com:81">访问java.ctnrs.com:81</a></p>
<p>1、为指定用户授权访问不同命名空间权限</p>
<p>2、使用Helm完成Java网站项目部署</p>
<p>注：自由发挥，实现需求即可</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>容器化搭建个人博客系统</title>
    <url>/2022/05/28/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Dockerfile涉及相关的文件及安装包</p>
<p><a href="/attachments/F00C39A38A9E42F1B5B1DB1B3DA7CB4Adockerfile.zip">dockerfile.zip</a></p>
<p><img src="/images/418306A840FE4995A255CA27354E9163clipboard.png" alt></p>
<p>前端项目镜像构建与部署：Nginx</p>
<p>nginx目录文件: 1.Dockerfile 2.nginx-1.15.5.tar.gz 3.nginx.conf4.php.conf</p>
<p>Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">LABEL maintainer www.ctnrs.com</span><br><span class="line">RUN yum install -y gcc gcc-c++ make \</span><br><span class="line">    openssl-devel pcre-devel gd-devel \</span><br><span class="line">    iproute net-tools telnet wget curl &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD nginx-1.15.5.tar.gz /</span><br><span class="line">RUN <span class="built_in">cd</span> nginx-1.15.5 &amp;&amp; \</span><br><span class="line">    ./configure --prefix=/usr/local/nginx \</span><br><span class="line">    --with-http_ssl_module \</span><br><span class="line">    --with-http_stub_status_module &amp;&amp; \</span><br><span class="line">    make -j 4 &amp;&amp; make install &amp;&amp; \</span><br><span class="line">    <span class="built_in">mkdir</span> /usr/local/nginx/conf/vhost &amp;&amp; \</span><br><span class="line">    <span class="built_in">cd</span> / &amp;&amp; <span class="built_in">rm</span> -rf nginx* &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/nginx/sbin</span><br><span class="line">COPY nginx.conf /usr/local/nginx/conf/nginx.conf</span><br><span class="line">WORKDIR /usr/local/nginx</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>nginx.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user                 nobody;</span><br><span class="line">worker_processes     4;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log  notice;</span><br><span class="line"></span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  4096;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    access_log off;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    client_max_body_size         64m;</span><br><span class="line">    include /usr/local/nginx/conf/vhost/*.conf;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        index index.html;</span><br><span class="line">        access_log logs/access.log;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>php.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.ctnrs.com;</span><br><span class="line">    index index.php index.html;</span><br><span class="line"></span><br><span class="line">    access_log logs/www.ctnrs.com_access.log;</span><br><span class="line">    error_log logs/www.ctnrs.com_error.log;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /wwwroot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~* \.php$ &#123;</span><br><span class="line">        root /wwwroot;</span><br><span class="line">        fastcgi_pass lnmp_php:9000;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PHP项目镜像构建：PHP</p>
<p>php目录文件: 1.Dockerfile 2.php-5.6.36.tar.gz 3.php-fpm.conf  4.php.ini</p>
<p>Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.ctnrs.com</span><br><span class="line">RUN yum install epel-release -y &amp;&amp; \</span><br><span class="line">    yum install -y gcc gcc-c++ make gd-devel libxml2-devel \</span><br><span class="line">    libcurl-devel libjpeg-devel libpng-devel openssl-devel \</span><br><span class="line">    libmcrypt-devel libxslt-devel libtidy-devel autoconf \</span><br><span class="line">    iproute net-tools telnet wget curl &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD php-5.6.36.tar.gz /</span><br><span class="line">RUN <span class="built_in">cd</span> php-5.6.36 &amp;&amp; \</span><br><span class="line">    ./configure --prefix=/usr/local/php \</span><br><span class="line">    --with-config-file-path=/usr/local/php/etc \</span><br><span class="line">    --enable-fpm --enable-opcache \</span><br><span class="line">    --with-mysql --with-mysqli --with-pdo-mysql \</span><br><span class="line">    --with-openssl --with-zlib --with-curl --with-gd \</span><br><span class="line">    --with-jpeg-dir --with-png-dir --with-freetype-dir \</span><br><span class="line">    --enable-mbstring --with-mcrypt --enable-hash &amp;&amp; \</span><br><span class="line">    make -j 4 &amp;&amp; make install &amp;&amp; \</span><br><span class="line">    <span class="built_in">cp</span> php.ini-production /usr/local/php/etc/php.ini &amp;&amp; \</span><br><span class="line">    <span class="built_in">cp</span> sapi/fpm/php-fpm.conf /usr/local/php/etc/php-fpm.conf &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">&quot;90a \daemonize = no&quot;</span> /usr/local/php/etc/php-fpm.conf &amp;&amp; \</span><br><span class="line">    <span class="built_in">mkdir</span> /usr/local/php/log &amp;&amp; \</span><br><span class="line">    <span class="built_in">cd</span> / &amp;&amp; <span class="built_in">rm</span> -rf php* &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/php/sbin</span><br><span class="line">COPY php.ini /usr/local/php/etc/</span><br><span class="line">COPY php-fpm.conf /usr/local/php/etc/</span><br><span class="line">WORKDIR /usr/local/php</span><br><span class="line">EXPOSE 9000</span><br><span class="line">CMD [<span class="string">&quot;php-fpm&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>容器化搭建个人博客系统</p>
<p>1、自定义网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create lnmp</span><br></pre></td></tr></table></figure>
<p>2、创建Mysql容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name lnmp_mysql --net lnmp --mount src=mysql-vol,dst=/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=wordpress mysql:5.7 --character-set-server=utf8</span><br></pre></td></tr></table></figure>
<p>3、创建PHP容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name lnmp_php --net lnmp --mount src=wwwroot,dst=/wwwroot php:v1</span><br></pre></td></tr></table></figure>
<p>4、创建Nginx容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name lnmp_nginx --net lnmp -p 88:80 --mount src=wwwroot,dst=/wwwroot --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,src=<span class="variable">$PWD</span>/php.conf,dst=/usr/local/nginx/conf/vhost/php.conf nginx:v1</span><br></pre></td></tr></table></figure>
<p>5、访问php网页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /var/lib/docker/volumes/wwwroot/_data/</span><br><span class="line">vim test.php</span><br><span class="line">&lt;?php phpinfo();?&gt;</span><br><span class="line"></span><br><span class="line">http://192.168.0.11:88/test.php</span><br></pre></td></tr></table></figure>
<p>6.以wordpress博客为例</p>
<p><a href="/attachments/DA30ED5D4B2C4750AEA183252F67A445wordpress-4.9.4-zh_CN.tar.gz">wordpress-4.9.4-zh_CN.tar.gz</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /var/lib/docker/volumes/wwwroot/_data/</span><br><span class="line">tar -zxf wordpress-4.9.4-zh_CN.tar.gz</span><br><span class="line"><span class="built_in">mv</span> wordpress/* .</span><br><span class="line"></span><br><span class="line">http://192.168.0.11:88</span><br></pre></td></tr></table></figure>
<p><img src="/images/691AF1100B69430F9FF94B594939ED9Eclipboard.png" alt></p>
<p><img src="/images/AA9191C1DDFA433D88B7445EB109505Dclipboard.png" alt></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工作负载控制器</title>
    <url>/2022/06/16/%E5%B8%B8%E7%94%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="工作负载控制器是什么">工作负载控制器是什么</h2>
<p>工作负载控制器（Workload Controllers）是K8s的一个抽象概念，用于更高级层次对象，部署和管理Pod。</p>
<p>常用工作负载控制器：</p>
<ul>
<li>
<p>Deployment ： 无状态应用部署</p>
</li>
<li>
<p>StatefulSet ： 有状态应用部署</p>
</li>
<li>
<p>DaemonSet ： 确保所有Node运行同一个Pod</p>
</li>
<li>
<p>Job ： 一次性任务</p>
</li>
<li>
<p>Cronjob ： 定时任务</p>
</li>
</ul>
<p>控制器的作用：</p>
<ul>
<li>
<p>管理Pod对象</p>
</li>
<li>
<p>使用标签与Pod关联</p>
</li>
<li>
<p>控制器实现了Pod的运维，例如滚动更新、伸缩、副本管理、维护Pod状态等。</p>
</li>
</ul>
<p><img src="/images/57989713257848DF8CDF41CBAA91FBB1clipboard.png" alt></p>
<h2 id="Deployment">Deployment</h2>
<h3 id="Deployment：介绍">Deployment：介绍</h3>
<p>Deployment的功能：</p>
<ul>
<li>
<p>管理Pod和ReplicaSet</p>
</li>
<li>
<p>具有上线部署、副本设定、滚动升级、回滚等功能</p>
</li>
<li>
<p>提供声明式更新，例如只更新一个新的Image 应用场景：网站、API、微服务</p>
</li>
</ul>
<h3 id="Deployment：使用流程">Deployment：使用流程</h3>
<p><img src="/images/7FCAD8175D234694B295C4780BB764D3clipboard.png" alt></p>
<h3 id="Deployment：部署">Deployment：部署</h3>
<p>第一步：部署镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f xxx.yaml </span><br><span class="line">kubectl create deployment web --image=nginx:1.15</span><br></pre></td></tr></table></figure>
<p>vim web-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: nginx:1.15</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>发布并访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web-deployment.yaml </span><br><span class="line">kubectl expose deployment web-deployment --port 80 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure>
<h3 id="Deployment：滚动升级">Deployment：滚动升级</h3>
<p>第二步：应用升级（更新镜像三种方式）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f xxx.yaml </span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/web nginx=nginx:1.16 </span><br><span class="line">kubectl edit deployment/web</span><br></pre></td></tr></table></figure>
<p>vim web-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: nginx:1.17</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /index.html</span><br><span class="line">            port: 80</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /index.html</span><br><span class="line">            port: 80</span><br><span class="line">          initialDelaySeconds: 10   <span class="comment">#启动容器后多少秒开始检查</span></span><br><span class="line">          periodSeconds: 10      <span class="comment">#以后间隔多少秒检查一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/3C61282B9CE64C02BCE02AC6E40E5605clipboard.png" alt></p>
<p>滚动升级：K8s对Pod升级的默认策略，通过使 用新版本Pod逐步更新旧版本Pod，实现零停机 发布，用户无感知。</p>
<p>滚动升级在K8s中的实现：</p>
<ul>
<li>
<p>1个Deployment</p>
</li>
<li>
<p>2个ReplicaSet</p>
</li>
</ul>
<p><img src="/images/9425F7FDCFEE49FE94E6D37E0A26B8C6clipboard.png" alt></p>
<ul>
<li>
<p>maxSurge：滚动更新过程中最大Pod副本数，确保在更新时启动的Pod数 量比期望（replicas）Pod数量最大多出25%</p>
</li>
<li>
<p>maxUnavailable：滚动更新过程中最大不可用Pod副本数，确保在更新时 最大25% Pod数量不可用，即确保75% Pod数量是可用状态。</p>
</li>
</ul>
<p><img src="/images/CD4FE9677984427DA97042EDB93D8695clipboard.png" alt></p>
<h3 id="Deployment：水平扩缩容">Deployment：水平扩缩容</h3>
<p>第三步：水平扩缩容（启动多实例，提高并发）</p>
<ul>
<li>
<p>修改yaml里replicas值，再apply</p>
</li>
<li>
<p>kubectl scale deployment web --replicas=10</p>
</li>
</ul>
<p>注：replicas参数控制Pod副本数量</p>
<p><img src="/images/C5A8BEFC58CA473986D5DBF11B8246F7clipboard.png" alt></p>
<h3 id="Deployment：回滚">Deployment：回滚</h3>
<p>第四步：回滚（发布失败恢复正常版本）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout <span class="built_in">history</span> deployment/web <span class="comment"># 查看历史发布版本 </span></span><br><span class="line">kubectl rollout undo deployment/web <span class="comment"># 默认回滚上一个版本 </span></span><br><span class="line">kubectl rollout undo deployment/web --to-revision=2 <span class="comment"># 回滚历史指定版本</span></span><br></pre></td></tr></table></figure>
<p>注：回滚是重新部署某一次部署时的状态，即当时版本所有配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deploy web-deployment web=nginx:1.19 --record  <span class="comment">#升级</span></span><br><span class="line">kubectl rollout undo deployment web-deployment --to-revision=7  <span class="comment">#回滚到指定版本</span></span><br><span class="line">kubectl get rs -o wide</span><br><span class="line">kubectl describe rs web-deployment-5449cf89f </span><br></pre></td></tr></table></figure>
<h3 id="Deployment：删除">Deployment：删除</h3>
<p>最后，项目下线：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete deploy/web </span><br><span class="line">kubectl delete svc/web</span><br></pre></td></tr></table></figure>
<h3 id="Deployment：ReplicaSet">Deployment：ReplicaSet</h3>
<p>ReplicaSet控制器用途：</p>
<ul>
<li>
<p>Pod副本数量管理，不断对比当前Pod数量与期望Pod数量</p>
</li>
<li>
<p>Deployment每次发布都会创建一个RS作为记录，用于实现回滚</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get rs <span class="comment">#查看RS记录 </span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment web <span class="comment">#版本对应RS记录</span></span><br><span class="line">kubectl describe rs |egrep -i <span class="string">&quot;revision|image&quot;</span>  <span class="comment">#查看版本对应的镜像</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/F05204D400AC49BD984EC2F32E0FB304clipboard.png" alt></p>
<h2 id="DaemonSet">DaemonSet</h2>
<p>DaemonSet功能：</p>
<ul>
<li>
<p>在每一个Node上运行一个Pod</p>
</li>
<li>
<p>新加入的Node也同样会自动运行一个Pod</p>
</li>
</ul>
<p>应用场景：网络插件（kube-proxy、calico）、其他Agent</p>
<p><img src="/images/8D4FD2F4A8E3450CB224EABA85A1F388clipboard.png" alt></p>
<p>示例：部署一个日志采集程序</p>
<p>vim daemonset.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet        </span><br><span class="line">metadata:</span><br><span class="line">  name: filebeat</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: filebeat</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: filebeat</span><br><span class="line">    spec:</span><br><span class="line">      tolerations:               </span><br><span class="line">      - effect: NoSchedule        <span class="comment">#配置污点容忍，确保分配到每个节点</span></span><br><span class="line">        operator: Exists  <span class="comment">#没有配置键值形式，节点上只要有NoSchedule策略，只要存在就容忍</span></span><br><span class="line">      containers:</span><br><span class="line">      - name: <span class="built_in">log</span></span><br><span class="line">        image: elastic/filebeat:7.3.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f daemonset.yaml </span><br><span class="line">kubectl get daemonsets.apps -n kube-system  <span class="comment">#查看使用daemonset控制器的pod</span></span><br><span class="line">kubectl get daemonsets.apps calico-node -o yaml -n kube-system | grep tor </span><br><span class="line">kubectl get pod -n kube-system -o wide  <span class="comment">#确保在每个节点都启动一个日志采集器pod   </span></span><br></pre></td></tr></table></figure>
<h2 id="Job">Job</h2>
<p>Job分为普通任务（Job）和定时任务（CronJob）</p>
<ul>
<li>一次性执行</li>
</ul>
<p>应用场景：离线数据处理，视频解码等业务</p>
<p>vim job.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: pi</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: pi</span><br><span class="line">        image: perl</span><br><span class="line">        <span class="built_in">command</span>: [<span class="string">&quot;perl&quot;</span>, <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">      restartPolicy: Never         <span class="comment">#执行完容器就退出</span></span><br><span class="line">  backoffLimit: 4 <span class="comment"># 重试次数</span></span><br></pre></td></tr></table></figure>
<p>查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f job.yaml </span><br><span class="line">kubectl get job</span><br><span class="line">kubectl get pod    <span class="comment">#complete状态，需要主动删除pod</span></span><br><span class="line">kubectl logs pi-z7rrb </span><br></pre></td></tr></table></figure>
<h2 id="CronJob">CronJob</h2>
<p>CronJob用于实现定时任务，像Linux的Crontab一样。</p>
<ul>
<li>定时任务 应用场景：通知，备份</li>
</ul>
<p>vim cronjob.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: batch/v1beta1</span><br><span class="line">kind: CronJob</span><br><span class="line">metadata:</span><br><span class="line">  name: hello</span><br><span class="line">spec:</span><br><span class="line">  schedule: <span class="string">&quot;*/1 * * * *&quot;</span>     <span class="comment">#跟Linux的crontab一样写法</span></span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        spec:</span><br><span class="line">          containers:</span><br><span class="line">          - name: hello</span><br><span class="line">            image: busybox</span><br><span class="line">            args:</span><br><span class="line">            - /bin/sh</span><br><span class="line">            - -c</span><br><span class="line">            - <span class="built_in">date</span>; <span class="built_in">echo</span> Hello azhe</span><br><span class="line">          restartPolicy: OnFailure   <span class="comment">#如果执行上面的命令失败返回状态码非0会帮你重启容器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f cronjob.yaml </span><br><span class="line">kubectl get job</span><br><span class="line">kubectl get cronjob</span><br><span class="line">kubectl logs hello-1613720220-ldb7z </span><br></pre></td></tr></table></figure>
<p><img src="/images/E705E25E66D840228B054BA469DE8828clipboard.png" alt></p>
<p><img src="/images/8FC4E782A0F040F3A6A2F40F0581134Fclipboard.png" alt></p>
<p><img src="/images/57136FADCE894FA7BF380678271AD152clipboard.png" alt></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务容器化迁移</title>
    <url>/2023/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h2 id="从运维角度看微服务">从运维角度看微服务</h2>
<h3 id="单体应用-vs-微服务">单体应用 vs 微服务</h3>
<p><img src="/images/CF73043D4E92439A8F92CC6B937B6AB3clipboard.png" alt></p>
<p>特点：</p>
<ul>
<li>
<p>易于部署</p>
</li>
<li>
<p>易于测试</p>
</li>
</ul>
<p>不足：</p>
<ul>
<li>
<p>代码膨胀，难以维护</p>
</li>
<li>
<p>构建、部署成本大</p>
</li>
<li>
<p>新人上手难</p>
</li>
</ul>
<p><img src="/images/97549FF2AF58428EA2A5684C48153052clipboard.png" alt></p>
<h3 id="微服务特点">微服务特点</h3>
<p>服务组件化</p>
<p>每个服务独立开发、部署，有效避免一个服务的修改引起整个系统重新部署。</p>
<p>技术栈灵活</p>
<p>约定通信方式，使得服务本身功能实现对技术要求不再那么敏感。</p>
<p>独立部署</p>
<p>每个微服务独立部署，加快部署速度，方便扩展。</p>
<p>扩展性强</p>
<p>每个微服务可以部署多个，并且有负载均衡能力。</p>
<p>独立数据</p>
<p>每个微服务有独立的基本组件，例如数据库、缓存等。</p>
<h3 id="微服务不足">微服务不足</h3>
<ul>
<li>
<p>沟通成本</p>
</li>
<li>
<p>数据一致性</p>
</li>
<li>
<p>运维成本：部署、监控</p>
</li>
<li>
<p>内部架构复杂性</p>
</li>
<li>
<p>大量服务治理</p>
</li>
</ul>
<h3 id="Java微服务框架">Java微服务框架</h3>
<ul>
<li>
<p>Spring Boot：快速开发微服务的框架</p>
</li>
<li>
<p>Spring Cloud：基于SpringBoot实现的一个完整的微服务解决方案</p>
</li>
<li>
<p>Dubbo：阿里巴巴开源的微服务治理框架</p>
</li>
</ul>
<h2 id="在K8s平台部署微服务考虑的问题">在K8s平台部署微服务考虑的问题</h2>
<h3 id="常见微服务架构图">常见微服务架构图</h3>
<p><img src="/images/56F56B2D53AC4FAB83088615376A5720clipboard.png" alt></p>
<h3 id="对微服务项目架构理解">对微服务项目架构理解</h3>
<ul>
<li>
<p>微服务间如何通信？REST API，RPC，MQ</p>
</li>
<li>
<p>微服务如何发现彼此？注册中心</p>
</li>
<li>
<p>组件之间怎么个调用关系？</p>
</li>
<li>
<p>哪个服务作为整个网站入口？前后端分离</p>
</li>
<li>
<p>哪些微服务需要对外访问？前端和微服务网关</p>
</li>
<li>
<p>微服务怎么部署？更新？扩容？</p>
</li>
<li>
<p>区分有状态应用与无状态应用</p>
</li>
</ul>
<h3 id="为什么用注册中心系统">为什么用注册中心系统</h3>
<p>微服务太多面临的问题：</p>
<ul>
<li>
<p>怎么记录一个微服务多个副本接口地址？</p>
</li>
<li>
<p>怎么实现一个微服务多个副本负载均衡？</p>
</li>
<li>
<p>怎么判断一个微服务副本是否可用？</p>
</li>
</ul>
<p>主流注册中心：Eureka，Nacos，Consul</p>
<p><img src="/images/C5A801E6B7A84C39A42B57A158172029clipboard.png" alt></p>
<h3 id="在K8s部署项目流程">在K8s部署项目流程</h3>
<p><img src="/images/4F2E70888DF042E797024352C3D5E5EAclipboard.png" alt></p>
<h2 id="在K8S平台部署Spring-Cloud微服务项目">在K8S平台部署Spring Cloud微服务项目</h2>
<h3 id="容器化微服务项目实施步骤">容器化微服务项目实施步骤</h3>
<p>具体步骤：</p>
<p>第一步：熟悉Spring Cloud微服务项目</p>
<p>第二步：源代码编译构建</p>
<p>第三步：构建项目镜像并推送到镜像仓库</p>
<p>第四步：K8s服务编排</p>
<p>第五步：在K8s中部署Eureka集群（注册中心）和MySQL数据库</p>
<p>第六步：部署微服务网关服务</p>
<p>第七步：部署微服务业务程序</p>
<p>第八步：部署微服务前端</p>
<p>第九步：微服务对外发布</p>
<p>第十步：微服务升级与扩容</p>
<p>第一步：熟悉Spring Cloud微服务项目</p>
<p><img src="/images/2B032000314E4C80BCA651C8FD2B83D5clipboard.png" alt></p>
<p><a href="https://gitee.com/lucky_liuzhe/simple-microservice">https://gitee.com/lucky_liuzhe/simple-microservice</a></p>
<p>代码分支说明：</p>
<ul>
<li>
<p>dev1 交付代码</p>
</li>
<li>
<p>dev2 增加Dockerfile</p>
</li>
<li>
<p>dev3 增加K8s资源编排</p>
</li>
<li>
<p>dev4 增加APM监控系统</p>
</li>
<li>
<p>master 最终上线</p>
</li>
</ul>
<p><img src="/images/B9386F315D434B56A0406E9DBEE40414clipboard.png" alt></p>
<p>第二步：源代码编译构建</p>
<p>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管 理工具软件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk maven -y</span><br><span class="line">修改maven源：https://maven.aliyun.com/mvn/guide</span><br><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>第三步：构建项目镜像并推送到镜像仓库</p>
<p><img src="/images/C0AB7281B6324798840833AF5AF4B88Bclipboard.png" alt></p>
<p>Dockerfile文件更换apk阿里云源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">链接：https://blog.csdn.net/qq_33657251/article/details/107526842</span><br><span class="line">sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories &amp;&amp; \</span><br><span class="line"><span class="comment">#使用sed工具将字符串dl-cdn.alpinelinux.org替换为mirrors.aliyun.com</span></span><br></pre></td></tr></table></figure>
<p>第四步：K8s服务编排</p>
<p><img src="/images/130E9C7374BD421C81F4C4882C1CB93Cclipboard.png" alt></p>
<p>第五步：在K8s中部署Erureka集群和MySQL数据库</p>
<p>1.删除Dockerfile中运行的拷贝时区的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name Dockerfile | xargs -i sed -i <span class="string">&#x27;/RUN/d&#x27;</span> &#123;&#125;</span><br><span class="line">find . -name Dockerfile | xargs -i sed -i <span class="string">&#x27;/ln/d&#x27;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/3696E1B7014849EF94335658C09A15C6clipboard.png" alt></p>
<p>2.修改源代码中eureka配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat eureka-service/src/main/resources/application-fat.yml</span></span><br><span class="line">eureka:</span><br><span class="line">  server:</span><br><span class="line">    renewal-percent-threshold: 0.9</span><br><span class="line">    enable-self-preservation: <span class="literal">false</span></span><br><span class="line">    eviction-interval-timer-in-ms: 40000</span><br><span class="line">  instance:</span><br><span class="line">    hostname: 127.0.0.1</span><br><span class="line">    prefer-ip-address: <span class="literal">false</span>     <span class="comment">#使用ip去通信，默认是使用主机名</span></span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">true</span></span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://eureka-0.eureka.ms:<span class="variable">$&#123;server.port&#125;</span>/eureka/,http://eureka-1.eureka.ms:<span class="variable">$&#123;server.port&#125;</span>/eureka/,http://eureka-2.eureka.ms:<span class="variable">$&#123;server.port&#125;</span>/eureka/</span><br><span class="line">    fetch-registry: <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>prefer-ip-address: false  由于使用statefulset部署默认使用主机名通信，其他微服务使用deployment部署无法使用主机名通信，dns无法解析，所以修改为使用IP去通信。</p>
<p>Eureka集群节点Pod DNS名称：</p>
<p><a href="http://eureka-0.eureka.ms.svc.cluster.local">http://eureka-0.eureka.ms.svc.cluster.local</a></p>
<p><a href="http://eureka-1.eureka.ms.svc.cluster.local">http://eureka-1.eureka.ms.svc.cluster.local</a></p>
<p><a href="http://eureka-2.eureka.ms.svc.cluster.local">http://eureka-2.eureka.ms.svc.cluster.local</a></p>
<p>3.修改docker_build.sh 文件</p>
<p>修改镜像仓库地址，要推送的镜像仓库项目名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi docker_build.sh </span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">docker_registry=192.168.0.14</span><br><span class="line">kubectl create secret docker-registry registry-pull-secret --docker-server=<span class="variable">$docker_registry</span> --docker-username=admin --docker-password=Harbor12345 --docker-email=admin@ctnrs.com -n ms</span><br><span class="line"></span><br><span class="line">service_list=<span class="string">&quot;eureka-service gateway-service order-service product-service stock-service portal-service&quot;</span></span><br><span class="line">service_list=<span class="variable">$&#123;1:-<span class="variable">$&#123;service_list&#125;</span>&#125;</span></span><br><span class="line">work_dir=$(<span class="built_in">dirname</span> <span class="variable">$PWD</span>)</span><br><span class="line">current_dir=<span class="variable">$PWD</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$work_dir</span></span><br><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> service <span class="keyword">in</span> <span class="variable">$service_list</span>; <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">cd</span> <span class="variable">$work_dir</span>/<span class="variable">$service</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">ls</span> |grep biz &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">cd</span> <span class="variable">$&#123;service&#125;</span>-biz</span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line">   service=<span class="variable">$&#123;service%-*&#125;</span></span><br><span class="line">   image_name=<span class="variable">$docker_registry</span>/ms/<span class="variable">$&#123;service&#125;</span>:$(<span class="built_in">date</span> +%F-%H-%M-%S)</span><br><span class="line">   docker build -t <span class="variable">$&#123;image_name&#125;</span> .</span><br><span class="line">   docker push <span class="variable">$&#123;image_name&#125;</span></span><br><span class="line">   sed -i -r <span class="string">&quot;s#(image: )(.*)#\1<span class="variable">$image_name</span>#&quot;</span> <span class="variable">$&#123;current_dir&#125;</span>/<span class="variable">$&#123;service&#125;</span>.yaml</span><br><span class="line">   kubectl apply -f <span class="variable">$&#123;current_dir&#125;</span>/<span class="variable">$&#123;service&#125;</span>.yaml</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.创建命名空间并部署eureka服务并启动（记得部署之前要部署ingress控制器）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建命名空间</span></span><br><span class="line">kubectl create ns ms</span><br><span class="line"><span class="comment">#启动部署(修改各个微服务yaml文件中的requests，请求资源设置小一点0.2)</span></span><br><span class="line">./docker_build.sh eureka-service</span><br></pre></td></tr></table></figure>
<p>5.部署MySQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#部署MySQL</span></span><br><span class="line">kubectl apply -f mysql.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入sql文件</span></span><br><span class="line">将源代码里db目录下sql文件拷贝到mysql容器并导入：</span><br><span class="line">kubectl <span class="built_in">cp</span> order.sql mysql-68d6f45844-kc6v4:/ -n ms</span><br><span class="line">kubectl <span class="built_in">cp</span> product.sql mysql-68d6f45844-kc6v4:/ -n ms</span><br><span class="line">kubectl <span class="built_in">cp</span> stock.sql mysql-68d6f45844-kc6v4:/ -n ms</span><br><span class="line">kubectl <span class="built_in">exec</span> -it mysql-68d6f45844-kc6v4 -n ms -- bash</span><br><span class="line"><span class="comment">#mysql -u root -p$MYSQL_ROOT_PASSWORD</span></span><br><span class="line">mysql&gt; create database tb_product;</span><br><span class="line">mysql&gt; use tb_product;</span><br><span class="line">mysql&gt; <span class="built_in">source</span> /product.sql;</span><br><span class="line"></span><br><span class="line">mysql&gt; create database tb_order;</span><br><span class="line">mysql&gt; use tb_order;</span><br><span class="line">mysql&gt; <span class="built_in">source</span> /order.sql;</span><br><span class="line"></span><br><span class="line">mysql&gt; create database tb_stock;</span><br><span class="line">mysql&gt; use tb_stock;</span><br><span class="line">mysql&gt; <span class="built_in">source</span> /stock.sql;</span><br></pre></td></tr></table></figure>
<p>MySQL Service DNS名称：mysql.ms.svc.cluster.local</p>
<p>第六步至第九步：在K8s中部署微服务</p>
<ul>
<li>
<p>部署业务程序（product、stock、order）</p>
</li>
<li>
<p>部署网关（gateway）</p>
</li>
<li>
<p>部署前端（portal）</p>
</li>
</ul>
<p>修改product、stock、order连接数据库地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi product-service/product-service-biz/src/main/resources/application-fat.yml </span></span><br><span class="line">url: jdbc:mysql://mysql:3306/tb_product?characterEncoding=utf-8</span><br><span class="line"><span class="comment">#其余两个微服务同上操作</span></span><br></pre></td></tr></table></figure>
<p>启动部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改各个微服务yaml文件中的requests，请求资源设置小一点0.2（java太吃内存）</span></span><br><span class="line"><span class="built_in">cd</span> k8s/</span><br><span class="line">./docker_build.sh product-service</span><br><span class="line">./docker_build.sh order-service</span><br><span class="line">./docker_build.sh stock-service</span><br><span class="line">./docker_build.sh gateway-service</span><br><span class="line">./docker_build.sh portal-service</span><br></pre></td></tr></table></figure>
<p>第十步：微服务升级与扩容</p>
<p>微服务升级：对要升级的微服务进行上述步骤打包镜像:版本，替代运行的镜像</p>
<p>微服务扩容：对Pod扩容副本数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment product --replicas=2 -n ms </span><br></pre></td></tr></table></figure>
<h3 id="生产环境踩坑经验分享">生产环境踩坑经验分享</h3>
<p>Q：限制了容器资源，还经常被杀死？</p>
<p>A：在JAVA1.9版本之前，是不能自动发现docker设置的 内存限制，随着应用负载起伏就会造成内存使用过大， 超过limits限制，从而触发K8s杀掉该容器。</p>
<p>解决办法：</p>
<ul>
<li>
<p>手动指定JVM堆内存大小</p>
</li>
<li>
<p>配置JVM自动识别（1.9版本+才支持）-</p>
</li>
</ul>
<p>XX:+UnlockExperimentalVMOptions -</p>
<p>XX:+UseCGroupMemoryLimitForHeap</p>
<p><img src="/images/03ABE34358714138A3E1E3B146A3AA20clipboard.png" alt></p>
<p>Q：滚动更新期间造成流量丢失</p>
<p>A：滚动更新触发，Pod在删除过程中，有些节点kube-proxy还没来得及同步iptables规则， 从而部分流量请求到Terminating的Pod上，导致请求出错。</p>
<p>解决办法：配置preStop回调，在容器终止前优雅暂停5秒，给kube-proxy多预留一点时间。</p>
<p><img src="/images/E8E29475D9EB4E6BA6A1F11B65CE7D2Cclipboard.png" alt></p>
<p>Q：滚动更新之健康检查重要性</p>
<p>A：滚动更新是默认发布策略，当配置健康检查时，滚动更新会根据Probe状 态来决定是否继续更新以及是否允许接入流量，这样在整个滚动更新过程中可 保证始终会有可用的Pod存在，达到平滑升级。</p>
<p><img src="/images/543879804CF04A2EAF15509904A62A9Eclipboard.png" alt></p>
<h2 id="APM监控微服务项目">APM监控微服务项目</h2>
<h3 id="微服务监控需求">微服务监控需求</h3>
<p>随着微服务架构的流行，服务按照不同的维度进行拆分，一次请求往往需要 涉及到多个服务。这些服务可能不同编程语言开发，不同团队开发，可能部 署很多副本。因此，就需要一些可以帮助理解系统行为、用于分析性能问题 的工具，以便发生故障的时候，能够快速定位和解决问题。“APM系统” 就 在这样的问题背景下产生了。</p>
<p>APM系统 从整体维度到局部维度展示各项指标，将跨应用的所有调用链性能 信息集中展现，可方便度量整体和局部性能，并且方便找到故障产生的源头， 生产上可极大缩短故障排除时间</p>
<p><img src="/images/C31EEB76852B48C98F86C18885A56576clipboard.png" alt></p>
<h3 id="APM监控系统是什么">APM监控系统是什么</h3>
<p>APM（ApplicationPerformance Management）是一种应用性能监控工具，通过汇聚业务系统各处理 环节的实时数据，分析业务系统各事务处理的交易路径和处理时间，实现对应用的全链路性能监测。</p>
<p>相比接触的Prometheus、Zabbix这类监控系统，APM系统主要监控对应用程序内部，例如：</p>
<ul>
<li>
<p>请求链路追踪：通过分析服务调用关系，绘制运行时拓扑信息，可视化展示</p>
</li>
<li>
<p>调用情况衡量：各个调用环节的性能分析，例如吞吐量、响应时间、错误次数</p>
</li>
<li>
<p>运行情况反馈：告警，通过调用链结合业务日志快速定位错误信息</p>
</li>
</ul>
<h3 id="APM监控系统选择依据">APM监控系统选择依据</h3>
<p>APM类监控系统有：Skywalking、Pinpoint、Zipkin</p>
<p>关于选型，可以从以下方面考虑：</p>
<p>探针的性能消耗</p>
<p>APM组件服务的影响应该做到足够小，数据分析要快，性能占用小。</p>
<p>代码的侵入性</p>
<p>即也作为业务组件，应当尽可能少入侵或者无入侵其他业务系统，对于使用 方透明，减少开发人员的负担。</p>
<p>监控维度</p>
<p>分析的维度尽可能多。</p>
<p>可扩展性</p>
<p>一个优秀的调用跟踪系统必须支持分布式部署，具备良好的可扩展性。能够 支持的组件越多当然越好。</p>
<h3 id="Skywalking介绍">Skywalking介绍</h3>
<p>Skywalking 是一个分布式应用程序性能监控系统，针对微服务体系结构而设计。</p>
<p>功能：</p>
<ul>
<li>
<p>多种监控手段。可以通过语言探针和 service mesh 获得监控是数据。</p>
</li>
<li>
<p>多个语言自动探针。包括 Java，.NET Core 和 Node.JS。</p>
</li>
<li>
<p>轻量高效。无需大数据平台，和大量的服务器资源。</p>
</li>
<li>
<p>模块化。UI、存储、集群管理都有多种机制可选。</p>
</li>
<li>
<p>支持告警。</p>
</li>
<li>
<p>优秀的可视化解决方案。</p>
</li>
</ul>
<h3 id="Skywalking架构">Skywalking架构</h3>
<p><img src="/images/E1BBAA9498D24E019DDE045649A3ADBBclipboard.png" alt></p>
<p><img src="/images/6926700A02404FB6B29E6B2B5A20ADECclipboard.png" alt></p>
<h3 id="Skywalking部署">Skywalking部署</h3>
<p>1、部署ES数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -e <span class="string">&quot;discovery.type=single-node&quot;</span> -d elasticsearch:7.7.0</span><br></pre></td></tr></table></figure>
<p>2、部署Skywalking OAP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">软件包下载地址：https://archive.apache.org/dist/skywalking/8.3.0/</span><br><span class="line">yum install java-11-openjdk –y</span><br><span class="line">tar zxvf apache-skywalking-apm-es7-8.3.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> apache-skywalking-apm-bin-es7/</span><br></pre></td></tr></table></figure>
<p>指定数据源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi config/application.yml</span></span><br><span class="line">storage: </span><br><span class="line">    selector: <span class="variable">$&#123;SW_STORAGE:elasticsearch7&#125;</span> <span class="comment">#这里使用elasticsearch7</span></span><br><span class="line">    ...</span><br><span class="line">    elasticsearch7: </span><br><span class="line">        nameSpace: <span class="variable">$&#123;SW_NAMESPACE:&quot;&quot;&#125;</span> </span><br><span class="line">        clusterNodes: <span class="variable">$&#123;SW_STORAGE_ES_CLUSTER_NODES:192.168.0.10:9200&#125;</span> <span class="comment"># 指定ES地址</span></span><br></pre></td></tr></table></figure>
<p>启动OAP和UI：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/startup.sh</span><br></pre></td></tr></table></figure>
<p>访问UI：<a href="http://IP:8080">http://IP:8080</a></p>
<h3 id="微服务接入Skywalking监控">微服务接入Skywalking监控</h3>
<p>内置Agent包路径：apache-skywalking-apm-bin-es7/agent/</p>
<p>启动Java程序以探针方式集成Agent：</p>
<p>java -jar -javaagent:/skywalking/skywalking-agent.jar=agent.service_name=&lt;项目名称 &gt;,agent.instance_name=&lt;实例名称&gt;,collector.backend_service=:11800 xxx.jar</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用dev4分支部署</span></span><br><span class="line"><span class="comment">#注意修改的部分：</span></span><br><span class="line">1.修改每个微服务下的Dockerfile中连接Skywalking服务器地址以及application-fat.yml</span><br><span class="line">中连接MySQL服务器的地址</span><br><span class="line">2.修改docker_build.sh脚本中连接harbor服务器的地址以及推送到镜像仓库的项目名</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Skywalking-UI使用">Skywalking UI使用</h3>
<p><img src="/images/F6B490280E3F405986346EF4426185CBclipboard.png" alt></p>
<ul>
<li>
<p>第一栏：不同内容主题的监控面板，应用/数据库/容器等</p>
</li>
<li>
<p>第二栏：操作，包括编辑/导出当前数据/倒入展示数据/不同服务端点筛选展示</p>
</li>
<li>
<p>第三栏：不同纬度展示，服务/实例/端点</p>
</li>
</ul>
<p><img src="/images/9EB6C2B5C2D84DC6A2593C66EE25F3E5clipboard.png" alt></p>
<p>全局：</p>
<ul>
<li>
<p>Service Load：CPM 每分钟回调次数</p>
</li>
<li>
<p>Slow Services：慢响应服务，单位ms</p>
</li>
<li>
<p>Un-Health Services：不健康的服务，1为满分</p>
</li>
<li>
<p>Slow Endpoints：慢端点，单位ms</p>
</li>
<li>
<p>Global Response Latency：百分比响应延时，不同百分 比的延时时间，单位ms</p>
</li>
<li>
<p>Global Heatmap：服务响应时间热力分布图，根据时间 段内不同响应时间的数量显示颜色深度</p>
</li>
<li>
<p>底部栏：展示数据的时间区间，点击可以调整</p>
</li>
</ul>
<p><img src="/images/CF412AFC16BE4D87891F6104CB7F0F5Aclipboard.png" alt></p>
<p>Service：</p>
<ul>
<li>
<p>Service Apdex（数字）:当前服务的评分</p>
</li>
<li>
<p>Service Apdex（折线图）：当前服务评分趋势图</p>
</li>
<li>
<p>Service Avg Response Times：服务平均响应时间，单 位ms</p>
</li>
<li>
<p>Service Response Time Percentile：服务响应时间百分 比，单位ms</p>
</li>
<li>
<p>Successful Rate（数字）：请求成功率</p>
</li>
<li>
<p>Successful Rate（折线图）：请求成功率趋势图</p>
</li>
<li>
<p>Servce Load（数字）：每分钟请求数</p>
</li>
<li>
<p>Servce Load（折线图）：每分钟请求数趋势图</p>
</li>
<li>
<p>Servce Instances Load：服务实例的每分钟请求数</p>
</li>
<li>
<p>Slow Service Instance：慢服务实例，单位ms</p>
</li>
<li>
<p>Service Instance Successful Rate：服务实例成功率</p>
</li>
</ul>
<p><img src="/images/C79A0E385FAE42D28182674C1412A8C3clipboard.png" alt></p>
<p>Instance：</p>
<ul>
<li>
<p>Service Instance Load：当前实例的每分钟请求数</p>
</li>
<li>
<p>Service Instance Successful Rate：当前实例的请求成功率</p>
</li>
<li>
<p>Service Instance Latency：当前实例的响应延时</p>
</li>
<li>
<p>JVM CPU：jvm占用CPU的百分比</p>
</li>
<li>
<p>JVM Memory：JVM堆内存，单位MB</p>
</li>
<li>
<p>JVM GC Time：JVM垃圾回收时间，包含YGC和OGC</p>
</li>
<li>
<p>JVM GC Count：JVM垃圾回收次数，包含YGC和OGC</p>
</li>
<li>
<p>JVM Thread Count：JVM线程统计CLR XX：.NET服务的 指标，类似JVM虚拟机</p>
</li>
</ul>
<p><img src="/images/478535722F1A4126AE64F077CC4E9F29clipboard.png" alt></p>
<p>Instance：</p>
<ul>
<li>
<p>Endpoint Load in Current Service：每个端点的每分钟请求数</p>
</li>
<li>
<p>Slow Endpoints in Current Service：每个端点的最慢请求时间， 单位ms</p>
</li>
<li>
<p>Successful Rate in Current Service：每个端点的请求成功率</p>
</li>
<li>
<p>Endpoint Load：端点请求数趋势图</p>
</li>
<li>
<p>Endpoint Avg Response Time：端点平均响应时间趋势图</p>
</li>
<li>
<p>Endpoint Response Time Percentile：端口响应时间的百分位数</p>
</li>
<li>
<p>Endpoint Successful Rate：端点请求成功率</p>
</li>
</ul>
<p><img src="/images/2D7C6A7C67D14F698D466688DBBDCF9Fclipboard.png" alt></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务治理istio初探上</title>
    <url>/2023/12/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86istio%E5%88%9D%E6%8E%A2%E4%B8%8A/</url>
    <content><![CDATA[<h2 id="Service-Mesh">Service Mesh</h2>
<p>Service Mesh 的中文译为 “服务网格” ，是一个用于处理服务 和服务之间通信的基础设施层，它负责为构建复杂的云原生应用 传递可靠的网络请求，并为服务通信实现了微服务所需的基本组 件功能，例如服务发现、负载均衡、监控、流量管理、访问控制 等。在实践中，服务网格通常实现为一组和应用程序部署在一起 的轻量级的网络代理，但对应用程序来说是透明的。</p>
<p>右图，绿色方块为应用服务，蓝色方块为 Sidecar Proxy，应用 服务之间通过 Sidecar Proxy 进行通信，整个服务通信形成图中 的蓝色网络连线，图中所有蓝色部分就形成一个网络，这个就是 服务网格名字的由来。</p>
<p><img src="/images/4B16166E7B5D4A9C8EF473CEF39CBAFDclipboard.png" alt></p>
<h2 id="Service-Mesh特点">Service Mesh特点</h2>
<p>Service Mesh有以下特点：</p>
<ul>
<li>
<p>治理能力独立（Sidecar）</p>
</li>
<li>
<p>应用程序无感知</p>
</li>
<li>
<p>服务通信的基础设施层</p>
</li>
<li>
<p>解耦应用程序的重试/超时、监控、追踪和服务发现</p>
</li>
</ul>
<p><img src="/images/C29CFDD8671144E4B028504B2E4966CEclipboard.png" alt></p>
<h2 id="Istio概述">Istio概述</h2>
<p>Isito是Service Mesh的产品化落地，是目前最受欢迎的服务网格，功能丰富、成熟度高。</p>
<p>Linkerd是世界上第一个服务网格类的产品。</p>
<ul>
<li>
<p>连接（Connect）</p>
</li>
<li>
<p>流量管理</p>
</li>
<li>
<p>负载均衡</p>
</li>
<li>
<p>灰度发布</p>
</li>
<li>
<p>安全（Secure）</p>
</li>
<li>
<p>认证 - 鉴权</p>
</li>
<li>
<p>控制（Control）</p>
</li>
<li>
<p>限流</p>
</li>
<li>
<p>ACL</p>
</li>
<li>
<p>观察（Observe）</p>
</li>
<li>
<p>监控</p>
</li>
<li>
<p>调用链</p>
</li>
</ul>
<p><img src="/images/34F3225902F843979C4F1E091D8D84ABclipboard.png" alt></p>
<p><img src="/images/3F033BCA807D4B148FEBD1030E2FA455clipboard.png" alt></p>
<h2 id="Istio版本变化">Istio版本变化</h2>
<p>在Istio1.5版本发生了一个重大变革，彻底推翻原有控制平面的架构，将有原有多个组件整合为单体结构 “istiod”，同时废弃了Mixer 组件，如果你正在使用之前版本，必须了解这些变化。</p>
<p><img src="/images/3432DCE395E34C519D680A715D39AA2Dclipboard.png" alt></p>
<h2 id="Istio架构与组件">Istio架构与组件</h2>
<p>Istio服务网格在逻辑上分为数据平面和控制平面。</p>
<ul>
<li>控制平面：使用全新的部署模式：istiod，这个组件负责处理Sidecar注入、证书分发、配置管理等功能，替 代 原有组件，降低复杂度，提高易用性。</li>
</ul>
<p>Pilot：策略配置组件，为Proxy提供服务发现、智能路由、错误处理等。</p>
<p>Citadel：安全组件，提供证书生成下发、加密通信、访问控制。</p>
<p>Galley：配置管理、验证、分发。</p>
<ul>
<li>数据平面：由一组Proxy组成，这些Proxy负责所有微服务网络通信，实现高效转发和策略。使用envoy实现， envoy是一个基于C++实现的L4/L7 Proxy转发器，是Istio在数据平面唯一的组件。</li>
</ul>
<h2 id="Istio基本概念">Istio基本概念</h2>
<p>Istio 有 4 个配置资源，落地所有流量管理需求：</p>
<ul>
<li>
<p>VirtualService（虚拟服务）：实现服务请求路由规则的功能。</p>
</li>
<li>
<p>DestinationRule（目标规则）：实现目标服务的负载均衡、服务发现、故障处理和故障注入的功能。</p>
</li>
<li>
<p>Gateway（网关）：让服务网格内的服务，可以被全世界看到。</p>
</li>
<li>
<p>ServiceEntry（服务入口） ：允许管理网格外的服务的流量。</p>
</li>
</ul>
<h2 id="部署Istio">部署Istio</h2>
<p>官方文档：<a href="https://preliminary.istio.io/latest/zh/docs/setup/getting-started">https://preliminary.istio.io/latest/zh/docs/setup/getting-started</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L https://istio.io/downloadIstio | sh -</span><br><span class="line">tar zxvf istio-1.8.2-linux.tar.gz</span><br><span class="line"><span class="built_in">cd</span> istio-1.8.2</span><br><span class="line"><span class="built_in">mv</span> bin/istioctl /usr/bin</span><br><span class="line">istioctl profile list</span><br><span class="line">istioctl install</span><br><span class="line">或者istioctl install --<span class="built_in">set</span> profile=default -y</span><br><span class="line"><span class="comment">#查看具体的profile开启了哪些组件可用如下命令</span></span><br><span class="line">istioctl profile dump [default|demo|minimal|remote|empty|preview]</span><br><span class="line">kubectl get pods -n istio-system </span><br><span class="line">kubectl get svc -n istio-system</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载：</span></span><br><span class="line">istioctl manifest generate | kubectl delete -f -</span><br></pre></td></tr></table></figure>
<h2 id="Sidercar注入">Sidercar注入</h2>
<p>部署httpbin Web示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> istio-1.8.2/samples/httpbin</span><br></pre></td></tr></table></figure>
<p>手动注入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f &lt;(istioctl kube-inject -f httpbin-nodeport.yaml)</span><br><span class="line">或者</span><br><span class="line">istioctl kube-inject -f httpbin-nodeport.yaml |kubectl apply -f -</span><br></pre></td></tr></table></figure>
<p>自动注入（给命名空间打指定标签，启用自动注入）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label namespace default istio-injection=enabled</span><br><span class="line">kubectl get ns --show-labels </span><br><span class="line">kubectl apply -f httpbin-gateway.yaml</span><br></pre></td></tr></table></figure>
<p>IngressGateway NodePort访问地址：<a href="http://192.168.0.11:32615/">http://192.168.0.11:32615/</a></p>
<p><img src="/images/E0D362E4B99243DB809D6E9151AB8E8Aclipboard.png" alt></p>
<p><img src="/images/85AAA642A7A041AF94483F9570F5528Bclipboard.png" alt></p>
<h2 id="Istio与K8s集成流程">Istio与K8s集成流程</h2>
<p><img src="/images/969A593798B846F5957B37EFB3D3260Dclipboard.png" alt></p>
<h2 id="服务网关：Gateway">服务网关：Gateway</h2>
<p><img src="/images/39B39E61B5E448E78E446992BBA91D02clipboard.png" alt></p>
<p>Gateway为网格内服务提供负载均衡器，提供以下功能：</p>
<ul>
<li>
<p>L4-L7的负载均衡</p>
</li>
<li>
<p>对外的mTLS</p>
</li>
</ul>
<p>Gateway根据流入流出方向分为：</p>
<ul>
<li>
<p>IngressGateway：接收外部访问，并将流量转发到网格内的服务。</p>
</li>
<li>
<p>EgressGateway：网格内服务访问外部应用。</p>
</li>
</ul>
<p>在实际部署中，K8s集群一般部署在内网，为了将暴露到互联 网，会在前面加一层负载均衡器，用于流量入口，将用户访问 的域名传递给IngressGateway，IngressGateway再转发到不 同应用。</p>
<p><img src="/images/EB6991F8CF47469283BDA4DE19031C16clipboard.png" alt></p>
<p>学习：</p>
<p><a href="https://www.it610.com/article/1292898160674414592.htm">https://www.it610.com/article/1292898160674414592.htm</a></p>
<p><a href="https://blog.csdn.net/lswzw/article/details/104745617/">https://blog.csdn.net/lswzw/article/details/104745617/</a></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务治理istio初探下</title>
    <url>/2024/01/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86istio%E5%88%9D%E6%8E%A2%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="Istio-流量管理核心资源">Istio 流量管理核心资源</h2>
<p>核心资源：</p>
<ul>
<li>
<p>VirtualService（虚拟服务）</p>
</li>
<li>
<p>DestinationRule（目标规则）</p>
</li>
<li>
<p>Gateway（网关）</p>
</li>
<li>
<p>ServiceEntry（服务入口）</p>
</li>
</ul>
<h2 id="VirtualService">VirtualService</h2>
<p>VirtualService（虚拟服务）：</p>
<ul>
<li>
<p>定义路由规则</p>
</li>
<li>
<p>描述满足条件的请求去哪里</p>
</li>
</ul>
<p><img src="/images/3985D1EC0AD44499924A416B5CAF5E4Fclipboard.png" alt></p>
<p><img src="/images/24B29DE7AB414C75BB2C8025DC474071clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get vs <span class="comment"># 查看已创建的虚拟服务</span></span><br></pre></td></tr></table></figure>
<h2 id="DestinationRule">DestinationRule</h2>
<p>DestinationRule（目标规则）：定义虚拟服务路由目标地址的 真实地址，即子集（subset），支持多种负载均衡策略：</p>
<ul>
<li>
<p>随机</p>
</li>
<li>
<p>权重</p>
</li>
<li>
<p>最小请求数</p>
</li>
</ul>
<p><img src="/images/338D88EB1A1D4B22A61C94DC6721A74Bclipboard.png" alt></p>
<h2 id="Gateway">Gateway</h2>
<p>Gateway（网关）：为网格内服务对外访问入口，管理进出网格的流量，根据流入流出方向分为：</p>
<ul>
<li>
<p>IngressGateway：接收外部访问，并将流量转发到网格内的服务。</p>
</li>
<li>
<p>EgressGateway：网格内服务访问外部应用。</p>
</li>
</ul>
<p><img src="/images/22624576E1B44322A5343B271D3F52D6clipboard.png" alt></p>
<p>Gateway（网关）与Kubernetes Ingress有什么区别？</p>
<p>Kubernetes Ingress与Getaway都是用于为集群内服务提供访问入口， 但Ingress主要功能比较单一，不易于Istio现有流量管理功能集成。</p>
<p>目前Gateway支持的功能：</p>
<ul>
<li>
<p>支持L4-L7的负载均衡</p>
</li>
<li>
<p>支持HTTPS和mTLS</p>
</li>
<li>
<p>支持流量镜像、熔断等</p>
</li>
</ul>
<p><img src="/images/3E61532C0C1F4DECBF56AD070367167Fclipboard.png" alt></p>
<p><img src="/images/0918E22244E14EECBE6CA3F81F8D8814clipboard.png" alt></p>
<p><img src="/images/29A976A68E5E4904BD7CC7889F7F28CAclipboard.png" alt></p>
<h2 id="ServiceEntry">ServiceEntry</h2>
<p>ServiceEntry（服务入口）：将网格外部服务添加到网格内， 像网格内其他服务一样管理。</p>
<p><img src="/images/9165DAC827F2412FA08DA86174EDA13Fclipboard.png" alt></p>
<h2 id="Istio-流量管理案例（主流发布方案介绍，灰度发布，流量镜像）">Istio 流量管理案例（主流发布方案介绍，灰度发布，流量镜像）</h2>
<h3 id="主流发布方案介绍">主流发布方案介绍</h3>
<p>主流发布方案：</p>
<ul>
<li>
<p>蓝绿发布</p>
</li>
<li>
<p>滚动发布</p>
</li>
<li>
<p>灰度发布（金丝雀发布）</p>
</li>
<li>
<p>A/B Test</p>
</li>
</ul>
<p>蓝绿发布</p>
<p>项目逻辑上分为AB组，在项目升级时，首先把A组从负载均衡 中摘除，进行新版本的部署。B组仍然继续提供服务。A组升级 完成上线，B组从负载均衡中摘除。</p>
<p>特点：</p>
<ul>
<li>
<p>策略简单</p>
</li>
<li>
<p>升级/回滚速度快</p>
</li>
<li>
<p>用户无感知，平滑过渡</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>
<p>需要两倍以上服务器资源</p>
</li>
<li>
<p>短时间内浪费一定资源成本</p>
</li>
<li>
<p>有问题影响范围大</p>
</li>
</ul>
<p><img src="/images/4320B5549A7C4DB8A4F9444D5665E972clipboard.png" alt></p>
<p>滚动发布</p>
<p>每次只升级一个或多个服务，升级完成后加入生产环境， 不断执行这个过程，直到集群中的全部旧版升级新版本。 Kubernetes的默认发布策略。</p>
<p>特点：</p>
<ul>
<li>用户无感知，平滑过渡</li>
</ul>
<p>缺点：</p>
<ul>
<li>
<p>部署周期长</p>
</li>
<li>
<p>发布策略较复杂</p>
</li>
<li>
<p>不易回滚</p>
</li>
<li>
<p>有影响范围较大</p>
</li>
</ul>
<p><img src="/images/9F0A5D41A3584A00BD43485570FB2121clipboard.png" alt></p>
<p>灰度发布（金丝雀发布）</p>
<p>只升级部分服务，即让一部分用户继续用老版本，一部分用户 开始用新版本，如果用户对新版本没有什么意见，那么逐步扩 大范围，把所有用户都迁移到新版本上面来。</p>
<p>特点：</p>
<ul>
<li>
<p>保证整体系统稳定性</p>
</li>
<li>
<p>用户无感知，平滑过渡</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>自动化要求高</li>
</ul>
<p><img src="/images/A1AA8F206D844340A64D9467AB5605A0clipboard.png" alt></p>
<h3 id="灰度发布">灰度发布</h3>
<p>A/B Test</p>
<p>灰度发布的一种方式，主要对特定用户采样后，对收集到的反 馈数据做相关对比，然后根据比对结果作出决策。用来测试应 用功能表现的方法，侧重应用的可用性，受欢迎程度等，最后 决定是否升级。</p>
<p><img src="/images/851466FB5D89403D93CFB6BF8E5A8731clipboard.png" alt></p>
<h4 id="灰度发布：部署Bookinfo微服务项目">灰度发布：部署Bookinfo微服务项目</h4>
<p>Bookinfo 是官方提供一个图书评测系统微服务项目示例，</p>
<p>分为四个微服务：</p>
<p><img src="/images/CEDE7A347482448B8222D62B9C714972clipboard.png" alt></p>
<p><img src="/images/E4CCFEAA3F414E2591535D118549476Dclipboard.png" alt></p>
<p>1、创建命名空间并开启自动注入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create ns bookinfo</span><br><span class="line">kubectl label namespace bookinfo istio-injection=enabled</span><br></pre></td></tr></table></figure>
<p>2、部署应用YAML</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> istio-1.8.2/samples/bookinfo</span><br><span class="line">kubectl apply -f platform/kube/bookinfo.yaml -n bookinfo</span><br><span class="line">kubectl get pod -n bookinfo</span><br></pre></td></tr></table></figure>
<p>3、创建Ingress网关</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f networking/bookinfo-gateway.yaml -n bookinfo</span><br></pre></td></tr></table></figure>
<p>4、确认网关和访问地址，访问应用页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod,svc -n istio-system </span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://192.168.1.11:31265/productpage">http://192.168.1.11:31265/productpage</a></p>
<p><img src="/images/328BD108F2504AB8AA40387642BAF9A0clipboard.png" alt></p>
<p>reviews 微服务部署 3 个版本，用于测试灰度发布效果：</p>
<ul>
<li>
<p>v1 版本不会调用 ratings 服务</p>
</li>
<li>
<p>v2 版本会调用 ratings 服务，并使用 5个黑色五角星来显示评分信息</p>
</li>
<li>
<p>v3 版本会调用 ratings 服务，并使用5个红色五角星 来显示评分信息</p>
</li>
</ul>
<h4 id="灰度发布：基于权重的路由">灰度发布：基于权重的路由</h4>
<p><img src="/images/1471C2B6984044A4A2CBCA760E505E1Aclipboard.png" alt></p>
<p>任务：</p>
<ol>
<li>
<p>流量全部发送到reviews v1版本（不带五角星）</p>
</li>
<li>
<p>将90%的流量发送到reviews v1版本，另外10%的流量发送到reviews v2版本（5个黑色五角星）， 最后完全切换到v2版本</p>
</li>
<li>
<p>将50%的流量发送到v2版本，另外50%的流量发送到v3版本（5个红色五角星）</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f networking/virtual-service-all-v1.yaml -n bookinfo</span><br><span class="line">kubectl apply -f networking/destination-rule-all.yaml -n bookinfo</span><br><span class="line">kubectl apply -f networking/virtual-service-reviews-90-10.yaml -n bookinfo</span><br><span class="line">kubectl apply -f networking/virtual-service-reviews-v2-v3.yaml -n bookinfo</span><br></pre></td></tr></table></figure>
<h4 id="灰度发布：基于请求内容的路由">灰度发布：基于请求内容的路由</h4>
<p><img src="/images/E85755EF9FC14456ADDB3EED6C60BECFclipboard.png" alt></p>
<p>任务：将特定用户的请求发送到reviews v2版本（5个黑色五角星），其他用户则不受影响（v3）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f networking/virtual-service-reviews-jason-v2-v3.yaml -n bookinfo</span><br></pre></td></tr></table></figure>
<h4 id="灰度发布：工作流程">灰度发布：工作流程</h4>
<p><img src="/images/F236CE642CBE4A1381B423D30217641Fclipboard.png" alt></p>
<p>1.将部署应用的deployment里pod标签增加一个&quot;version :v1&quot;</p>
<p>2.部署deployment接入istio</p>
<p>3.目标规则关联服务版本标签</p>
<p>4.虚拟服务实现灰度发布</p>
<h3 id="流量镜像">流量镜像</h3>
<p>流量镜像：将请求复制一份，并根据策略来处理这个请求，不会影响真实请求。</p>
<p>应用场景：</p>
<ul>
<li>
<p>线上问题排查</p>
</li>
<li>
<p>用真实的流量验证应用功能是否正常</p>
</li>
<li>
<p>对镜像环境压力测试</p>
</li>
<li>
<p>收集真实流量数据进行分析</p>
</li>
<li></li>
</ul>
<p>验证模拟测试：（访问nginx-v1版本的流量复制到nginx-v2版本）</p>
<p><a href="/attachments/8794669FE2E04A64A668905476955E7Fazhe.zip">azhe.zip</a></p>
<p><img src="/images/4DD72B0F055D4DB4965DF0F30E44986Aclipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label namespaces default istio-injection=enabled</span><br><span class="line"><span class="built_in">cd</span> azhe/</span><br><span class="line">kubectl apply -f .</span><br><span class="line">kubectl logs nginx-v1-7fcbd8f56f-s9s4m -c nginx  -f</span><br><span class="line">kubectl logs  nginx-v2-596b8cbb66-lcnnc -c nginx -f </span><br><span class="line">kubectl get svc -n istio-system </span><br></pre></td></tr></table></figure>
<p>访问页面验证，访问nginx-v1版本的流量复制到nginx-v2版本</p>
<p>nodeport暴露的端口：<a href="http://192.168.0.12:31994/">http://192.168.0.12:31994/</a></p>
<h2 id="将应用暴露到互联网">将应用暴露到互联网</h2>
<p>在实际部署中，K8s集群一般部署在内网，为了将暴露到互联 网，会在前面加一层负载均衡器（公有云LB产品、Nginx、 LVS等），用于流量入口，将用户访问的域名传递给 IngressGateway，IngressGateway再转发到不同应用。</p>
<p><img src="/images/B14BFF55B56245619CE3945DC864BFC2clipboard.png" alt></p>
<p>1.安装nginx并配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    ....</span><br><span class="line">location / &#123;</span><br><span class="line">         proxy_http_version 1.1; <span class="comment">#必须指定不然会出现422，默认只支持1.1，upstream默认支持1.0</span></span><br><span class="line">         proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">         proxy_pass http://192.168.0.11:31994;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>2.在Gateway和VirtualService添加接收流量入口的域名</p>
<p><img src="/images/FA8B624FF34C4A568996E2B2CED399C1clipboard.png" alt></p>
<p>3.宿主机绑定nginx负载均衡ip关联的hosts解析，<a href="http://xn--nginx-408hr55ozm5bnft.ctnrs.com">然后访问nginx.ctnrs.com</a></p>
<h2 id="可视化监控">可视化监控</h2>
<p>Istio集成了多维度监控系统：</p>
<ul>
<li>
<p>使用Kiali观测应用</p>
</li>
<li>
<p>使用Prometheus+Grafana查看系统状态</p>
</li>
<li>
<p>使用Jaeger进行链路追踪</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f samples/addons/prometheus.yaml -n istio-system</span><br><span class="line">kubectl apply -f samples/addons/grafana.yaml -n istio-system</span><br><span class="line">kubectl apply -f samples/addons/jaeger.yaml -n istio-system</span><br><span class="line">kubectl apply -f samples/addons/kiali.yaml -n istio-system</span><br></pre></td></tr></table></figure>
<p>注：service默认使用ClusterIP，浏览器访问需要改成NodePort后再apply</p>
<h2 id="使用Kiali观测应用">使用Kiali观测应用</h2>
<p>Kiali是一款Isito服务网格可视化工具，提供以下功能：</p>
<ul>
<li>
<p>Istio 的可观察性控制台</p>
</li>
<li>
<p>通过服务拓扑帮助你理解服务网格的结构</p>
</li>
<li>
<p>提供网格的健康状态视图</p>
</li>
<li>
<p>具有服务网格配置功能</p>
</li>
</ul>
<p><img src="/images/2184D9031775451C98121A0C77B15479clipboard.png" alt></p>
<h2 id="使用Prometheus-Grafana查看系统状态">使用Prometheus+Grafana查看系统状态</h2>
<p>Prometheus用于收集Isito指标，通过Grafana可视化展示。</p>
<p>仪表盘：</p>
<ul>
<li>
<p>Istio Control Plane Dashboard：控制面板仪表盘</p>
</li>
<li>
<p>Istio Mesh Dashboard：网格仪表盘，查看应用（服务）数据</p>
</li>
<li>
<p>Istio Performance Dashboard：查看Istio 自身（各组件）数据</p>
</li>
<li>
<p>Istio Service Dashboard：服务仪表盘</p>
</li>
<li>
<p>Istio Workload Dashboard：工作负载仪表盘</p>
</li>
<li>
<p>Istio Wasm Extension Dashboard</p>
</li>
</ul>
<p><img src="/images/F21B64A414A24EABA49FD57FCC5DC342clipboard.png" alt></p>
<h2 id="使用Jaeger进行链路追踪">使用Jaeger进行链路追踪</h2>
<p>Jaeger是Uber开源的分布式追踪系统，用于微服务的监控 和全链路追踪。</p>
<p><img src="/images/86CF0CD21B4B4236BDB44435A7918C82clipboard.png" alt></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务部署</title>
    <url>/2021/10/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p><img src="/images/FFAA9D94DE594B9284FF61D8DA22A7A5clipboard.png" alt></p>
<p>项目架构原理：</p>
<p>用户使用手机端或电脑端访问前端程序，前端程序来调用服务端的服务接口，前端一般是在客户端完成的，处理数据，渲染数据，服务端提供一个统一的接口（负载均衡提供的统一接口）供前端去调用，接下来到网关，网关不是网络的网关，它是一个反向的路由，例如使用nginx做反向代理网关，那么nginx（API接口）作用是为后端微服务提供一个统一的入口，来实现不同的功能，不单是路由功能，还有安全认证，限流，负载均衡等功能，那么请求来到网关会帮你转发到后端的微服务，它帮你转发的时候，会去请求注册中心（集中管理每个微服务实例IP）里面的微服务，这个微服务下有哪些实例IP，拿到之后根据自己的调度算法帮你转发到其中的一个微服务实例IP，然后微服务都会调用后端的数据库（数据库，分布式存储），存储用户的相关信息。配置中心呢，是集中管理每个微服务相关的配置文件。</p>
<p>为什么要用注册中心呢？（主流注册中心：eureka, consul, nacos)</p>
<p>1.集中帮你记录每个微服务对应的多副本实例IP，像每个微服务都有很多实例IP</p>
<p>2.实现对每个微服务对应的多副本实例IP负载均衡</p>
<p>3.保证对每个微服务对应的多副本实例IP的一个可用性，通过基本的健康检查功能实现</p>
<hr>
<p><img src="/images/015006CBA41445AA979641DBA56359C0clipboard.png" alt></p>
<p>eureka服务内部的一个调用：</p>
<p>每个微服务实例启动之后都会注册到注册中心，首先，一个用户浏览一个商品，加入了购物车，准备支付，那么支付服务请求去eureka服务端查询这个微服务对应哪些实例IP，然后将请求转发其中的一个实例IP上提供服务。</p>
<hr>
<p><img src="/images/52F209AB20FD4F2BB0C3BBB8166A4D16clipboard.png" alt></p>
<table>
<thead>
<tr>
<th>服务器IP</th>
<th>端口</th>
<th>服务</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.0.11<br>    192.168.0.12<br>    192.168.0.13</td>
<td>8888</td>
<td>eureka</td>
<td>注册中心</td>
</tr>
<tr>
<td>192.168.0.11</td>
<td>3306<br>---------------------------------<br>           80</td>
<td>mariadb<br>---------------------------------<br>          nginx</td>
<td>数据库<br>---------------------------------<br>        负载均衡器</td>
</tr>
<tr>
<td>192.168.0.12<br>    192.168.0.13</td>
<td>8010<br>---------------------------------<br>          8020<br>---------------------------------<br>          8030<br>---------------------------------<br>          8080<br>---------------------------------<br>          9999</td>
<td>product<br>---------------------------------<br>          order<br>---------------------------------<br>          stock<br>---------------------------------<br>          portal<br>---------------------------------<br>          gateway</td>
<td>商品服务<br>---------------------------------<br>        订单服务<br>---------------------------------<br>        库存服务<br>---------------------------------<br>          前端<br>---------------------------------<br>          网关</td>
</tr>
</tbody>
</table>
<pre><code>                                                项目环境信息表
</code></pre>
<hr>
<p>192.168.0.11</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.部署jdk maven环境</span><br><span class="line">2.拷贝源码包到服务器上解压</span><br><span class="line">3.修改源码相关的配置文件以及相关连接数据库的地址用户名密码</span><br><span class="line">添加eureka注册地址</span><br><span class="line">http://192.168.0.11:8888/eureka/,http://192.168.0.12:8888/eureka/,http://192.168.0.13:8888/eureka/</span><br><span class="line">4.配置eureka集群,修改配置文件打成jar包，添加工作目录<span class="built_in">mkdir</span> /data/ms/eureka -p ，将jar移动到工作目录，</span><br><span class="line">生成systemd service 配置文件，并启动服务，然后将jar包推送到另两台服务器</span><br><span class="line">mvn clean package -Dmaven.test.skip</span><br><span class="line"><span class="comment">#生成systemd service 配置文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /usr/lib/systemd/system/eureka.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Eureka</span></span><br><span class="line"><span class="string">Documentation=eureka</span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">ExecStart=/usr/local/jdk/bin/java -jar /data/ms/eureka/eureka-service.jar</span></span><br><span class="line"><span class="string">ExecReload=/bin/kill -HUP $MAINPID</span></span><br><span class="line"><span class="string">KillMode=process</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否启动相关的服务</span></span><br><span class="line">jps -l</span><br><span class="line">5.批量拷贝文件(eureka jar包)</span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> 192.168.0.12 192.168.0.13;<span class="keyword">do</span></span><br><span class="line">	scp eureka-service/target/eureka-service.jar root@<span class="variable">$ip</span>:/data/ms/eureka</span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line">批量拷贝文件(product order stock jar包）</span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> 192.168.0.12 192.168.0.13;<span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> name <span class="keyword">in</span> product order stock ;<span class="keyword">do</span></span><br><span class="line">		scp <span class="variable">$name</span>-service/<span class="variable">$name</span>-service-biz/target/<span class="variable">$name</span>-service-biz.jar root@<span class="variable">$ip</span>:/data/ms/<span class="variable">$name</span></span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">批量拷贝文件(portal gateway jar包）</span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> 192.168.0.12 192.168.0.13;<span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> name <span class="keyword">in</span> portal gateway;<span class="keyword">do</span></span><br><span class="line">	scp <span class="variable">$name</span>-service/target/<span class="variable">$name</span>-service.jar  root@<span class="variable">$ip</span>:/data/ms/<span class="variable">$name</span></span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">6.安装Mariadb数据库：</span><br><span class="line">yum install mariadb-server</span><br><span class="line">systemctl start mariadb</span><br><span class="line">systemctl <span class="built_in">enable</span> mariadb</span><br><span class="line">mysqladmin -uroot password <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">创建一个账号并授权，该账户用于微服务连接：</span><br><span class="line">grant all on *.* to <span class="string">&#x27;ms&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">将源代码目录里sql文件拷贝到数据库服务器并导入：</span><br><span class="line">mysql -uroot –p</span><br><span class="line"></span><br><span class="line">mysql&gt; create database tb_stock;</span><br><span class="line">mysql&gt; use tb_stock;</span><br><span class="line">mysql&gt; <span class="built_in">source</span> /root/simple-microservice/db/stock.sql</span><br><span class="line"></span><br><span class="line">mysql&gt; create database tb_product;</span><br><span class="line">mysql&gt; use tb_product;</span><br><span class="line">mysql&gt; <span class="built_in">source</span> /root/simple-microservice/db/product.sql</span><br><span class="line"></span><br><span class="line">mysql&gt; create database tb_order;</span><br><span class="line">mysql&gt; use tb_order;</span><br><span class="line">mysql&gt; <span class="built_in">source</span> /root/simple-microservice/db/order.sql</span><br><span class="line"></span><br><span class="line">7.安装nginx</span><br><span class="line">[root@localhost yum.repos.d]<span class="comment"># cat nginx.repo </span></span><br><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/7/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">修改配置nginx虚拟目录文件</span><br><span class="line">[root@localhost ~]<span class="comment"># cat  /etc/nginx/conf.d/default.conf </span></span><br><span class="line">upstream gateway &#123;</span><br><span class="line">server 192.168.0.12:9999;</span><br><span class="line">server 192.168.0.13:9999;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name gateway.ctnrs.com;</span><br><span class="line">access_log /var/log/nginx/gateway-access.log main;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://gateway;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">upstream portal &#123;</span><br><span class="line">server 192.168.0.12:8080;</span><br><span class="line">server 192.168.0.13:8080;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name portal.ctnrs.com;</span><br><span class="line">access_log /var/log/nginx/portal-access.log main;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://portal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">重启nginx服务，对外访问</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>192.168.0.12  192.168.0.13</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.部署jdk环境</span><br><span class="line">2.创建工作目录</span><br><span class="line"><span class="built_in">mkdir</span> /data/ms/&#123;product,order,stock,eureka,gateway,portal&#125; -p</span><br><span class="line">3.批量生成systemd service 配置文件(gateway portal eureka)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> eureka gateway portal ;<span class="keyword">do</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /usr/lib/systemd/system/<span class="variable">$name</span>.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=$name</span></span><br><span class="line"><span class="string">Documentation=$name</span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">ExecStart=/usr/local/jdk/bin/java -jar /data/ms/$name/$name-service.jar</span></span><br><span class="line"><span class="string">ExecReload=/bin/kill -HUP $MAINPID</span></span><br><span class="line"><span class="string">KillMode=process</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">批量生成systemd service 配置文件(product order stock)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> product order stock;<span class="keyword">do</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /usr/lib/systemd/system/<span class="variable">$name</span>.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=$name</span></span><br><span class="line"><span class="string">Documentation=$name</span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">ExecStart=/usr/local/jdk/bin/java -jar /data/ms/$name/$name-service-biz.jar</span></span><br><span class="line"><span class="string">ExecReload=/bin/kill -HUP $MAINPID</span></span><br><span class="line"><span class="string">KillMode=process</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">4.批量启动服务并加入开机自启(product order stock gateway portal eureka)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> eureka product order stock gateway portal;<span class="keyword">do</span></span><br><span class="line">	systemctl start <span class="variable">$name</span></span><br><span class="line">	systemctl <span class="built_in">enable</span> <span class="variable">$name</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">5.查看是否启动相关的服务</span><br><span class="line">jps -l</span><br></pre></td></tr></table></figure>
<p>如果遇到访问nginx报错502，可能是selinux权限问题。</p>
<p>setenforce 0</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>快速部署一个K8s集群</title>
    <url>/2022/06/11/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AAk8s%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="生产环境部署K8s的2种方式">生产环境部署K8s的2种方式</h2>
<h3 id="kubeadm">kubeadm</h3>
<p>Kubeadm是一个工具，提供kubeadm init和kubeadm join，用于快速部署Kubernetes集群。</p>
<p>部署地址：<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></p>
<h3 id="二进制">二进制</h3>
<p>推荐，从官方下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</p>
<p>下载地址：<a href="https://github.com/kubernetes/kubernetes/releases">https://github.com/kubernetes/kubernetes/releases</a></p>
<h2 id="服务器硬件配置推荐">服务器硬件配置推荐</h2>
<p><img src="/images/2AB14DBE37A14CEB9A1838BE07C1D5F5clipboard.png" alt></p>
<h2 id="使用kubeadm快速部署一个K8s集群">使用kubeadm快速部署一个K8s集群</h2>
<table>
<thead>
<tr>
<th>192.168.0.11/24</th>
<th>192.168.0.12/24</th>
<th>192.168.0.13/24</th>
</tr>
</thead>
<tbody>
<tr>
<td>k8s-master</td>
<td>k8s-node1</td>
<td>k8s-node2</td>
</tr>
</tbody>
</table>
<p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。</p>
<p>这个工具能通过两条指令完成一个kubernetes集群的部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Master 节点</span></span><br><span class="line">$ kubeadm init</span><br><span class="line"><span class="comment"># 将一个 Node 节点加入到当前集群中</span></span><br><span class="line">$ kubeadm <span class="built_in">join</span> &lt;Master节点的IP和端口 &gt;</span><br></pre></td></tr></table></figure>
<p>master：kube-apiserver、scheduler、controller-manager、etcd</p>
<p>node：kubelet（非容器化）、kube-proxy</p>
<p>kubeadm不单纯是简化部署k8s集群，采用了容器化方式部署k8s组件。</p>
<h3 id="1-安装要求">1. 安装要求</h3>
<p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件：</p>
<ul>
<li>
<p>一台或多台机器，操作系统 CentOS7.x-86_x64</p>
</li>
<li>
<p>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多</p>
</li>
<li>
<p>集群中所有机器之间网络互通</p>
</li>
<li>
<p>可以访问外网，需要拉取镜像</p>
</li>
<li>
<p>禁止swap分区</p>
</li>
</ul>
<h3 id="2-准备环境">2. 准备环境</h3>
<h4 id="关闭防火墙：">关闭防火墙：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>
<h4 id="关闭selinux：">关闭selinux：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  <span class="comment"># 永久</span></span><br><span class="line">$ setenforce 0  <span class="comment"># 临时</span></span><br></pre></td></tr></table></figure>
<h4 id="关闭swap：">关闭swap：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swapoff -a  <span class="comment"># 临时</span></span><br><span class="line">$ vim /etc/fstab  <span class="comment"># 永久</span></span><br></pre></td></tr></table></figure>
<h4 id="设置主机名：">设置主机名：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hostnamectl set-hostname &lt;hostname&gt;</span><br></pre></td></tr></table></figure>
<h4 id="在master添加hosts：">在master添加hosts：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">192.168.0.11 k8s-master</span></span><br><span class="line"><span class="string">192.168.0.12 k8s-node1</span></span><br><span class="line"><span class="string">192.168.0.13 k8s-node2</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h4 id="将桥接的IPv4流量传递到iptables的链：">将桥接的IPv4流量传递到iptables的链：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">$ sysctl --system  <span class="comment"># 生效</span></span><br></pre></td></tr></table></figure>
<h4 id="时间同步：">时间同步：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install ntpdate -y</span><br><span class="line">$ ntpdate time.windows.com</span><br></pre></td></tr></table></figure>
<h3 id="3-安装Docker-kubeadm-kubelet【所有节点】">3. 安装Docker/kubeadm/kubelet【所有节点】</h3>
<p>Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker。</p>
<h4 id="3-1-安装Docker">3.1 安装Docker</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">$ yum -y install docker-ce</span><br><span class="line">$ systemctl <span class="built_in">enable</span> docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure>
<p>配置镜像下载加速器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">$ systemctl restart docker</span><br><span class="line">$ docker info</span><br></pre></td></tr></table></figure>
<h4 id="3-2-添加阿里云YUM软件源">3.2 添加阿里云YUM软件源</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-安装kubeadm，kubelet和kubectl">3.3 安装kubeadm，kubelet和kubectl</h4>
<p>由于版本更新频繁，这里指定版本号部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install -y kubelet-1.19.0 kubeadm-1.19.0 kubectl-1.19.0</span><br><span class="line">$ systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure>
<h3 id="4-部署Kubernetes-Master">4. 部署Kubernetes Master</h3>
<p><a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file">https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file</a></p>
<p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#initializing-your-control-plane-node">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#initializing-your-control-plane-node</a></p>
<p>在192.168.0.11（Master）执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubeadm init \	</span><br><span class="line">  --apiserver-advertise-address=192.168.0.11 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.19.0 \</span><br><span class="line">  --service-cidr=10.96.0.0/12 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">  --ignore-preflight-errors=all</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>–apiserver-advertise-address 集群通告地址</p>
</li>
<li>
<p>–image-repository  由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址</p>
</li>
<li>
<p>–kubernetes-version K8s版本，与上面安装的一致</p>
</li>
<li>
<p>–service-cidr 集群内部虚拟网络，Pod统一访问入口</p>
</li>
<li>
<p>–pod-network-cidr Pod网络，，与下面部署的CNI网络组件yaml中保持一致</p>
</li>
</ul>
<p>kubeadm init初始化工作：</p>
<p>1、[preflight] 环境检查和拉取镜像 kubeadm config /images pull</p>
<p>2、[certs] 生成k8s证书和etcd证书 /etc/kubernetes/pki</p>
<p>3、[kubeconfig] 生成kubeconfig文件</p>
<p>4、[kubelet-start] 生成kubelet配置文件</p>
<p>5、[control-plane] 部署管理节点组件，用镜像启动容器  kubectl get pods -n kube-system</p>
<p>6、[etcd] 部署etcd数据库，用镜像启动容器</p>
<p>7、[upload-config] [kubelet] [upload-certs] 上传配置文件到k8s中</p>
<p>8、[mark-control-plane] 给管理节点添加一个标签 <a href="http://node-role.kubernetes.io/master=">node-role.kubernetes.io/master=</a>‘’，再添加一个污点[<a href="http://node-role.kubernetes.io/master:NoSchedule">node-role.kubernetes.io/master:NoSchedule</a>]</p>
<p>9、[bootstrap-token] 自动为kubelet颁发证书</p>
<p>10、[addons] 部署插件，CoreDNS、kube-proxy</p>
<p>或者使用配置文件引导：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi kubeadm.conf</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.18.0</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers </span><br><span class="line">networking:</span><br><span class="line">  podSubnet: 10.244.0.0/16 </span><br><span class="line">  serviceSubnet: 10.96.0.0/12 </span><br><span class="line">  </span><br><span class="line">$ kubeadm init --config kubeadm.conf --ignore-preflight-errors=all  </span><br></pre></td></tr></table></figure>
<p>拷贝kubectl使用的连接k8s认证文件到默认路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">$ kubectl get nodes</span><br><span class="line">NAME         STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-master   Ready    master   2m   v1.18.0</span><br></pre></td></tr></table></figure>
<h3 id="5-加入Kubernetes-Node">5. 加入Kubernetes Node</h3>
<p>在192.168.0.11/12（Node）执行。</p>
<p>向集群添加新节点，执行在kubeadm init输出的kubeadm join命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 192.168.0.11:6443 --token dq52g0.m44tucwrwwyieklo \</span><br><span class="line">  --discovery-token-ca-cert-hash sha256:0f9df6b112b8bd2ca31c6ccfa777ab057158774bd68990e84393b50e0f181572 </span><br></pre></td></tr></table></figure>
<p>默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubeadm token create</span><br><span class="line">$ kubeadm token list</span><br><span class="line">$ openssl x509 -pubkey -<span class="keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span class="string">&#x27;s/^.* //&#x27;</span></span><br><span class="line">63bca849e0e01691ae14eab449570284f0c3ddeea590f8da988c07fe2729e924</span><br><span class="line"></span><br><span class="line">$ kubeadm <span class="built_in">join</span> 192.168.0.11:6443 --token nuja6n.o3jrhsffiqs9swnu --discovery-token-ca-cert-hash sha256:63bca849e0e01691ae14eab449570284f0c3ddeea590f8da988c07fe2729e924</span><br></pre></td></tr></table></figure>
<p>或者直接命令快捷生成：kubeadm token create --print-join-command</p>
<p><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/</a></p>
<h3 id="6-部署容器网络（CNI）">6. 部署容器网络（CNI）</h3>
<p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network</a></p>
<p>注意：只需要部署下面其中一个，推荐Calico。</p>
<p>Calico是一个纯三层的数据中心网络方案，Calico支持广泛的平台，包括Kubernetes、OpenStack等。</p>
<p>Calico 在每一个计算节点利用 Linux Kernel 实现了一个高效的虚拟路由器（ vRouter） 来负责数据转发，而每个 vRouter 通过 BGP 协议负责把自己上运行的 workload 的路由信息向整个 Calico 网络内传播。</p>
<p>此外，Calico  项目还实现了 Kubernetes 网络策略，提供ACL功能。</p>
<p><a href="https://docs.projectcalico.org/getting-started/kubernetes/quickstart">https://docs.projectcalico.org/getting-started/kubernetes/quickstart</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://docs.projectcalico.org/manifests/calico.yaml</span><br></pre></td></tr></table></figure>
<p>下载完后还需要修改里面定义Pod网络（CALICO_IPV4POOL_CIDR），与前面kubeadm init指定的一样</p>
<p>修改完后应用清单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f calico.yaml</span><br><span class="line">$ kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>
<h3 id="7-测试kubernetes集群">7. 测试kubernetes集群</h3>
<ul>
<li>
<p>验证Pod工作</p>
</li>
<li>
<p>验证Pod网络通信</p>
</li>
<li>
<p>验证DNS解析</p>
</li>
</ul>
<p>在Kubernetes集群中创建一个pod，验证是否正常运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create deployment nginx --image=nginx</span><br><span class="line">$ kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line">$ kubectl get pod,svc</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://NodeIP">http://NodeIP</a>:Port</p>
<h3 id="8-部署-Dashboard">8. 部署 Dashboard</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.3/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>
<p>默认Dashboard只能集群内部访问，修改Service为NodePort类型，暴露到外部：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi recommended.yaml</span><br><span class="line">...</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30001</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">...</span><br><span class="line">$ kubectl apply -f recommended.yaml</span><br><span class="line">$ kubectl get pods -n kubernetes-dashboard</span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">dashboard-metrics-scraper-6b4884c9d5-gl8nr   1/1     Running   0          13m</span><br><span class="line">kubernetes-dashboard-7f99b75bf4-89cds        1/1     Running   0          13m</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="https://NodeIP:30001">https://NodeIP:30001</a></p>
<p>创建service account并绑定默认cluster-admin管理员集群角色：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">$ kubectl create serviceaccount dashboard-admin -n kube-system</span><br><span class="line"><span class="comment"># 用户授权</span></span><br><span class="line">$ kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</span><br><span class="line"><span class="comment"># 获取用户Token</span></span><br><span class="line">$ kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk <span class="string">&#x27;/dashboard-admin/&#123;print $1&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用输出的token登录Dashboard。</p>
<p><img src="/images/268C8E2AC7224A1C8F6A0BC88B9B1A0Cclipboard.png" alt></p>
<h2 id="K8s-CNI网络模型">K8s CNI网络模型</h2>
<p><img src="/images/77DF44AB43FB4CA0BA6CEF859FCE5CF3clipboard.png" alt></p>
<p>K8s是一个扁平化网络。</p>
<p>即所有部署的网络组件都必须满足如下要求：</p>
<ul>
<li>
<p>一个Pod一个IP</p>
</li>
<li>
<p>所有的 Pod 可以与任何其他 Pod 直接通信</p>
</li>
<li>
<p>所有节点可以与所有 Pod 直接通信</p>
</li>
<li>
<p>Pod 内部获取到的 IP 地址与其他 Pod 或节点与其通信时的 IP 地址是同一个</p>
</li>
</ul>
<p>主流网络组件有：Flannel、Calico等</p>
<h2 id="查看集群状态">查看集群状态</h2>
<h4 id="查看master组件状态：">查看master组件状态：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get cs </span><br></pre></td></tr></table></figure>
<h4 id="查看node状态：">查看node状态：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure>
<h4 id="查看Apiserver代理的URL：">查看Apiserver代理的URL：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl cluster-info </span><br></pre></td></tr></table></figure>
<h4 id="查看集群详细信息：">查看集群详细信息：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl cluster-info dump </span><br></pre></td></tr></table></figure>
<h4 id="查看资源信息：">查看资源信息：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe &lt;资源&gt; &lt;名称&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>收集Java堆栈日志</title>
    <url>/2021/07/07/%E6%94%B6%E9%9B%86java%E5%A0%86%E6%A0%88%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>收集Java堆栈日志</p>
<p>一般应用记录的日志，每行表示一个事务，但有些日志是多行表示一个事务。</p>
<p>例如，常见的Java堆栈日志：</p>
<p>Exception in thread “main” java.lang.NullPointerException</p>
<pre><code>at com.example.myproject.Book.getTitle(Book.java:16)

at com.example.myproject.Author.getBookTitles(Author.java:25)

at com.example.myproject.Bootstrap.main(Bootstrap.java:14)
</code></pre>
<p>上面文档表示四行，在Kibana里也视为四个单独的文档，但实际这是一个异常日志，如果分开阅读会脱离上 下文关系，不利于分析。</p>
<p>因此，为了避免此问题，可以让filebeat启用多行处理，将这四行作为一个事件发送。</p>
<p>filebeat多行参数：</p>
<p>• multiline.pattern: ‘^\s’ 正则表达式，匹配行</p>
<p>• multiline.negate: false 否定正则匹配模式，正则取反效果。例如false时将匹配的 行合并到上一行，       true时将不匹配的行合并到上一行。默认false</p>
<p>• multiline.match: after 合并到上一行的末尾还是开头（before）</p>
<p>匹配空格开头的行放到不是空格开头的行的下面</p>
<p><img src="/images/A2998AE6189F4A2C969D0DA99DD2F6C1clipboard.png" alt></p>
<p>修改filebeat配置文件</p>
<p>vi /etc/filebeat/filebeat.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/test/product.log</span><br><span class="line">  tags: [<span class="string">&quot;nginx&quot;</span>]</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  fields:</span><br><span class="line">    project: microservice</span><br><span class="line">    app: product</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/test/gateway.log</span><br><span class="line">  tags: [<span class="string">&quot;nginx&quot;</span>]</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  fields:</span><br><span class="line">    project: microservice</span><br><span class="line">    app: gateway</span><br><span class="line">    </span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/nginx/access.log</span><br><span class="line">  tags: [<span class="string">&quot;nginx&quot;</span>]</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  fields:</span><br><span class="line">    project: microservice</span><br><span class="line">    app: nginx</span><br><span class="line">  multiline.pattern: <span class="string">&#x27;^\s&#x27;</span></span><br><span class="line">  multiline.negate: <span class="literal">false</span></span><br><span class="line">  multiline.match: after</span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">&quot;192.168.0.11:5044&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart filebeat</span><br></pre></td></tr></table></figure>
<p>模拟java日志数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat a</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">	at com.example.myproject.Book.getTitle(Book.java:16)</span><br><span class="line">	at com.example.myproject.Author.getBookTitles(Author.java:25)</span><br><span class="line">	at com.example.myproject.Bootstrap.main(Bootstrap.java:14)</span><br><span class="line">[root@localhost ~]<span class="comment"># cat a &gt;&gt; /var/log/nginx/access.log </span></span><br></pre></td></tr></table></figure>
<p>在kibana页面上查看</p>
<p><img src="/images/E04E937DA5154D34B624FF28C2C8C4DCclipboard.png" alt></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>收集Kubernetes日志</title>
    <url>/2021/07/10/%E6%94%B6%E9%9B%86kubernetes%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>收集Kubernetes日志</p>
<p>容器特性给日志采集带来的难度：</p>
<p>• K8s弹性伸缩性：导致不能预先确定采集的目标</p>
<p>• 容器隔离性：容器的文件系统与宿主机是隔离，导致 日志采集器读取日志文件受阻</p>
<p>应用程序日志记录体现方式分为两类：</p>
<p>• 标准输出：输出到控制台，使用kubectl logs可以看到</p>
<p>• 日志文件：写到容器的文件系统的文件</p>
<p><img src="/images/CEEF894073884B049205B655AF1D6B93clipboard.png" alt></p>
<p>针对标准输出：以DaemonSet方式在每个Node 上部署一个日志收集程序，采集 /var/lib/docker/containers/目录下所有容器日志。</p>
<p>docker容器本地日志文件：/var/lib/docker/containers/<em>/</em>-json.log</p>
<p>通过将/var/lib/docker/containers/<em>/</em>-json.log 挂载到日志采集器中（pod），这样就可以采集到所有容器的日志了。</p>
<p>kubectl log标准输出流程:</p>
<p>kubectl log -&gt; apiserver -&gt; kubelet -&gt;docker -&gt;*-json.log</p>
<p>kubectl log请求apiserver，apiserver访问kubelet, kubelet调用docker，docker读取的是*-json.log文件</p>
<p>k8s上部署nginx服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#去除kubeadm master污点</span></span><br><span class="line">kubectl describe node |grep Taint</span><br><span class="line">kubectl taint node k8s-master node-role.kubernetes.io/master-</span><br><span class="line">kubectl describe node |grep Taint</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署nginx服务</span></span><br><span class="line">kubectl create deployment web --image=nginx</span><br><span class="line">kubectl get pod -n kube-system</span><br><span class="line">kubectl describe pod web-5dcb957ccc-7w784 </span><br><span class="line">kubectl get pods -o wide</span><br><span class="line">curl 10.244.0.4</span><br><span class="line">kubectl logs web-5dcb957ccc-7w784 -f</span><br><span class="line">docker ps |grep web</span><br></pre></td></tr></table></figure>
<p>k8s上部署filebeat采集器 ：</p>
<p>vim filebeat-kubernetes.yaml</p>
<p>#修改推送到logstash的IP地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># cat filebeat-kubernetes.yaml </span></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: filebeat-config</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: filebeat</span><br><span class="line">data:</span><br><span class="line">  filebeat.yml: |-</span><br><span class="line">    filebeat.config:</span><br><span class="line">      inputs:</span><br><span class="line">        <span class="comment"># Mounted `filebeat-inputs` configmap:</span></span><br><span class="line">        path: <span class="variable">$&#123;path.config&#125;</span>/inputs.d/*.yml</span><br><span class="line">        <span class="comment"># Reload inputs configs as they change:</span></span><br><span class="line">        reload.enabled: <span class="literal">false</span></span><br><span class="line">      modules:</span><br><span class="line">        path: <span class="variable">$&#123;path.config&#125;</span>/modules.d/*.yml</span><br><span class="line">        <span class="comment"># Reload module configs as they change:</span></span><br><span class="line">        reload.enabled: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># To enable hints based autodiscover, remove `filebeat.config.inputs` configuration and uncomment this:</span></span><br><span class="line">    <span class="comment">#filebeat.autodiscover:</span></span><br><span class="line">    <span class="comment">#  providers:</span></span><br><span class="line">    <span class="comment">#    - type: kubernetes</span></span><br><span class="line">    <span class="comment">#      hints.enabled: true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#output.elasticsearch:</span></span><br><span class="line">    <span class="comment">#  hosts: [&#x27;$&#123;ELASTICSEARCH_HOST:elasticsearch&#125;:$&#123;ELASTICSEARCH_PORT:9200&#125;&#x27;]</span></span><br><span class="line">    output.logstash:</span><br><span class="line">      hosts: [<span class="string">&quot;192.168.0.11:5044&quot;</span>]</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: filebeat-inputs</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: filebeat</span><br><span class="line">data:</span><br><span class="line">  kubernetes.yml: |-</span><br><span class="line">    - <span class="built_in">type</span>: docker</span><br><span class="line">      containers.ids:</span><br><span class="line">      - <span class="string">&quot;*&quot;</span></span><br><span class="line">      processors:</span><br><span class="line">        - add_kubernetes_metadata:</span><br><span class="line">            in_cluster: <span class="literal">true</span></span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1 </span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: filebeat</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: filebeat</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: filebeat</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: filebeat</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccountName: filebeat</span><br><span class="line">      terminationGracePeriodSeconds: 30</span><br><span class="line">      containers:</span><br><span class="line">      - name: filebeat</span><br><span class="line">        image: elastic/filebeat:7.9.2</span><br><span class="line">        args: [</span><br><span class="line">          <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/etc/filebeat.yml&quot;</span>,</span><br><span class="line">          <span class="string">&quot;-e&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line">        <span class="built_in">env</span>:</span><br><span class="line">        - name: ELASTICSEARCH_HOST</span><br><span class="line">          value: elasticsearch</span><br><span class="line">        - name: ELASTICSEARCH_PORT</span><br><span class="line">          value: <span class="string">&quot;9200&quot;</span></span><br><span class="line">        securityContext:</span><br><span class="line">          runAsUser: 0</span><br><span class="line">          <span class="comment"># If using Red Hat OpenShift uncomment this:</span></span><br><span class="line">          <span class="comment">#privileged: true</span></span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            memory: 200Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 100Mi</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: config</span><br><span class="line">          mountPath: /etc/filebeat.yml</span><br><span class="line">          readOnly: <span class="literal">true</span></span><br><span class="line">          subPath: filebeat.yml</span><br><span class="line">        - name: inputs</span><br><span class="line">          mountPath: /usr/share/filebeat/inputs.d</span><br><span class="line">          readOnly: <span class="literal">true</span></span><br><span class="line">        - name: data</span><br><span class="line">          mountPath: /usr/share/filebeat/data</span><br><span class="line">        - name: varlibdockercontainers</span><br><span class="line">          mountPath: /var/lib/docker/containers</span><br><span class="line">          readOnly: <span class="literal">true</span></span><br><span class="line">      volumes:</span><br><span class="line">      - name: config</span><br><span class="line">        configMap:</span><br><span class="line">          defaultMode: 0600</span><br><span class="line">          name: filebeat-config</span><br><span class="line">      - name: varlibdockercontainers</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /var/lib/docker/containers</span><br><span class="line">      - name: inputs</span><br><span class="line">        configMap:</span><br><span class="line">          defaultMode: 0600</span><br><span class="line">          name: filebeat-inputs</span><br><span class="line">      <span class="comment"># data folder stores a registry of read status for all files, so we don&#x27;t send everything again on a Filebeat pod restart</span></span><br><span class="line">      - name: data</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /var/lib/filebeat-data</span><br><span class="line">          <span class="built_in">type</span>: DirectoryOrCreate</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: filebeat</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: filebeat</span><br><span class="line">  namespace: kube-system</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: filebeat</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: filebeat</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: filebeat</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [<span class="string">&quot;&quot;</span>] <span class="comment"># &quot;&quot; indicates the core API group</span></span><br><span class="line">  resources:</span><br><span class="line">  - namespaces</span><br><span class="line">  - pods</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">  - watch</span><br><span class="line">  - list</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: filebeat</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: filebeat</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f filebeat-kubernetes.yaml </span><br><span class="line">kubectl get pod -n kube-system</span><br></pre></td></tr></table></figure>
<p>访问nginx服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br><span class="line">curl 10.244.0.4 </span><br></pre></td></tr></table></figure>
<p>在kibana页面上查看</p>
<p><img src="/images/6BDF7A647FFF4C529D80470D1265F3A0clipboard.png" alt></p>
<p>从上面我们可以看出，filebeat采集到了k8s容器日志,比如这条日志属于哪个容器，哪个pod，哪个命名空间，哪个node节点等等日志来源，因为它内置了k8s容器相关的模块。</p>
<p><img src="/images/7329173106BE4F1392683D44B860F2D8clipboard.png" alt></p>
<p>针对容器中日志文件：在Pod中增加一个容器运行 日志采集器，使用emtyDir共享日志目录让日志采 集器读取到日志文件。</p>
<p>通过pod内部多个容器共享数据卷的形式采集到应用容器的日志。</p>
<p>k8s上部署nginx和filebeat容器</p>
<p>vim nginx-deployment.yaml</p>
<p>#修改推送到logstash的IP地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-log-demo</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      project: microservice</span><br><span class="line">      app: gateway</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        project: microservice</span><br><span class="line">        app: gateway</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      <span class="comment"># 应用容器</span></span><br><span class="line">      - name: nginx </span><br><span class="line">        image: lizhenliang/nginx-php</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">          protocol: TCP</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 0.5</span><br><span class="line">            memory: 256Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 1</span><br><span class="line">            memory: 1Gi</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /status.html</span><br><span class="line">            port: 80</span><br><span class="line">          initialDelaySeconds: 20</span><br><span class="line">          timeoutSeconds: 20</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /status.html</span><br><span class="line">            port: 80</span><br><span class="line">          initialDelaySeconds: 20</span><br><span class="line">          timeoutSeconds: 20</span><br><span class="line">        <span class="comment"># 将数据卷挂载到日志目录</span></span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: nginx-logs </span><br><span class="line">          mountPath: /usr/local/nginx/logs</span><br><span class="line">      <span class="comment"># 日志采集器容器</span></span><br><span class="line">      - name: filebeat</span><br><span class="line">        image: elastic/filebeat:7.9.2 </span><br><span class="line">        args: [</span><br><span class="line">          <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/etc/filebeat.yml&quot;</span>,</span><br><span class="line">          <span class="string">&quot;-e&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            memory: 500Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 100Mi</span><br><span class="line">        securityContext:</span><br><span class="line">          runAsUser: 0</span><br><span class="line">        volumeMounts:</span><br><span class="line">        <span class="comment"># 挂载filebeat配置文件</span></span><br><span class="line">        - name: filebeat-config</span><br><span class="line">          mountPath: /etc/filebeat.yml</span><br><span class="line">          subPath: filebeat.yml</span><br><span class="line">        <span class="comment"># 将数据卷挂载到日志目录</span></span><br><span class="line">        - name: nginx-logs </span><br><span class="line">          mountPath: /usr/local/nginx/logs</span><br><span class="line">      <span class="comment"># 数据卷共享日志目录</span></span><br><span class="line">      volumes:</span><br><span class="line">      - name: nginx-logs</span><br><span class="line">        emptyDir: &#123;&#125;</span><br><span class="line">      - name: filebeat-config</span><br><span class="line">        configMap:</span><br><span class="line">          name: filebeat-nginx-config</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: filebeat-nginx-config</span><br><span class="line">  namespace: default</span><br><span class="line">  </span><br><span class="line">data:</span><br><span class="line">  <span class="comment"># 配置文件保存在ConfigMap</span></span><br><span class="line">  filebeat.yml: |-</span><br><span class="line">    filebeat.inputs:</span><br><span class="line">      - <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">        paths:</span><br><span class="line">          - /usr/local/nginx/logs/access.log</span><br><span class="line">        <span class="comment"># tags: [&quot;access&quot;]</span></span><br><span class="line">        fields_under_root: <span class="literal">true</span></span><br><span class="line">        fields:</span><br><span class="line">          project: microservice</span><br><span class="line">          app: gateway</span><br><span class="line"></span><br><span class="line">    output.logstash:</span><br><span class="line">      hosts: [<span class="string">&quot;192.168.0.11:5044&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>将filebeat配置文件存放在configmap中，在创建容器时将configmap挂载到日志采集器容器中，filebeat就通过配置文件可以采集日志。

通过emptyDir数据卷将应用容器中的日志目录映射到宿主机上，又将宿主机上的日志目录映射到日志采集容器中，这样日志采集器就可以在本地采集日志了，就像你在宿主机上采集日志一样。
</code></pre>
<p>查看pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml </span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
<p>访问nginx服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br><span class="line">curl 10.244.0.8/status.html</span><br></pre></td></tr></table></figure>
<p>在kibana页面上查看</p>
<p><img src="/images/E604FBDD39F442468EF10E797048D6B2clipboard.png" alt></p>
<p>进入容器内部查看日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it nginx-log-demo-86b84c65b8-xwgsn -c nginx -- bash</span><br><span class="line"><span class="built_in">ls</span> /usr/local/nginx/logs/</span><br><span class="line">access.log  error.log</span><br><span class="line"></span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx-log-demo-86b84c65b8-xwgsn -c filebeat -- bash</span><br><span class="line"><span class="built_in">ls</span> /usr/local/nginx/logs/</span><br><span class="line">access.log  error.log</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>针对标准输出：在每个node上部署一个日志采集器（filebeat)，它采集宿主机上docker接管标准输出的日志目录，并且利用filebeat对docker,k8s这方面的处理器，对这个日志源打一定的标记。</p>
<p>针对容器中日志文件：在pod中增加一个容器运行日志采集器（filebeat),使用emptyDir数据卷去共享应用容器的日志目录，让filebeat容器能够读取到这个日志目录。</p>
<p>参考链接：</p>
<p><a href="https://www.cnblogs.com/jetpropelledsnake/p/10906335.html">https://www.cnblogs.com/jetpropelledsnake/p/10906335.html</a></p>
<p><a href="https://www.cnblogs.com/musen/p/13306395.html">https://www.cnblogs.com/musen/p/13306395.html</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>收集Nginx访问日志</title>
    <url>/2021/07/08/%E6%94%B6%E9%9B%86nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>收集Nginx访问日志</p>
<p>安装nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo </span><br><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/7/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install nginx</span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>
<p>filebeat配置</p>
<p>vim /etc/filebeat/filebeat.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/nginx/access.log</span><br><span class="line">  tags: [<span class="string">&quot;nginx&quot;</span>]</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  fields:</span><br><span class="line">    project: microservice</span><br><span class="line">    app: nginx</span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">&quot;192.168.0.11:5044&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart filebeat.service</span><br></pre></td></tr></table></figure>
<p>1.写Grok正则匹配nginx访问日志：</p>
<p>logstash配置</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">   host =&gt; <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">   port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">  match =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;%&#123;IPV4:remote_addr&#125; - (%&#123;USERNAME:remote_user&#125;|-) \[%&#123;HTTPDATE:time_local&#125;\] \&quot;%&#123;WORD:request_method&#125; %&#123;URIPATHPARAM:request_uri&#125; HTTP/%&#123;NUMBER:http_protocol&#125;\&quot; %&#123;NUMBER:http_status&#125; %&#123;NUMBER:body_bytes_sent&#125; \&quot;%&#123;GREEDYDATA:http_referer&#125;\&quot; \&quot;%&#123;GREEDYDATA:http_user_agent&#125;\&quot; \&quot;(%&#123;IPV4:http_x_forwarded_for&#125;|-)\&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [app] == <span class="string">&quot;product&quot;</span> and [project] == <span class="string">&quot;microservice&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;microservice-product-%&#123;+YYYY.MM&#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> [app] == <span class="string">&quot;gateway&quot;</span> and [project] == <span class="string">&quot;microservice&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;microservice-gateway-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> [app] == <span class="string">&quot;nginx&quot;</span> and [project] == <span class="string">&quot;microservice&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;microservice-nginx-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;unknown-%&#123;+YYYY&#125;&quot;</span></span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">  hosts =&gt; <span class="string">&quot;192.168.0.11:9200&quot;</span></span><br><span class="line">  index =&gt; <span class="string">&quot;%&#123;[@metadata][target_index]&#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>验证</p>
<p>访问nginx，查看kibana页面</p>
<p><img src="/images/A4AD1E51431C49809B31DC8FEF453BA7clipboard.png" alt></p>
<p><img src="/images/97C4F0A455C649B7A95DE40FD3945126clipboard.png" alt></p>
<p><img src="/images/B50654DE2C414607ACF09DF1AADAAE7Aclipboard.png" alt></p>
<p><img src="/images/F9735F980D884933A9D1D610E22742B2clipboard.png" alt></p>
<p><img src="/images/2DB682E024C840DEAB3F2E52365318BCclipboard.png" alt></p>
<p>2.将Nginx访问日志格式改为JSON收集：</p>
<p>修改nginx配置文件(Nginx访问日志格式改为JSON)</p>
<p>vim /etc/nginx/nginx.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">log_format json  <span class="string">&#x27;&#123; &quot;@timestamp&quot;: &quot;$time_iso8601&quot;, &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;remote_addr&quot;: &quot;$remote_addr&quot;, &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;remote_user&quot;: &quot;$remote_user&quot;, &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;body_bytes_sent&quot;: &quot;$body_bytes_sent&quot;, &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;request_time&quot;: &quot;$request_time&quot;, &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;status&quot;: &quot;$status&quot;, &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;request_uri&quot;: &quot;$request_uri&quot;, &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;request_method&quot;: &quot;$request_method&quot;, &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;http_referrer&quot;: &quot;$http_referer&quot;, &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;http_x_forwarded_for&quot;: &quot;$http_x_forwarded_for&quot;, &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;http_user_agent&quot;: &quot;$http_user_agent&quot;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">access_log  /var/log/nginx/access.log  json;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重新启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>
<p>查看访问日志</p>
<p><img src="/images/3E4E77C66C6F4A9696AE12CE7DE0021Aclipboard.png" alt></p>
<p>修改logstash配置文件(Logstash再使用JSON过滤插件解析)</p>
<p>vim /opt/elk/logstash/conf.d/test.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">   host =&gt; <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">   port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  json &#123;</span><br><span class="line">    <span class="built_in">source</span> =&gt; <span class="string">&quot;message&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [app] == <span class="string">&quot;product&quot;</span> and [project] == <span class="string">&quot;microservice&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;microservice-product-%&#123;+YYYY.MM&#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> [app] == <span class="string">&quot;gateway&quot;</span> and [project] == <span class="string">&quot;microservice&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;microservice-gateway-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> [app] == <span class="string">&quot;nginx&quot;</span> and [project] == <span class="string">&quot;microservice&quot;</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;microservice-nginx-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">  add_field =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;[@metadata][target_index]&quot;</span> =&gt; <span class="string">&quot;unknown-%&#123;+YYYY&#125;&quot;</span></span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">  hosts =&gt; <span class="string">&quot;192.168.0.11:9200&quot;</span></span><br><span class="line">  index =&gt; <span class="string">&quot;%&#123;[@metadata][target_index]&#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>热加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;logstash pid&gt;</span><br></pre></td></tr></table></figure>
<p>在kibana页面上查看</p>
<p><img src="/images/E5264E355FEF4314AF0449950E4E7096clipboard.png" alt></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>数据卷与持久数据卷</title>
    <url>/2022/07/12/%E6%95%B0%E6%8D%AE%E5%8D%B7%E4%B8%8E%E6%8C%81%E4%B9%85%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
    <content><![CDATA[<h2 id="为什么需要存储卷">为什么需要存储卷</h2>
<p>容器部署过程中一般有以下三种数据：</p>
<ul>
<li>
<p>启动时需要的初始数据，例如配置文件</p>
</li>
<li>
<p>启动过程中产生的临时数据，该临时数据需要多个容器间共享</p>
</li>
<li>
<p>启动过程中产生的持久化数据，例如MySQL的data目录</p>
</li>
</ul>
<p><img src="/images/FB8D2370347643C8B7E7A9D6D7009856clipboard.png" alt></p>
<h2 id="数据卷概述">数据卷概述</h2>
<ul>
<li>
<p>Kubernetes中的Volume提供了在容器中挂载外部存储的能力</p>
</li>
<li>
<p>Pod需要设置卷来源（spec.volume）和挂载点（spec.containers.volumeMounts）两个信息后才可以使用相应的Volume</p>
</li>
</ul>
<p>数据卷类型大致分类：</p>
<ul>
<li>
<p>本地（hostPath，emptyDir等）</p>
</li>
<li>
<p>网络（NFS，Ceph，GlusterFS等）</p>
</li>
<li>
<p>公有云（AWS EBS等）</p>
</li>
<li>
<p>K8S资源（configmap，secret等）</p>
</li>
</ul>
<p>支持的数据劵类型：<a href="https://kubernetes.io/docs/concepts/storage/volumes/">https://kubernetes.io/docs/concepts/storage/volumes/</a></p>
<h2 id="数据卷：emptyDir">数据卷：emptyDir</h2>
<p>emptyDir卷：是一个临时存储卷，与Pod生命周期绑定一起，如果 Pod删除了卷也会被删除。</p>
<p>应用场景：Pod中容器之间数据共享</p>
<p>示例：Pod内容器之前共享数据</p>
<p>vim emptyDir.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: emptydir-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: write</span><br><span class="line">    image: centos</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in &#123;1..100&#125;;do echo <span class="variable">$i</span> &gt;&gt; /data/hello;sleep 1;done&quot;</span>]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /data</span><br><span class="line">  - name: <span class="built_in">read</span></span><br><span class="line">    image: centos</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /data/hello&quot;</span>]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /data</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: data</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f emptyDir.yaml </span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl <span class="built_in">exec</span> -it emptydir-pod -c write -- bash   <span class="comment">#写容器</span></span><br><span class="line"><span class="comment"># ls /data/</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it emptydir-pod -c <span class="built_in">read</span> -- bash    <span class="comment">#读容器</span></span><br><span class="line"><span class="comment"># ls /data/</span></span><br><span class="line"><span class="comment"># tail -f /data/hello </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据目录存放在本地的路径</span></span><br><span class="line">kubectl get pod -o wide  <span class="comment">#查看该pod在哪个节点，对应节点查看数据卷目录</span></span><br><span class="line"><span class="comment">#data的存放目录路径</span></span><br><span class="line">docker ps -l         <span class="comment">#查看最近创建的容器</span></span><br><span class="line">/var/lib/kubelet/pods/53d07406-364b-4d85-90b9-e3a6dca15427/volumes/kubernetes.io~empty-dir/data</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数据卷：hostPath">数据卷：hostPath</h2>
<p>hostPath卷：挂载Node文件系统（Pod所在节点）上文件或者目 录到Pod中的容器。</p>
<p>应用场景：Pod中容器需要访问宿主机文件</p>
<p>示例：将宿主机/tmp目录挂载到容器/data目录</p>
<p>vim hostpath.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: hostpath-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - <span class="built_in">sleep</span> 36000</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /data</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: data</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /tmp</span><br><span class="line">      <span class="built_in">type</span>: Directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f hostpath.yaml </span><br><span class="line">kubectl get pod -o wide     <span class="comment">#查看该pod所在节点</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it hostpath-pod -- sh</span><br><span class="line"><span class="comment"># ls /data/</span></span><br><span class="line"></span><br><span class="line">在pod所在节点的/tmp目录下创建文件，验证pod中/data目录下能否看见</span><br><span class="line"><span class="built_in">touch</span> /tmp/xiaozhe.txt </span><br></pre></td></tr></table></figure>
<h2 id="数据卷：NFS">数据卷：NFS</h2>
<p>NFS数据卷：提供对NFS挂载支持，可以自动将NFS共享 路径挂载到Pod中</p>
<p>NFS：是一个主流的文件共享服务器。</p>
<p><img src="/images/28A0DA7356A64912A77B538BF4AEAF76clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装nfs安装包（每个k8s节点都要安装）</span></span><br><span class="line">yum install nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建nfs共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改nfs配置文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/nfs/kubernetes *(rw,no_root_squash)</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动nfs并加入开机自启</span></span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#尝试在别的K8s节点挂载nfs共享目录</span></span><br><span class="line">mount -t nfs 192.168.0.13:/nfs/kubernetes /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment">#在/mnt下新建文件，验证在nfs服务器共享目录下能否看到该文件</span></span><br><span class="line"><span class="built_in">touch</span> /mnt/index.html</span><br><span class="line"><span class="built_in">ls</span> /nfs/kubernetes/</span><br></pre></td></tr></table></figure>
<p>示例：将网站程序通过NFS数据卷共享，让所有Pod使用</p>
<p>vim nfs.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nfs-nginx</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nfs-nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: wwwroot</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br><span class="line">      volumes:</span><br><span class="line">      - name: wwwroot</span><br><span class="line">        nfs:</span><br><span class="line">          server: 192.168.0.13</span><br><span class="line">          path: /nfs/kubernetes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nfs.yaml </span><br><span class="line">kubectl get pod -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment">#在nfs服务器上修改nfs的共享目录下index.html里面的内容</span></span><br><span class="line"><span class="built_in">echo</span> hello &gt; index.html</span><br><span class="line">curl 10.244.36.74     <span class="comment">#访问nfs的任意pod的IP，验证数据是否共享</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<h2 id="持久卷概述">持久卷概述</h2>
<p>PersistentVolume（PV）：对存储资源创建和使用的抽象，使得存储作为集群中的资源管理 • PersistentVolumeClaim（PVC）：让用户不需要关心具体的Volume实现细节</p>
<h2 id="PV与PVC使用流程">PV与PVC使用流程</h2>
<p><img src="/images/FF65698AA4024189919794B4672DE56Bclipboard.png" alt></p>
<p>支持持久卷的存储插件：<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">https://kubernetes.io/docs/concepts/storage/persistent-volumes/</a></p>
<p>vim pv.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pv</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/kubernetes</span><br><span class="line">    server: 192.168.0.13</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim pvc-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: pvc-nginx</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: pvc-nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: wwwroot</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br><span class="line">      volumes:</span><br><span class="line">      - name: wwwroot</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: my-pvc</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pvc</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 5Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pv.yaml </span><br><span class="line">kubectl apply -f pvc-deployment.yaml </span><br><span class="line">kubectl get pv,pvc</span><br><span class="line">kubectl get pod -o wide     </span><br><span class="line">curl 10.244.169.139         <span class="comment">#访问该pod对应的IP</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p><img src="/images/ED2ECD142CBB4EAAB83BC7E2AB52D234clipboard.png" alt></p>
<h2 id="PV-生命周期">PV 生命周期</h2>
<p>ACCESS MODES（访问模式）：</p>
<p>AccessModes 是用来对 PV 进行访问模式的设置，用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：</p>
<ul>
<li>
<p>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</p>
</li>
<li>
<p>ReadOnlyMany（ROX）：只读权限，可以被多个节点挂载</p>
</li>
<li>
<p>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</p>
</li>
</ul>
<p>RECLAIM POLICY（回收策略）：</p>
<p>目前 PV 支持的策略有三种：</p>
<ul>
<li>
<p>Retain（保留）： 保留数据，需要管理员手工清理数据</p>
</li>
<li>
<p>Recycle（回收）：清除 PV 中的数据，效果相当于执行 rm -rf /ifs/kuberneres/*</p>
</li>
<li>
<p>Delete（删除）：与 PV 相连的后端存储同时删除</p>
</li>
</ul>
<p>STATUS（状态）：</p>
<p>一个 PV 的生命周期中，可能会处于4中不同的阶段：</p>
<ul>
<li>
<p>Available（可用）：表示可用状态，还未被任何 PVC 绑定</p>
</li>
<li>
<p>Bound（已绑定）：表示 PV 已经被 PVC 绑定</p>
</li>
<li>
<p>Released（已释放）：PVC 被删除，但是资源还未被集群重新声明</p>
</li>
<li>
<p>Failed（失败）： 表示该 PV 的自动回收失败</p>
</li>
</ul>
<p>现在PV使用方式称为静态供给，需要K8s运维工程师提前创 建一堆PV，供开发者使用。</p>
<p><img src="/images/7F6C904DF2F547EFA22234DA45AC0D74clipboard.png" alt></p>
<p>在nfs服务器共享目录下创建多个目录，供下面引用不同的pv匹配不同的pv目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /nfs/kubernetes/</span><br><span class="line"><span class="built_in">mkdir</span> pv&#123;2,3,4&#125;</span><br><span class="line"><span class="built_in">cd</span> pv2/</span><br><span class="line"><span class="built_in">echo</span> 222 &gt;index.html</span><br><span class="line"><span class="built_in">cd</span> ../pv4/</span><br><span class="line"><span class="built_in">echo</span> 444 &gt;index.html    </span><br></pre></td></tr></table></figure>
<p>vim pv234.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv2</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 3Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/kubernetes/pv2</span><br><span class="line">    server: 192.168.0.13</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv3</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/kubernetes/pv3</span><br><span class="line">    server: 192.168.0.13</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv4</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 10Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/kubernetes/pv4</span><br><span class="line">    server: 192.168.0.13</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim pvc234-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc234-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: pvc234-nginx</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: pvc234-nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: wwwroot</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br><span class="line">      volumes:</span><br><span class="line">      - name: wwwroot</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: pv2</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pv2</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 8Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pv234.yaml </span><br><span class="line">kubectl apply -f pvc234-deployment.yaml </span><br><span class="line">kubectl get pv,pvc</span><br></pre></td></tr></table></figure>
<p><img src="/images/4E8E666509E344BB9880A3EE7743CDBCclipboard.png" alt></p>
<p>从上面pvc234-deployment.yaml 文件配置可以看到，配置文件指定的pvc是pv2，使用最大容量是8Gi，但是pv2的容量可以看到是3Gi，并不满足你要使用的容量，但是为了尽可能的分配给你，所以它将pv4指定了给你使用，pv4的容量是10Gi。</p>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -o wide    <span class="comment">#查看该pod对应的IP</span></span><br><span class="line">curl 10.244.36.76        <span class="comment">#可以看到结果是pv4目录下的内容</span></span><br><span class="line">444                      </span><br></pre></td></tr></table></figure>
<h2 id="PV-动态供给（StorageClass）">PV 动态供给（StorageClass）</h2>
<p>PV静态供给明显的缺点是维护成本太高了！</p>
<p>因此，K8s开始支持PV动态供给，使用StorageClass对象实现。</p>
<p><img src="/images/F0D3C44DEBDE478DB81FA77DACA6BD67clipboard.png" alt></p>
<p>支持动态供给的存储插件：<a href="https://kubernetes.io/docs/concepts/storage/storage-classes/">https://kubernetes.io/docs/concepts/storage/storage-classes/</a></p>
<p><img src="/images/4B20627845894BA38107F554AE2F816Eclipboard.png" alt></p>
<p>部署NFS实现自动创建PV插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-incubator/external-storage </span><br><span class="line"><span class="built_in">cd</span> nfs-client/deploy </span><br><span class="line">kubectl apply -f rbac.yaml <span class="comment"># 授权访问apiserver </span></span><br><span class="line">kubectl apply -f deployment.yaml <span class="comment"># 部署插件，需修改里面NFS服务器地址与共享目录 </span></span><br><span class="line">kubectl apply -f class.yaml <span class="comment"># 创建存储类</span></span><br><span class="line"></span><br><span class="line">kubectl get sc  <span class="comment"># 查看存储类</span></span><br></pre></td></tr></table></figure>
<p><a href="/attachments/9CF482103C694E018A1FEDFC08B95305nfs-client.zip">nfs-client.zip</a></p>
<p>#修改deployment.yaml 修改里面NFS服务器地址与共享目录</p>
<p><img src="/images/36841FF64E8B43B6BA77621F00E1EAFFclipboard.png" alt></p>
<p>vim sc-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: sc-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: sc-nginx</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: sc-nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: wwwroot</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br><span class="line">      volumes:</span><br><span class="line">      - name: wwwroot</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: nfs-pvc</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pvc</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: <span class="string">&quot;managed-nfs-storage&quot;</span>  <span class="comment">#在创建pvc时指定存储类名称</span></span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 12Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f sc-deployment.yaml </span><br><span class="line">kubectl get pv,pvc</span><br></pre></td></tr></table></figure>
<p><img src="/images/B5135FE1E30A49D09D5705CF74E0127Dclipboard.png" alt></p>
<p>从上图可以看出当我们使用kubectl创建一个deployment时，它会请求managed-nfs-storage（nfs存储类），然后managed-nfs-storage调用nfs-client-provisioner插件(pod)，帮我们自动创建pv。</p>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在nfs服务器共享目录下新建文件</span></span><br><span class="line"><span class="built_in">cd</span> /nfs/kubernetes/default-nfs-pvc-pvc-2a62f7d8-b356-45d0-87cb-018c10447595</span><br><span class="line"><span class="built_in">echo</span> sc &gt; index.html</span><br><span class="line">kubectl get pod -o wide</span><br><span class="line">curl 10.244.169.142      <span class="comment">#验证数据是否是新建的内容</span></span><br><span class="line">sc</span><br></pre></td></tr></table></figure>
<p>删除deployment</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete -f sc-deployment.yaml</span><br></pre></td></tr></table></figure>
<p>在nfs服务器上的共享目录查看</p>
<p><img src="/images/B45261F8AE7B4F79815693DABBBC1544clipboard.png" alt></p>
<p><img src="/images/EF34312BE1134B1CA0B0D557B9299951clipboard.png" alt></p>
<p><img src="/images/F8A5A52C50774ACE84922233ED73CF99clipboard.png" alt></p>
<p>从上面可以看出，nfs的回收策略是deployment删除后端的存储也同时删除，但是当我们把deployment删除之后，数据共享目录还在，并没有删除，它只是帮我们把数据共享目录归档了，如果要删除需要修改class.yaml 配置文件中的archiveOnDelete为false，这时就会帮我们删除后端数据共享目录。</p>
<p><img src="/images/CEA08EB09CA34E518ABCAD947DE16DA3clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f class.yaml  <span class="comment">#更新配置</span></span><br><span class="line">kubectl delete -f sc-deployment.yaml   </span><br><span class="line">kubectl apply -f sc-deployment.yaml    <span class="comment">#删除再创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#再次在nfs服务器共享目录下新建文件</span></span><br><span class="line"><span class="built_in">cd</span> /nfs/kubernetes/default-nfs-pvc-pvc-d5ca3b6e-7045-4868-8fdf-17063bc19e13</span><br><span class="line"><span class="built_in">echo</span> 123456 &gt; index.html</span><br><span class="line">kubectl get pod -o wide</span><br><span class="line">curl 10.244.169.142      <span class="comment">#验证数据是否是新建的内容</span></span><br><span class="line">123456</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除deployment后，验证在nfs服务器上查看是否删除了数据共享目录下的pv目录</span></span><br><span class="line">kubectl delete -f sc-deployment.yaml  </span><br></pre></td></tr></table></figure>
<p>Q：PV与PVC什么关系？</p>
<p>A：一对一</p>
<p>Q：PVC与PV怎么匹配的？</p>
<p>A：访问模式和存储容量</p>
<p>Q：容量匹配策略</p>
<p>A：匹配就近的符合的容量（向上）</p>
<p>Q：存储容量是真的用于限制吗？</p>
<p>A：存储容量取决于后端存储，容量字段主要还是用于匹配</p>
<p>1、使用Ingress暴露应用对外访问</p>
<p>2、创建一个configmap，使用环境变量和数据卷方式引用</p>
<p>3、创建一个pv，再创建一个pod使用该pv</p>
<p>4、配置PV自动供给，再创建一个pod使用该pv</p>
<p>注：自由发挥，实现需求即可</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>案例一服务器系统配置初始化</title>
    <url>/2021/03/10/%E6%A1%88%E4%BE%8B%E4%B8%80%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>背景：新购买10台服务器并已安装Linux系统</p>
<p>需求：</p>
<p>1.设置时区并同步时间</p>
<p>2.禁用selinux</p>
<p>3.清空防火墙默认策略</p>
<p>4.历史命令显示操作时间</p>
<p>5.禁止root远程登陆</p>
<p>6.禁止定时任务发送邮件</p>
<p>7.设置最大打开文件数</p>
<p>8.减少swap使用</p>
<p>9.系统内核参数优化</p>
<p>10.安装系统性能分析工具及其他</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#配置阿里云yum源</span></span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line"><span class="built_in">mkdir</span> centos</span><br><span class="line"><span class="built_in">mv</span> /etc/yum.repos.d/CentOS-* centos</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo </span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line"><span class="comment"># 设置时区并同步时间</span></span><br><span class="line">timedatectl set-timezone Asia/Shanghaihttp://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="built_in">ln</span> -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"><span class="keyword">if</span> ! crontab -l |grep ntpdate &amp;&gt;/dev/null ; <span class="keyword">then</span></span><br><span class="line">    (<span class="built_in">echo</span> <span class="string">&quot;* 1 * * * ntpdate time.windows.com &gt;/dev/null 2&gt;&amp;1&quot;</span>;crontab -l) |crontab </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用selinux</span></span><br><span class="line">sed -i <span class="string">&#x27;/SELINUX/&#123;s/enforcing/disabled/&#125;&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line"><span class="keyword">if</span> egrep <span class="string">&quot;7.[0-9]&quot;</span> /etc/redhat-release &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    systemctl stop firewalld</span><br><span class="line">    systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="keyword">elif</span> egrep <span class="string">&quot;6.[0-9]&quot;</span> /etc/redhat-release &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    service iptables stop</span><br><span class="line">    chkconfig iptables off</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 历史命令显示操作时间</span></span><br><span class="line"><span class="keyword">if</span> ! grep HISTTIMEFORMAT /etc/bashrc; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;export HISTTIMEFORMAT=&quot;%F %T `whoami` &quot;&#x27;</span> &gt;&gt; /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">source</span> /etc/bashrc</span><br><span class="line"><span class="comment"># SSH超时时间</span></span><br><span class="line"><span class="keyword">if</span> ! grep <span class="string">&quot;TMOUT=600&quot;</span> /etc/profile &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;export TMOUT=600&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止root远程登录</span></span><br><span class="line">sed -i <span class="string">&#x27;s/#PermitRootLogin yes/PermitRootLogin no/&#x27;</span> /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止定时任务发送邮件</span></span><br><span class="line">sed -i <span class="string">&#x27;s/^MAILTO=root/MAILTO=&quot;&quot;/&#x27;</span> /etc/crontab </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最大打开文件数</span></span><br><span class="line"><span class="keyword">if</span> ! grep <span class="string">&quot;* soft nofile 65535&quot;</span> /etc/security/limits.conf &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/security/limits.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">    * soft nofile 65535</span></span><br><span class="line"><span class="string">    * hard nofile 65535</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统内核优化</span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/sysctl.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">net.ipv4.tcp_syncookies = 1</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_tw_buckets = 20480</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_syn_backlog = 20480</span></span><br><span class="line"><span class="string">net.core.netdev_max_backlog = 262144</span></span><br><span class="line"><span class="string">net.ipv4.tcp_fin_timeout = 20  </span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减少SWAP使用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0&quot;</span> &gt; /proc/sys/vm/swappiness</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装系统性能分析工具及其他</span></span><br><span class="line">yum install gcc make autoconf vim sysstat net-tools iostat iftop iotp lrzsz -y</span><br></pre></td></tr></table></figure>
<p>在Windows 下的脚本格式放在Linux下可能格式就变了，我们可以安装一个工具来转换格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install dos2unix -y</span><br><span class="line">dos2unix 脚本名</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim 1.sh</span><br><span class="line">:<span class="built_in">set</span> fileformat=unix</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Console服务发现</title>
    <url>/2021/09/05/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基于文件的服务发现</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">#启用基于文件的服务发现</span></span><br><span class="line"><span class="comment">#以下都在服务端配置</span></span><br><span class="line">vim /opt/monitor/prometheus/prometheus.yml</span><br><span class="line">scrape_configs:</span><br><span class="line">   - job_name: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">     basic_auth:</span><br><span class="line">        username: prometheus</span><br><span class="line">        password: 123.com</span><br><span class="line">     file_sd_configs:</span><br><span class="line">     - files: [<span class="string">&#x27;/opt/monitor/prometheus/sd_config/*.yml&#x27;</span>]</span><br><span class="line">      refresh_interval: 5s    <span class="comment"># 每隔5秒检查一次</span></span><br><span class="line">---------------------------------------------------</span><br><span class="line"><span class="comment">#配置完成后，使用promtool工具检查配置文件是否有误</span></span><br><span class="line"><span class="built_in">cd</span> /opt/monitor/prometheus</span><br><span class="line">./promtool check config ./prometheus.yml </span><br><span class="line"><span class="comment">#查看prometheus的进程id,上面修改配置进行热加载配置</span></span><br><span class="line">ps -ef |grep prometheus</span><br><span class="line"><span class="built_in">kill</span> -HUP 62291 </span><br><span class="line">------------------------------------------------------------      </span><br><span class="line"><span class="comment">#添加被监控端：</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/monitor/prometheus/sd_config</span><br><span class="line"><span class="built_in">cd</span> /opt/monitor/prometheus/sd_config/</span><br><span class="line"><span class="comment">#定期检查该文件，自动将文件中的主机加入监控指标</span></span><br><span class="line">vi test.yml      </span><br><span class="line">- targets: [<span class="string">&#x27;192.168.1.13:9100&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/21B0972D1392455E9EE63924C4FA18DEclipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基于consul的服务发现</span></span><br><span class="line"><span class="comment">#Consul是一个分布式的服务发现和键/值存储系统。</span></span><br><span class="line"><span class="comment">#Docker部署Consul：（任意机器部署，只要prometheus和被监控端能够和consul通信即可</span></span><br><span class="line">docker run --name consul -d -p 8500:8500 consul</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"><span class="comment">#被监控端配置</span></span><br><span class="line"><span class="comment">#向consul服务注册自己的IP，端口信息，prometheus会自动的监控这些主机  </span></span><br><span class="line"><span class="built_in">id</span>:consul里面的一个实例  </span><br><span class="line">name:consul里面的一个组名</span><br><span class="line">address和port：自己的IP和端口  </span><br><span class="line">tags:consul里面的标签 </span><br><span class="line">checks：consul的健康检查  </span><br><span class="line">最后是consul的注册地址</span><br><span class="line">curl -X PUT -d <span class="string">&#x27;&#123;&quot;id&quot;: &quot;Linux-2&quot;,&quot;name&quot;: &quot;Linux&quot;,&quot;address&quot;: &quot;192.168.0.13&quot;,&quot;port&quot;:9100,&quot;tags&quot;:[&quot;service&quot;],&quot;checks&quot;: [&#123;&quot;http&quot;: &quot;http://192.168.0.13:9100&quot;,&quot;interval&quot;:&quot;5s&quot;&#125;]&#125;&#x27;</span> http://192.168.0.11:8500/v1/agent/service/register</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"><span class="comment">#服务端配置</span></span><br><span class="line">vim /opt/monitor/prometheus/prometheus.yml</span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: <span class="string">&#x27;consul&#x27;</span></span><br><span class="line">    consul_sd_configs:</span><br><span class="line">    - server: 192.168.0.11:8500    <span class="comment">#consul地址及端口</span></span><br><span class="line">     services: [<span class="string">&#x27;linux&#x27;</span>]      <span class="comment">#组名</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"><span class="comment">#配置完成后，使用promtool工具检查配置文件是否有误</span></span><br><span class="line"><span class="built_in">cd</span> /opt/monitor/prometheus</span><br><span class="line">./promtool check config ./prometheus.yml </span><br><span class="line"><span class="comment">#查看prometheus的进程id,上面修改配置进行热加载配置</span></span><br><span class="line">ps -ef |grep prometheus</span><br><span class="line"><span class="built_in">kill</span> -HUP 62291 </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/942C52DE74C740FA91CE188A2296E72Dclipboard.png" alt></p>
<p><img src="/images/61C922EBF7684A1FB84802279B272411clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>案例七监控100台服务器磁盘利用率</title>
    <url>/2021/03/16/%E6%A1%88%E4%BE%8B%E4%B8%83%E7%9B%91%E6%8E%A7100%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A3%81%E7%9B%98%E5%88%A9%E7%94%A8%E7%8E%87/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ssh远程登录查看磁盘</span></span><br><span class="line">ssh root@192.168.1.3 <span class="string">&quot;df -h&quot;</span></span><br><span class="line"><span class="comment">#实现免密登录</span></span><br><span class="line">ssh-keygen</span><br><span class="line"><span class="comment">#在当前用户的目录下生成一个密钥对</span></span><br><span class="line"><span class="built_in">cat</span> /root/.ssh/</span><br><span class="line"><span class="comment">#将公钥拷贝到要远程免密登录的机器上</span></span><br><span class="line">ssh-copy-id root@192.168.1.3</span><br><span class="line"><span class="comment">#拷贝过去这样就可以免密登录了</span></span><br><span class="line">ssh -i /root/.ssh/id_rsa root@192.168.1.3</span><br><span class="line"></span><br><span class="line"><span class="comment">#存放远程登录IP，用户，端口的一个文件，从这里调取</span></span><br><span class="line">vim host.info</span><br><span class="line">192.168.1.3 root 22</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#存放远程登录IP，用户，端口的一个文件，从这里调取</span></span><br><span class="line">HOST_INFO=host.info</span><br><span class="line"><span class="comment">#^[^#]:除了带#的，其余都遍历，例如某台机器故障了；</span></span><br><span class="line"><span class="comment">#解释：循环遍历host.info文件中的第一列值(除#号开头的)</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> $(awk <span class="string">&#x27;/^[^#]/&#123;print $1&#125;&#x27;</span> <span class="variable">$HOST_INFO</span>); <span class="keyword">do</span></span><br><span class="line"><span class="comment">#解释：判断当前ip是不是host.info文件中第一列的值，如果是打印这个值对应的第二列的值</span></span><br><span class="line">    USER=$(awk -v ip=<span class="variable">$IP</span> <span class="string">&#x27;ip==$1&#123;print $2&#125;&#x27;</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line"><span class="comment">#解释：判断当前ip是不是host.info文件中第一列的值，如果是打印这个值对应的第三列的值</span></span><br><span class="line">    PORT=$(awk -v ip=<span class="variable">$IP</span> <span class="string">&#x27;ip==$1&#123;print $3&#125;&#x27;</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line"><span class="comment">#解释：临时保存磁盘信息的一个文件</span></span><br><span class="line">    TMP_FILE=/tmp/disk.tmp</span><br><span class="line"><span class="comment">#解释：通过ssh -P 端口 用户名@IP远程登录查看磁盘信息，将它写进文件中</span></span><br><span class="line">    ssh -p <span class="variable">$PORT</span> <span class="variable">$USER</span>@<span class="variable">$IP</span> <span class="string">&#x27;df -h&#x27;</span> &gt; <span class="variable">$TMP_FILE</span></span><br><span class="line"><span class="comment">#OFS=&quot;=&quot;表示输出分隔符,以&quot;=&quot;隔开;int($5)表示取整数，去掉%号;  </span></span><br><span class="line"><span class="comment">#解释：打印disk.tmp这文件中以/dev/开头的这一行对应的第五列和最后一列的值</span></span><br><span class="line">    USE_RATE_LIST=$(awk <span class="string">&#x27;BEGIN&#123;OFS=&quot;=&quot;&#125;/^\/dev/&#123;print $NF,int($5)&#125;&#x27;</span> <span class="variable">$TMP_FILE</span>)</span><br><span class="line"><span class="comment">#解释：循环遍历disk.tmp这个文件中的值</span></span><br><span class="line">    <span class="keyword">for</span> USE_RATE <span class="keyword">in</span> <span class="variable">$USE_RATE_LIST</span>; <span class="keyword">do</span></span><br><span class="line"><span class="comment">#解释：以=为分隔符，去掉=右边的值，*表示通配符</span></span><br><span class="line">        PART_NAME=<span class="variable">$&#123;USE_RATE%=*&#125;</span></span><br><span class="line"><span class="comment">#解释:以=为分隔符，去掉=左边的值，*也就是左边所有的值</span></span><br><span class="line">        USE_RATE=<span class="variable">$&#123;USE_RATE#*=&#125;</span></span><br><span class="line"><span class="comment">#解释：如果右边的值大于80% ，那么就告警</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$USE_RATE</span> -ge 80 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$IP</span> \n Warning: <span class="variable">$PART_NAME</span> Partition usage <span class="variable">$USE_RATE</span>%!&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;YES&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例九批量主机执行命令</title>
    <url>/2021/03/18/%E6%A1%88%E4%BE%8B%E4%B9%9D%E6%89%B9%E9%87%8F%E4%B8%BB%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#expect是一个自动化交互套件，主要应用于执行命令和程序时，系统以交互形式要求输入指定字符串，实现交互通信。</span></span><br><span class="line"><span class="comment">#spawn启动指定进程---expect获取指定关键字---send向指定程序发送指定字符---执行完成退出.</span></span><br><span class="line"><span class="comment">#expect常用命令总结:</span></span><br><span class="line">spawn               交互程序开始后面跟命令或者指定程序</span><br><span class="line">expect              获取匹配信息匹配成功则执行expect后面的程序动作</span><br><span class="line">send exp_send       用于发送指定的字符串信息</span><br><span class="line">exp_continue        在expect中多次匹配就需要用到</span><br><span class="line">send_user           用来打印输出 相当于shell中的<span class="built_in">echo</span></span><br><span class="line"><span class="built_in">exit</span>                退出expect脚本</span><br><span class="line">eof                 expect执行结束 退出</span><br><span class="line"><span class="built_in">set</span>                 定义变量</span><br><span class="line">puts                输出变量</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">timeout</span>         设置超时时间</span><br><span class="line"><span class="comment">#安装expect工具</span></span><br><span class="line">yum -y install expect </span><br><span class="line"><span class="comment">#存放远程登录IP，用户，端口,密码的一个文件，从这里调取</span></span><br><span class="line">vim host.info</span><br><span class="line">192.168.1.3 root 22 123.com</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#执行的shell命令，$*表示所有位置参数</span></span><br><span class="line">COMMAND=$*</span><br><span class="line"><span class="comment">#存放远程登录IP，用户，端口，密码的一个文件，从这里调取</span></span><br><span class="line">HOST_INFO=host.info</span><br><span class="line"><span class="comment">#^[^#]表示开头为#号并取反，也就是除了#号开头的，其余都遍历</span></span><br><span class="line"><span class="comment">#循环遍历host.info文件中的第一列值(除#号开头的)</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> $(awk <span class="string">&#x27;/^[^#]/&#123;print $1&#125;&#x27;</span> <span class="variable">$HOST_INFO</span>); <span class="keyword">do</span></span><br><span class="line"><span class="comment">#解释：判断当前ip是不是host.info文件中第一列的值，如果是打印这个值对应的第二列的值</span></span><br><span class="line">    USER=$(awk -v ip=<span class="variable">$IP</span> <span class="string">&#x27;ip==$1&#123;print $2&#125;&#x27;</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line"><span class="comment">#解释：判断当前ip是不是host.info文件中第一列的值，如果是打印这个值对应的第三列的值</span></span><br><span class="line">    PORT=$(awk -v ip=<span class="variable">$IP</span> <span class="string">&#x27;ip==$1&#123;print $3&#125;&#x27;</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line"><span class="comment">#解释：判断当前ip是不是host.info文件中第一列的值，如果是打印这个值对应的第四列的值</span></span><br><span class="line">    PASS=$(awk -v ip=<span class="variable">$IP</span> <span class="string">&#x27;ip==$1&#123;print $4&#125;&#x27;</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line"><span class="comment">#表示执行expect自身的一个指令</span></span><br><span class="line">    expect -c <span class="string">&quot;</span></span><br><span class="line"><span class="string">#在expect的shell环境中执行ssh -p <span class="variable">$PORT</span> <span class="variable">$USER</span>@<span class="variable">$IP</span>这条命令</span></span><br><span class="line"><span class="string">       spawn ssh -p <span class="variable">$PORT</span> <span class="variable">$USER</span>@<span class="variable">$IP</span></span></span><br><span class="line"><span class="string">#捕获当前的一个信息，自动帮你输入</span></span><br><span class="line"><span class="string">       expect &#123;</span></span><br><span class="line"><span class="string">#初次远程登录会输入yes/no，发送yes指令，\表示转义，r表示回车</span></span><br><span class="line"><span class="string">          \&quot;(yes/no)\&quot; &#123;send \&quot;yes\r\&quot;; exp_continue&#125;</span></span><br><span class="line"><span class="string">#紧接着就是输入密码，发送密码指令</span></span><br><span class="line"><span class="string">          \&quot;password:\&quot; &#123;send \&quot;<span class="variable">$PASS</span>\r\&quot;; exp_continue&#125;</span></span><br><span class="line"><span class="string">#<span class="variable">$USER</span>@*表示匹配当前的用户名和@符号，发送你想要的执行的命令</span></span><br><span class="line"><span class="string">          \&quot;<span class="variable">$USER</span>@*\&quot; &#123;send \&quot;<span class="variable">$COMMAND</span>\r exit\r\&quot;; exp_continue&#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">    &quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-------------------&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例二发送告警邮件</title>
    <url>/2021/03/11/%E6%A1%88%E4%BE%8B%E4%BA%8C%E5%8F%91%E9%80%81%E5%91%8A%E8%AD%A6%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mailx是一个邮件发送程序，像 sendmail  postfix</span></span><br><span class="line">yum install mailx</span><br><span class="line"><span class="comment">#编辑mail配置文件</span></span><br><span class="line">vi /etc/mail.rc  </span><br><span class="line"><span class="built_in">set</span> from=123456@sina.com smtp=smtp.sina.com</span><br><span class="line"><span class="built_in">set</span> smtp-auth-user=123456@sina.com smtp-auth-password=b78e6f39cc4699ad</span><br><span class="line"><span class="built_in">set</span> smtp-auth=login</span><br><span class="line"><span class="comment">#发送邮件  </span></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line"><span class="comment">#mail -s &quot;标题&quot; 邮件地址 &lt; 要发送的文件</span></span><br><span class="line"><span class="comment">#mail -s &quot;hello world&quot; 623799533@qq.com &lt;/etc/hosts</span></span><br><span class="line"><span class="comment">#echo &quot;正文&quot;|mail -s &quot;hello world&quot; 623799533@qq.com</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is liuzhe.&quot;</span> |mail -s <span class="string">&quot;monitor&quot;</span> 123456@sina.com</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#mailx是一个邮件发送程序</span></span><br><span class="line">yum install mailx</span><br><span class="line"><span class="comment">#添加邮件账户，密码</span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/mail.rc &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">set from=123456@sina.com smtp=smtp.sina.com</span></span><br><span class="line"><span class="string">set smtp-auth-user=123456@sina.com smtp-auth-password=d2aa4bb9a942a7d2</span></span><br><span class="line"><span class="string">set smtp-auth=login</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment">#发送邮件&quot;this is xiaozhezhe.&quot;到123456@sina.com</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is xiaozhezhe.&quot;</span> |mail -s <span class="string">&quot;hello&quot;</span> 123456@sina.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>标签管理</title>
    <url>/2021/09/04/%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>标签作用：Prometheus中存储的数据为时间序列，是由Metric的名字和一系列的标签(键值对)唯一标识的, 不同的标签代表不同的时间序列，即通过指定标签查询指定数据。</p>
<p>Metadata标签</p>
<p>在Prometheus所有的Target实例中，都包含一些默认的Metadata标签信息。可以通过Prometheus UI的 Targets页面中查看这些实例的Metadata标签的内容：</p>
<p>• <strong>address</strong>：当前Target实例的访问地址:</p>
<p>• <strong>scheme</strong>：采集目标服务访问地址的HTTP Scheme，HTTP或者HTTPS</p>
<p>• <strong>metrics_path</strong>：采集目标服务访问地址的访问路径</p>
<p><img src="/images/0B789DD33F8D4A9CB6CAD026CC746ED3f0e9f9731e54cba7fdd236dad84baab.jpg" alt></p>
<p>上面这些标签将会告诉Prometheus如何从该Target实例中获取监控数据。除了这些默认的标签以外，我们 还可以为Target添加自定义的标签。</p>
<p>自定义标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- job_name: <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">    basic_auth:</span><br><span class="line">        username: prometheus</span><br><span class="line">        password: 123.com</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [<span class="string">&#x27;192.168.0.12:9100&#x27;</span>]</span><br><span class="line">      labels: </span><br><span class="line">        idc: BJ           <span class="comment">#北京的机房</span></span><br><span class="line">        project: JD    <span class="comment">#京东的项目   </span></span><br></pre></td></tr></table></figure>
<p>#在这个下面可以任意的添加多个标签</p>
<p><img src="/images/8C77D0F675884745A62D29DADBF945B5clipboard.png" alt></p>
<p><img src="/images/9005EECBBC9F4E3EAAE4384C50BBDC20clipboard.png" alt="北京机房京东项目整个cpu使用率"></p>
<p>重新标记标签</p>
<p>重新标记目的：为了更好的标识监控指标。</p>
<p>在两个阶段可以重新标记：</p>
<p>• relabel_configs ：在采集之前</p>
<p>• metric_relabel_configs：在存储之前</p>
<p>准备抓取指标数据时，可以使用relabel_configs添加一些标签、也可以只采集特定目标或过滤目标。 已经抓取到指标数据时，可以使用metric_relabel_configs做最后的重新标记和过滤。</p>
<p><img src="/images/68593A5F220C4D2A88AB5E0A571414FBclipboard.png" alt></p>
<p>重新标记标签一般用途：</p>
<p>• 动态生成新标签</p>
<p>• 过滤采集的Target</p>
<p>• 删除不需要或者敏感标签</p>
<p>• 添加新标签</p>
<p>action：重新标记标签动作</p>
<p>• replace：默认，通过regex匹配source_label的值，使用replacement来 引用表达式匹配的分组，分组使用$1,$2…引用</p>
<p>• keep：删除regex与连接不匹配的目标 source_labels</p>
<p>• drop：删除regex与连接匹配的目标 source_labels</p>
<p>• labeldrop：删除regex匹配的标签</p>
<p>• labelkeep：删除regex不匹配的标签</p>
<p>• labelmap：匹配regex所有标签名称，并将捕获的内容分组，用第一个分 组内容作为新的标签名</p>
<p>重新标签的应用</p>
<p>重新标记标签：重命名标签</p>
<p>场景1：动态生成添加标签（对已有的标签重新标记）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- job_name: <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">   basic_auth:</span><br><span class="line">       username: prometheus</span><br><span class="line">       password: 123.com</span><br><span class="line">   static_configs:</span><br><span class="line">   - targets: [<span class="string">&#x27;192.168.0.12:9100&#x27;</span>]</span><br><span class="line">     labels:</span><br><span class="line">       idc: BJ</span><br><span class="line">       project: JD</span><br><span class="line">   metric_relabel_configs:             <span class="comment">#在存储数据之前重新标记 </span></span><br><span class="line">   - action: replace                         <span class="comment">#重新标记标签动作，默认replace</span></span><br><span class="line">     source_labels: [<span class="string">&#x27;instance&#x27;</span>]        <span class="comment">#告诉prometheus基于哪个标签生成新的标签（重新标记）</span></span><br><span class="line">     regex: (.*):([0-9]+)                 <span class="comment">#正则匹配，（.*)代表一组IP，([0-9]+)代表一组数字，通过：分隔</span></span><br><span class="line">     replacement: <span class="variable">$1</span>    <span class="comment"># 赋予生成新标签的值，引用正则匹配值，$1表示第一组，$2表示第二组，可以明确指定值</span></span><br><span class="line">     target_label: <span class="string">&quot;ip&quot;</span>            <span class="comment">#生成的新的标签名叫什么</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/E1A47462B5D0449E9B7B608CA14DD68Eclipboard.png" alt="动态生成新的标签----&gt;ip"></p>
<p>重新标记标签：过滤Target</p>
<p>场景2：选择采集的目标</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- job_name: <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">  basic_auth:</span><br><span class="line">      username: prometheus</span><br><span class="line">      password: 123.com</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets: [<span class="string">&#x27;192.168.0.12:9100&#x27;</span>]</span><br><span class="line">    labels:</span><br><span class="line">      idc: BJ</span><br><span class="line">      project: JD</span><br><span class="line">  relabel_configs:                     <span class="comment">#在采集之前</span></span><br><span class="line">  - action: drop                        <span class="comment">#重新标记标签动作 ，删除regex与连接匹配的目标 source_labels</span></span><br><span class="line">    regex: <span class="string">&quot;192.168.0.12.*&quot;</span>      <span class="comment">#意思就是通过正则过滤掉这个target实例</span></span><br><span class="line">    source_labels: [<span class="string">&quot;__address__&quot;</span>]      <span class="comment">#基于哪个标签过滤</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/CF7CC5B4D4FC4FAEA8D031289B5E2FBCclipboard.png" alt="过滤掉192.168.0.12这个target实例了"></p>
<p>注意：</p>
<p><strong>address</strong>  ：这个标签是在采集之前</p>
<p>instance : 这个标签是在存储之前</p>
<p>prometheus采集之前使用的是__address__ 这个标签，采集到之后（入库之前），可能生成了一个新的标签，也就是instance这个标签。</p>
<p>重新标记标签：删除标签</p>
<p>场景3：删除不需要或者敏感的标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- job_name: <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">  basic_auth:</span><br><span class="line">      username: prometheus</span><br><span class="line">      password: 123.com</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets: [<span class="string">&#x27;192.168.0.12:9100&#x27;</span>]</span><br><span class="line">    labels:</span><br><span class="line">      idc: BJ</span><br><span class="line">      project: JD</span><br><span class="line">  metric_relabel_configs:                 <span class="comment">#在存储之前(入库之前）</span></span><br><span class="line">  - action: labeldrop                         <span class="comment">#重新标记标签动作 , 删除regex匹配的标签</span></span><br><span class="line">    regex: <span class="string">&quot;job&quot;</span>                                 <span class="comment">#通过正则删除job这个标签</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/9E5647F9F962452BAA99216C24132FFDclipboard.png" alt="会发现库里没有job这个标签"></p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>案例三批量创建100个用户并设置密码</title>
    <url>/2021/03/12/%E6%A1%88%E4%BE%8B%E4%B8%89%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA100%E4%B8%AA%E7%94%A8%E6%88%B7%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>解释：</p>
<p>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p>
<p>cut  [-bn] [file] 或 cut [-c] [file]  或  cut [-df] [file]</p>
<p>主要参数</p>
<p>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</p>
<p>-c ：以字符为单位进行分割。</p>
<p>-d ：自定义分隔符，默认为制表符。</p>
<p>-f  ：与-d一起使用，指定显示哪个区域。</p>
<p>-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的<br>范围之内，该字符将被写出；否则，该字符将被排除。</p>
<p>$RANDOM    #获取随机数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">USER_LIST=<span class="variable">$@</span></span><br><span class="line">USER_FILE=/root/user.txt</span><br><span class="line"><span class="keyword">for</span> USER <span class="keyword">in</span> <span class="variable">$USER_LIST</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> ! <span class="built_in">id</span> <span class="variable">$USER</span> &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        PASS=$(<span class="built_in">echo</span> <span class="variable">$RANDOM</span> |<span class="built_in">md5sum</span> |<span class="built_in">cut</span> -c 1-8)</span><br><span class="line">        useradd <span class="variable">$USER</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$PASS</span> |passwd --stdin <span class="variable">$USER</span> &amp;&gt;/dev/null</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$USER</span>   <span class="variable">$PASS</span>&quot;</span> &gt;&gt; <span class="variable">$USER_FILE</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$USER</span> User create successful.&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$USER</span> User already exists!&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例五找出占用cpu和内存过高的进程</title>
    <url>/2021/03/14/%E6%A1%88%E4%BE%8B%E4%BA%94%E6%89%BE%E5%87%BA%E5%8D%A0%E7%94%A8cpu%E5%92%8C%E5%86%85%E5%AD%98%E8%BF%87%E9%AB%98%E7%9A%84%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----------------cpu top 10---------------&quot;</span></span><br><span class="line"><span class="comment">#解释: ps -o:输出指定的字段; -e:列出所有的进程;--sort:对pcpu字段进行排序-降序</span></span><br><span class="line">ps -eo pid,pcpu,pmem,args --<span class="built_in">sort</span>=-pcpu |<span class="built_in">head</span> -n 10</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----------------memory top 10---------------&quot;</span></span><br><span class="line">ps -eo pid,pcpu,pmem,args --<span class="built_in">sort</span>=-pmem |<span class="built_in">head</span> -n 10 </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例八批量检查网站是否异常</title>
    <url>/2021/03/17/%E6%A1%88%E4%BE%8B%E5%85%AB%E6%89%B9%E9%87%8F%E6%A3%80%E6%9F%A5%E7%BD%91%E7%AB%99%E6%98%AF%E5%90%A6%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#curl是一个命令行访问URL的工具</span></span><br><span class="line">-v 详细输出，包含请求和响应的首部</span><br><span class="line">-o <span class="built_in">test</span> 将指定curl返回保存为<span class="built_in">test</span>文件，内容从html/jpg到各种MIME类型文件</span><br><span class="line">-O  把输出写到该文件中，保留远程文件的文件名</span><br><span class="line">-C 在保存文件时进行续传</span><br><span class="line">-x  ip:port 指定使用的http代理</span><br><span class="line">-c &lt;file&gt; 保存服务器的cookie文件</span><br><span class="line">-H &lt;header:value&gt;  为HTTP请求设置任意header及值</span><br><span class="line">-L 跟随重定向</span><br><span class="line">-S 显示错误信息</span><br><span class="line">-s 静默模式，不输出任何信息</span><br><span class="line">-G 以get的方式发送数据</span><br><span class="line">-f  连接失败是不显示http错误</span><br><span class="line">-d 以post方式传送数据</span><br><span class="line">-w 什么输出完成后</span><br><span class="line">curl -o /dev/null -s -w <span class="string">&quot;%&#123;http_code&#125;&quot;</span> http://www.baidu.com</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="comment">#遍历多个url</span></span><br><span class="line">URL_LIST=<span class="string">&quot;www.baidu.com www.ctnrs.com&quot;</span></span><br><span class="line"><span class="keyword">for</span> URL <span class="keyword">in</span> <span class="variable">$URL_LIST</span>; <span class="keyword">do</span></span><br><span class="line"><span class="comment">#失败url的次数进行统计</span></span><br><span class="line">    FAIL_COUNT=0</span><br><span class="line"><span class="comment">#每个网址进行判断3次</span></span><br><span class="line">    <span class="keyword">for</span> ((i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)); <span class="keyword">do</span></span><br><span class="line"><span class="comment">#--connect-timeout表示访问超市时间为3秒;</span></span><br><span class="line"><span class="comment">#只返回状态码</span></span><br><span class="line">        HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="string">&quot;%&#123;http_code&#125;&quot;</span> <span class="variable">$URL</span>)</span><br><span class="line"><span class="comment">#如果这个状态码是200，也就是正常的，那么就输出ok；</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$HTTP_CODE</span> -eq 200 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$URL</span> OK&quot;</span></span><br><span class="line"><span class="comment">#如果正常，那么就跳出循环</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line"><span class="comment">#否则不正常，那么就尝试访问3次。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$URL</span> retry <span class="variable">$FAIL_COUNT</span>&quot;</span></span><br><span class="line"><span class="comment">#每访问一次加1</span></span><br><span class="line">            <span class="built_in">let</span> FAIL_COUNT++</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="comment">#如果访问3次都不行，那么就发送告警</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$FAIL_COUNT</span> -eq 3 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Warning: <span class="variable">$URL</span> Access failure!&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例十一监控MySQL主从同步状态是否异常</title>
    <url>/2021/03/20/%E6%A1%88%E4%BE%8B%E5%8D%81%E4%B8%80%E7%9B%91%E6%8E%A7mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E6%98%AF%E5%90%A6%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="comment">#连接的主机用户名密码</span></span><br><span class="line">HOST=localhost</span><br><span class="line">USER=root</span><br><span class="line">PASSWD=123.com</span><br><span class="line"><span class="comment">#2&gt;/dev/null表示忽略掉警告</span></span><br><span class="line"><span class="comment">#打印匹配包含&quot;Slave_.*_Running:&quot;这个值的行，*代表通配符</span></span><br><span class="line">IO_SQL_STATUS=$(mysql -h<span class="variable">$HOST</span> -u<span class="variable">$USER</span> -p<span class="variable">$PASSWD</span> -e <span class="string">&#x27;show slave status\G&#x27;</span> 2&gt;/dev/null |awk <span class="string">&#x27;/Slave_.*_Running:/&#123;print $1$2&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">#遍历循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$IO_SQL_STATUS</span>; <span class="keyword">do</span></span><br><span class="line"><span class="comment">#以:为分隔符去掉右边的值，*代表右边所有值</span></span><br><span class="line">    THREAD_STATUS_NAME=<span class="variable">$&#123;i%:*&#125;</span></span><br><span class="line"><span class="comment">#以:为分隔符去掉左边的值，*代表左边所有值</span></span><br><span class="line">    THREAD_STATUS=<span class="variable">$&#123;i#*:&#125;</span></span><br><span class="line"><span class="comment">#判断IO和SQL线程的状态是否为YES</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$THREAD_STATUS</span>&quot;</span> != <span class="string">&quot;Yes&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="comment">#如果不为YES,那么就告警</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Error: MySQL Master-Slave <span class="variable">$THREAD_STATUS_NAME</span> status is <span class="variable">$THREAD_STATUS</span>!&quot;</span> |mail -s <span class="string">&quot;Master-Slave Staus&quot;</span> lz13753705474@sina.com</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123.com -e <span class="string">&quot;show slave status\G;&quot;</span> |awk <span class="string">&#x27;/Slave_.*_Running:/ &#123;print $1$2&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">crontab -e</span><br><span class="line"><span class="comment">#每一分钟监控一次</span></span><br><span class="line">*/1 * * * * /bin/bash /root/2.sh  &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例十七DOS攻击防范脚本</title>
    <url>/2021/03/26/%E6%A1%88%E4%BE%8B%E5%8D%81%E4%B8%83dos%E6%94%BB%E5%87%BB%E9%98%B2%E8%8C%83%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Dos拒绝服务式的攻击</span><br><span class="line">点对点</span><br><span class="line">原理：tcp半连接</span><br><span class="line">c-&gt;s</span><br><span class="line">c&lt;-s</span><br><span class="line">c-&gt;s</span><br><span class="line">DDos洪水式攻击</span><br><span class="line">cc攻击  请求web页面，耗尽服务器资源</span><br><span class="line"></span><br><span class="line">ssh防暴力破解（ip，次数） </span><br><span class="line"><span class="built_in">tail</span>  /var/log/audit/audit.log </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#存放屏蔽的IP文件</span></span><br><span class="line"><span class="built_in">touch</span> /tmp/drop_ip.log</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#获取当前的时间，以nginx访问日志中的日期记录格式为准</span></span><br><span class="line">DATE=$(<span class="built_in">date</span> +%d/%b/%Y:%H:%M)</span><br><span class="line"><span class="comment">#nginx日志文件路径</span></span><br><span class="line">LOG_FILE=/usr/local/nginx/logs/default.access.log</span><br><span class="line"><span class="comment">#获取日志文件中最后5000条日志，打印其中当前1分钟访问超过10次的IP；5000条日志根据你的应用访问量评估</span></span><br><span class="line">ABNORMAL_IP=$(<span class="built_in">tail</span> -n5000 <span class="variable">$LOG_FILE</span> |grep <span class="variable">$DATE</span> |awk <span class="string">&#x27;&#123;a[$1]++&#125;END&#123;for(i in a)if(a[i]&gt;10)print i&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">#循环遍历当前1分钟访问超过10次的IP</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> <span class="variable">$ABNORMAL_IP</span>; <span class="keyword">do</span></span><br><span class="line"><span class="comment">#判断当前iptable规则中有没有这条IP的屏蔽，如果等于0的代表没有</span></span><br><span class="line">    <span class="keyword">if</span> [ $(iptables -vnL |grep -c <span class="string">&quot;<span class="variable">$IP</span>&quot;</span>) -eq 0 ]; <span class="keyword">then</span></span><br><span class="line"><span class="comment">#如果没有，那么就添加iptable规则屏蔽掉这个IP</span></span><br><span class="line">        iptables -I INPUT -s <span class="variable">$IP</span> -j DROP</span><br><span class="line"><span class="comment">#然后输出当前的时间以及屏蔽的IP到/tmp/drop_ip.log文件中</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date +&#x27;%F_%T&#x27;)</span> <span class="variable">$IP</span>&quot;</span> &gt;&gt; /tmp/drop_ip.log</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#允许IP192.168.1.1访问本机</span></span><br><span class="line">iptables -D INPUT -s 192.168.1.1 -j DROP</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例十三nginx访问日志分析</title>
    <url>/2021/03/22/%E6%A1%88%E4%BE%8B%E5%8D%81%E4%B8%89nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实现的功能</span></span><br><span class="line">访问最多的IP</span><br><span class="line">访问最多的页面</span><br><span class="line">访问页面状态码数量</span><br><span class="line">根据时间段来访问最多的IP</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 日志格式: $remote_addr - $remote_user [$time_local] &quot;$request&quot; $status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;</span></span><br><span class="line"><span class="comment">#表示位置参数</span></span><br><span class="line">LOG_FILE=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;统计访问最多的10个IP&quot;</span></span><br><span class="line"><span class="comment">#sort表示降序；-k2表示对第二列数字，-nr表示从大到小进行降序；head -10表示打印前10行，length表示统计数量</span></span><br><span class="line"><span class="comment">#解释：打印日志中访问的IP以及每个IP访问对应的次数，（并统计IP的个数，也就是UV）</span></span><br><span class="line">awk <span class="string">&#x27;&#123;a[$1]++&#125;END&#123;print &quot;UV:&quot;,length(a);for(v in a)print v,a[v]&#125;&#x27;</span> <span class="variable">$LOG_FILE</span> |<span class="built_in">sort</span> -k2 -nr |<span class="built_in">head</span> -10</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----------------------&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;统计时间段访问最多的IP&quot;</span></span><br><span class="line"><span class="comment">#打印日志中一个时间段内访问的IP以及每个IP访问对应的次数</span></span><br><span class="line">awk <span class="string">&#x27;$4&gt;=&quot;[17/Jan/2021:15:11:22 &quot; &amp;&amp; $4&lt;=&quot;[18/Jan/2021:18:11:22 &quot;&#123;a[$1]++&#125;END&#123;for(v in a)print v,a[v]&#125;&#x27;</span> <span class="variable">$LOG_FILE</span> |<span class="built_in">sort</span> -k2 -nr|<span class="built_in">head</span> -10</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----------------------&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;统计访问最多的10个页面&quot;</span></span><br><span class="line"><span class="comment">#打印日志中访问pv次数大于10次的页面的url以及每个页面对应的访问次数，并统计PV的次数，否则不打印。</span></span><br><span class="line">awk <span class="string">&#x27;&#123;a[$7]++&#125;END&#123;print &quot;PV:&quot;,length(a);for(v in a)&#123;if(a[v]&gt;10)print v,a[v]&#125;&#125;&#x27;</span> <span class="variable">$LOG_FILE</span> |<span class="built_in">sort</span> -k2 -nr</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----------------------&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;统计访问页面状态码数量&quot;</span></span><br><span class="line"><span class="comment">#打印日志中访问状态码超过5次的url和对应的状态码，以及对应访问url的次数</span></span><br><span class="line">awk <span class="string">&#x27;&#123;a[$7&quot; &quot;$9]++&#125;END&#123;for(v in a)&#123;if(a[v]&gt;5)print v,a[v]&#125;&#125;&#x27;</span> <span class="variable">$LOG_FILE</span> |<span class="built_in">sort</span> -k3 -nr</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例六查看网卡实时流量</title>
    <url>/2021/03/15/%E6%A1%88%E4%BE%8B%E5%85%AD%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%8D%A1%E5%AE%9E%E6%97%B6%E6%B5%81%E9%87%8F/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#$1:表示变量传参</span></span><br><span class="line">nic=<span class="variable">$1</span></span><br><span class="line"><span class="comment">#-e表示对于转义字符按相应的方式处理，如果不加-e那么对于转义字符会按普通字符处理。</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot; In ------ Out&quot;</span></span><br><span class="line"><span class="comment">#死循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line"><span class="comment">#$0~:表示某一行;$nic:表示匹配包含这个值的行;$2:第二列</span></span><br><span class="line"><span class="comment">#解释:打印包含$nic值的这一行的第二列</span></span><br><span class="line">    old_in=$(awk <span class="string">&#x27;$0~&quot;&#x27;</span><span class="variable">$nic</span><span class="string">&#x27;&quot;&#123;print $2&#125;&#x27;</span> /proc/net/dev)</span><br><span class="line"><span class="comment">#解释:打印包含$nic值的这一行的第十列</span></span><br><span class="line">    old_out=$(awk <span class="string">&#x27;$0~&quot;&#x27;</span><span class="variable">$nic</span><span class="string">&#x27;&quot;&#123;print $10&#125;&#x27;</span> /proc/net/dev)</span><br><span class="line"><span class="comment">#休眠一秒</span></span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line">    new_in=$(awk  <span class="string">&#x27;$0~&quot;&#x27;</span><span class="variable">$nic</span><span class="string">&#x27;&quot;&#123;print $2&#125;&#x27;</span> /proc/net/dev)</span><br><span class="line">    new_out=$(awk <span class="string">&#x27;$0~&quot;&#x27;</span><span class="variable">$nic</span><span class="string">&#x27;&quot;&#123;print $10&#125;&#x27;</span> /proc/net/dev)</span><br><span class="line"><span class="comment">#%.1f:表示保留一位小数;%s:表示占位符，将后面的这个值传入到前面这个占位;默认单位是比特，转换成KB;</span></span><br><span class="line"><span class="comment">#解释：打印新的值减去旧的值的差的这个值,(也就是新值和旧值之间休眠的这一秒的值,也就是实时查看的值)</span></span><br><span class="line">    <span class="keyword">in</span>=$(<span class="built_in">printf</span> <span class="string">&quot;%.1f%s&quot;</span> <span class="string">&quot;<span class="subst">$((($new_in-$old_in)</span>/1024))&quot;</span> <span class="string">&quot;KB/s&quot;</span>)</span><br><span class="line">    out=$(<span class="built_in">printf</span> <span class="string">&quot;%.1f%s&quot;</span> <span class="string">&quot;<span class="subst">$((($new_out-$new_out)</span>/1024))&quot;</span> <span class="string">&quot;KB/s&quot;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$in</span> <span class="variable">$out</span>&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例十二MySQL数据库备份</title>
    <url>/2021/03/21/%E6%A1%88%E4%BE%8B%E5%8D%81%E4%BA%8Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个名为backup的用户来备份数据</span></span><br><span class="line">create user <span class="string">&quot;backup&quot;</span>@<span class="string">&quot;localhost&quot;</span> identified by <span class="string">&quot;123.com&quot;</span>;</span><br><span class="line"><span class="comment">#授权给backup用户管理要备份的数据库的权限</span></span><br><span class="line">mysql&gt; grant all on lz.* to <span class="string">&quot;backup&quot;</span>@<span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#记录当时备份的时间</span></span><br><span class="line">DATE=$(<span class="built_in">date</span> +%F_%H-%M-%S)</span><br><span class="line"><span class="comment">#备份的主机，用户，密码以及备份到哪个目录下</span></span><br><span class="line">HOST=localhost</span><br><span class="line">USER=backup</span><br><span class="line">PASS=123.com</span><br><span class="line"><span class="comment">#创建要备份数据库所存放的目录</span></span><br><span class="line">BACKUP_DIR=/data/db_backup</span><br><span class="line"><span class="comment">#egrep表示过滤掉不备份的库</span></span><br><span class="line"><span class="comment">#遍历要备份的数据库</span></span><br><span class="line">DB_LIST=$(mysql -h<span class="variable">$HOST</span> -u<span class="variable">$USER</span> -p<span class="variable">$PASS</span> -s -e <span class="string">&quot;show databases;&quot;</span> 2&gt;/dev/null |egrep -v <span class="string">&quot;Database|information_schema|mysql|performance_schema|sys&quot;</span>)</span><br><span class="line"><span class="comment">#循环遍历的数据库</span></span><br><span class="line"><span class="keyword">for</span> DB <span class="keyword">in</span> <span class="variable">$DB_LIST</span>; <span class="keyword">do</span></span><br><span class="line"><span class="comment">#备份到/data/db_backup这个目录下，起名格式为（备份的数据库的名字加上备份的时间.sql)</span></span><br><span class="line">    BACKUP_NAME=<span class="variable">$BACKUP_DIR</span>/<span class="variable">$&#123;DB&#125;</span>_<span class="variable">$&#123;DATE&#125;</span>.sql</span><br><span class="line"><span class="comment">#判断导出的数据库是否正常，如果不正常（也就是非0），那么发送告警邮件</span></span><br><span class="line">    <span class="keyword">if</span> ! mysqldump -h<span class="variable">$HOST</span> -u<span class="variable">$USER</span> -p<span class="variable">$PASS</span> -B <span class="variable">$DB</span> &gt; <span class="variable">$BACKUP_NAME</span> 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$BACKUP_NAME</span> 备份失败!&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>分表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#记录当时备份的时间</span></span><br><span class="line">DATE=$(<span class="built_in">date</span> +%F_%H-%M-%S)</span><br><span class="line"><span class="comment">#备份的主机，用户，密码以及备份到哪个目录下</span></span><br><span class="line">HOST=localhost</span><br><span class="line">USER=backup</span><br><span class="line">PASS=123.com</span><br><span class="line"><span class="comment">#创建要备份数据库所存放的目录</span></span><br><span class="line">BACKUP_DIR=/data/db_backup</span><br><span class="line"><span class="comment">#egrep表示过滤掉不备份的库</span></span><br><span class="line"><span class="comment">#遍历要备份的数据库</span></span><br><span class="line">DB_LIST=$(mysql -h<span class="variable">$HOST</span> -u<span class="variable">$USER</span> -p<span class="variable">$PASS</span> -s -e <span class="string">&quot;show databases;&quot;</span> 2&gt;/dev/null |egrep -v <span class="string">&quot;Database|information_schema|mysql|performance_schema|sys&quot;</span>)</span><br><span class="line"><span class="comment">#循环遍历的数据库</span></span><br><span class="line"><span class="keyword">for</span> DB <span class="keyword">in</span> <span class="variable">$DB_LIST</span>; <span class="keyword">do</span></span><br><span class="line"><span class="comment">#在/data/db_backup这个目录下为要备份的数据库创建一个目录，名字格式为（备份的数据库名字加上备份的日期）</span></span><br><span class="line">    BACKUP_DB_DIR=<span class="variable">$BACKUP_DIR</span>/<span class="variable">$&#123;DB&#125;</span>_<span class="variable">$&#123;DATE&#125;</span></span><br><span class="line"><span class="comment">#判断/data/db_backup这个目录下有没有要备份的数据库的目录，如果没有那就创建要备份的数据库目录</span></span><br><span class="line">    [ ! -d <span class="variable">$BACKUP_DB_DIR</span> ] &amp;&amp; <span class="built_in">mkdir</span> -p <span class="variable">$BACKUP_DB_DIR</span> &amp;&gt;/dev/null</span><br><span class="line"><span class="comment">#查看要备份的数据库下的所有表</span></span><br><span class="line">    TABLE_LIST=$(mysql -h<span class="variable">$HOST</span> -u<span class="variable">$USER</span> -p<span class="variable">$PASS</span> -s -e <span class="string">&quot;use <span class="variable">$DB</span>;show tables;&quot;</span> 2&gt;/dev/null)</span><br><span class="line"><span class="comment">#循环遍历要备份的数据库下的所有表</span></span><br><span class="line">    <span class="keyword">for</span> TABLE <span class="keyword">in</span> <span class="variable">$TABLE_LIST</span>; <span class="keyword">do</span></span><br><span class="line"><span class="comment">#备份到/data/db_backup这个目录下的数据库的目录下，起名格式为（ 备份表的名字.sql)</span></span><br><span class="line">        BACKUP_NAME=<span class="variable">$BACKUP_DB_DIR</span>/<span class="variable">$&#123;TABLE&#125;</span>.sql </span><br><span class="line"><span class="comment">#判断导出的数据表是否正常，如果不正常（也就是非0），那么发送告警邮件</span></span><br><span class="line">        <span class="keyword">if</span> ! mysqldump -h<span class="variable">$HOST</span> -u<span class="variable">$USER</span> -p<span class="variable">$PASS</span> <span class="variable">$DB</span> <span class="variable">$TABLE</span> &gt; <span class="variable">$BACKUP_NAME</span> 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$BACKUP_NAME</span> 备份失败!&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="comment">#每三天的第一个小时第一分钟执行一次分库的备份</span></span><br><span class="line">1 1 */3 * * /bin/bash /root/12.sh  &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="comment">#每12个小时的第五分钟执行一次分表的备份</span></span><br><span class="line">5 */12 * * * /bin/bash /root/12-1.sh  &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">分　 时　 日　 月　 周　 命令</span><br><span class="line">第1列表示分钟1～59 每分钟用*或者 */1表示</span><br><span class="line">第2列表示小时1～23（0表示0点）</span><br><span class="line">第3列表示日期1～31</span><br><span class="line">第4列表示月份1～12</span><br><span class="line">第5列标识号星期0～6（0表示星期天）</span><br><span class="line">第6列要运行的命令</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例十八文件系统入侵检测</title>
    <url>/2021/03/27/%E6%A1%88%E4%BE%8B%E5%8D%81%E5%85%AB%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">对某个目录创建，删除文件监控</span><br><span class="line"></span><br><span class="line">挖矿病毒；应用程序和系统漏洞</span><br><span class="line">勒索病毒:</span><br><span class="line"></span><br><span class="line">可执行文件/usr/bin 串改 注入</span><br><span class="line">网站根目录/wwwroot 串改 注入</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装inotify-tools工具</span></span><br><span class="line">wget -O /etc/yum.repos.d/epel-7.repo  http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line"></span><br><span class="line">yum -y install inotify-tools</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">inotifywait</span><br><span class="line">    用法：inotifywait [-hcmrq] [-e &lt;event&gt; ] [-t &lt;seconds&gt; ] [--format &lt;<span class="built_in">fmt</span>&gt; ] [--timefmt &lt;<span class="built_in">fmt</span>&gt; ] &lt;file&gt; [ ... ]</span><br><span class="line">    选项：</span><br><span class="line">      -m：监视</span><br><span class="line">      -r：递归监视</span><br><span class="line">      -q：减少冗余信息</span><br><span class="line">      -e/--event：要监视的事件列表；</span><br><span class="line">        可监视的事件：create，delete，modify，move，access，attrib（元数据被修改），open，close</span><br><span class="line">      -t seconds：过期时长，即超出该时长退出监视，缺省为0，表示无限期监视</span><br><span class="line">      --format：指定事件信息的输出格式</span><br><span class="line">        %w：发生事件的目录或文件</span><br><span class="line">        %f：发生事件的文件</span><br><span class="line">        %e：发生的事件</span><br><span class="line">        %T：使用由-timefmt定义的时间格式</span><br><span class="line">      --timefmt：指定时间格式，具体用法可man inotifywait</span><br><span class="line">      --exclude &lt;pattern&gt;：指定排除不需要监视的文件模式</span><br><span class="line">      --fromfile &lt;file&gt;：从file中读取要监视或排除监视的文件（或目录），一行一个，不能使用正则表达式，以@开头的表示排除监视</span><br><span class="line">    例：inotifywait -mrq --timefmt <span class="string">&#x27;%Y/%m/%d-%H:%M:%S&#x27;</span> --format <span class="string">&#x27;%T %w %f %e&#x27;</span> -e modify,delete,create,move,attrib /tmp/test</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#指定要监控的目录</span></span><br><span class="line">MON_DIR=/opt</span><br><span class="line"><span class="comment">#持续递归监视发生事件的文件，-e实时打印监听的文件，\换行</span></span><br><span class="line">inotifywait -mqr --format %f -e create <span class="variable">$MON_DIR</span> |\</span><br><span class="line"><span class="comment">#读取接收事件产生的文件</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> files; <span class="keyword">do</span></span><br><span class="line"><span class="comment">#/opt 与/tmp/opt下产生的文件保持实时同步（例如实时备份的场景可以用到）</span></span><br><span class="line">   rsync -avz /opt /tmp/opt</span><br><span class="line">   <span class="comment">#echo &quot;$(date +&#x27;%F %T&#x27;) create $files&quot; | mail -s &quot;dir monitor&quot; xxx@163.com</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#后台保持实时运行</span></span><br><span class="line"><span class="built_in">nohup</span> bash 18.sh &amp;&gt;/dev/null &amp;</span><br><span class="line">ps -ef |grep 18.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例十五自动发布JAVA项目（tomcat）</title>
    <url>/2021/03/24/%E6%A1%88%E4%BE%8B%E5%8D%81%E4%BA%94%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83java%E9%A1%B9%E7%9B%AE-tomcat/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先部署jdk，apache-tomcat,git,maven环境</span></span><br><span class="line">jdk安装地址:https://www.cnblogs.com/mrfo/p/10223277.html</span><br><span class="line">apache-tomcat安装地址：wget https://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.61/bin/apache-tomcat-8.5.61.tar.gz</span><br><span class="line">yum -y install git </span><br><span class="line">yum -y install unzip</span><br><span class="line">maven安装地址：wget https://mirrors.bfsu.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz</span><br><span class="line"><span class="comment">#创建一个备份目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /data/backup</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">配置jdk以及maven的环境变量</span><br><span class="line"><span class="built_in">cat</span> /etc/profile</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/jdk1.8</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:/usr/local/maven3.6/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#获取当前的时间</span></span><br><span class="line">DATE=$(<span class="built_in">date</span> +%F_%T)</span><br><span class="line"><span class="comment">#tomcat名称，也就是/usr/local/tomcat，这里的tomcat取名为tomcat（实际环境可能有多个tomcat实例，根据tomcat的唯一名称来进行传参）</span></span><br><span class="line">TOMCAT_NAME=<span class="variable">$1</span></span><br><span class="line"><span class="comment">#tomcat安装目录</span></span><br><span class="line">TOMCAT_DIR=/usr/local/<span class="variable">$TOMCAT_NAME</span></span><br><span class="line"><span class="comment">#tomcat网站根目录</span></span><br><span class="line">ROOT=<span class="variable">$TOMCAT_DIR</span>/webapps/ROOT</span><br><span class="line"><span class="comment">#数据备份到/data/backup这个目录下</span></span><br><span class="line">BACKUP_DIR=/data/backup</span><br><span class="line"><span class="comment">#临时去拉代码工作的目录</span></span><br><span class="line">WORK_DIR=/tmp</span><br><span class="line"><span class="comment">#项目名称，github指定的名称</span></span><br><span class="line">PROJECT_NAME=tomcat-java-demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取代码</span></span><br><span class="line"><span class="comment">#切到临时目录下</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$WORK_DIR</span></span><br><span class="line"><span class="comment">#判断当前下有没有项目名称目录，那么没有就会去github克隆项目到当前目录</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$PROJECT_NAME</span> ]; <span class="keyword">then</span></span><br><span class="line">   git <span class="built_in">clone</span> https://github.com/lizhenliang/tomcat-java-demo</span><br><span class="line"><span class="comment">#切到项目名称目录</span></span><br><span class="line">   <span class="built_in">cd</span> <span class="variable">$PROJECT_NAME</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">cd</span> <span class="variable">$PROJECT_NAME</span></span><br><span class="line"><span class="comment">#否则有的话，就去增量拉取</span></span><br><span class="line">   git pull</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建</span></span><br><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line"><span class="comment">#判断当前maven是否构建成功，如果上一条命令执行失败，也就是非0，那么就退出当前脚本</span></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;maven build failure!&quot;</span></span><br><span class="line">   <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line"><span class="comment">#获取tomcat的pid     egrep取反</span></span><br><span class="line">TOMCAT_PID=$(ps -ef |grep <span class="string">&quot;<span class="variable">$TOMCAT_NAME</span>&quot;</span> |egrep -v <span class="string">&quot;grep|$$&quot;</span> |awk <span class="string">&#x27;NR==1&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">#如果tomcat的pid不为空，也就是tomcat是启动的，那么就（kill)杀死它</span></span><br><span class="line">[ -n <span class="string">&quot;<span class="variable">$TOMCAT_PID</span>&quot;</span> ] &amp;&amp; <span class="built_in">kill</span> -9 <span class="variable">$TOMCAT_PID</span></span><br><span class="line"><span class="comment">#判断tomcat的网站根目录ROOT有没有在，有的话移动到备份目录/data/backup这个目录下，起名格式为（tomcat名称加ROOT加时间）</span></span><br><span class="line">[ -d <span class="variable">$ROOT</span> ] &amp;&amp; <span class="built_in">mv</span> <span class="variable">$ROOT</span> <span class="variable">$BACKUP_DIR</span>/<span class="variable">$&#123;TOMCAT_NAME&#125;</span>_ROOT<span class="variable">$DATE</span></span><br><span class="line"><span class="comment">#通过unzip命令解压临时目录/tmp下的项目名称目录下的target目录下的war包 到网站根目录</span></span><br><span class="line">unzip <span class="variable">$WORK_DIR</span>/<span class="variable">$PROJECT_NAME</span>/target/*.war -d <span class="variable">$ROOT</span></span><br><span class="line"><span class="comment">#最后启动tomcat</span></span><br><span class="line"><span class="variable">$TOMCAT_DIR</span>/bin/startup.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行脚本</span></span><br><span class="line"><span class="comment">#./15.sh tomcat </span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">访问：</span><br><span class="line"><span class="comment">#tomcat默认端口8080</span></span><br><span class="line">http://192.168.1.2:8080</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例十四nginx访问日志分析与切割</title>
    <url>/2021/03/23/%E6%A1%88%E4%BE%8B%E5%8D%81%E5%9B%9Bnginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%87%E5%89%B2/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#移动nginx的默认日志文件到/tmp下</span></span><br><span class="line"><span class="built_in">mv</span> /usr/local/nginx/logs/default.access.log /tmp/</span><br><span class="line"><span class="comment">#发送一个信号，nginx会生成一个日志文件default.access.log</span></span><br><span class="line"><span class="built_in">kill</span> -USR1 $(<span class="built_in">cat</span> /var/run/nginx.pid)</span><br><span class="line"><span class="comment">#再次查看default.access.log会为空</span></span><br><span class="line"><span class="built_in">cat</span> /usr/local/nginx/logs/default.access.log </span><br><span class="line"></span><br><span class="line"><span class="comment">#然后访问页面，重新生成日志</span></span><br><span class="line"><span class="comment">#然后执行脚本文件会在log目录下创建一个月份的目录，log目录下的default.access.log文件就为空，月份目录下就是每天进行切割归档的日志文件</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义当前nginx日志的目录路径</span></span><br><span class="line">LOG_DIR=/usr/local/nginx/logs</span><br><span class="line"><span class="comment">#获取前一天的时间（零点执行的话）</span></span><br><span class="line">YESTERDAY_TIME=$(<span class="built_in">date</span> -d <span class="string">&quot;yesterday&quot;</span> +%F)</span><br><span class="line"><span class="comment">#在nginx的log目录下创建一个按月份的归档目录，月份目录下就是每天的日志</span></span><br><span class="line">LOG_MONTH_DIR=<span class="variable">$LOG_DIR</span>/$(<span class="built_in">date</span> +<span class="string">&quot;%Y-%m&quot;</span>)</span><br><span class="line"><span class="comment">#nginx默认记录日志的一个文件</span></span><br><span class="line">LOG_FILE_LIST=<span class="string">&quot;default.access.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> LOG_FILE <span class="keyword">in</span> <span class="variable">$LOG_FILE_LIST</span>; <span class="keyword">do</span></span><br><span class="line"><span class="comment">#如果当前月目录文件不存在，那么它会帮你创建</span></span><br><span class="line">    [ ! -d <span class="variable">$LOG_MONTH_DIR</span> ] &amp;&amp; <span class="built_in">mkdir</span> -p <span class="variable">$LOG_MONTH_DIR</span></span><br><span class="line"><span class="comment">#当前在log目录下生成的日志文件移动到创建的月份目录下，起名格式为（归档日志文件的名字加上归档日志的日期）</span></span><br><span class="line">    <span class="built_in">mv</span> <span class="variable">$LOG_DIR</span>/<span class="variable">$LOG_FILE</span> <span class="variable">$LOG_MONTH_DIR</span>/<span class="variable">$&#123;LOG_FILE&#125;</span>_<span class="variable">$&#123;YESTERDAY_TIME&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#发送一个信号，nginx会生成一个日志文件default.access.log</span></span><br><span class="line"><span class="built_in">kill</span> -USR1 $(<span class="built_in">cat</span> /var/run/nginx.pid)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="comment">#每天的0点0分执行归档日志的切割</span></span><br><span class="line">0 0 * * *  /bin/bash /root/14.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx 403问题 https://www.cnblogs.com/williamjie/p/9604594.html</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例十六自动发布PHP项目</title>
    <url>/2021/03/25/%E6%A1%88%E4%BE%8B%E5%8D%81%E5%85%AD%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83php%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">环境：lnmp环境</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#记录当时的时间</span></span><br><span class="line">DATE=$(<span class="built_in">date</span> +%F_%T)</span><br><span class="line"><span class="comment">#网站根目录（指定传参的形式,根据某个项目去指定)</span></span><br><span class="line">WWWROOT=/usr/local/nginx/html/<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据备份目录</span></span><br><span class="line">BACKUP_DIR=/data/backup</span><br><span class="line"><span class="comment">#临时工作目录</span></span><br><span class="line">WORK_DIR=/tmp</span><br><span class="line"><span class="comment">#项目名称</span></span><br><span class="line">PROJECT_NAME=php-demo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取代码</span></span><br><span class="line"><span class="comment">#切到临时目录下</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$WORK_DIR</span></span><br><span class="line"><span class="comment">#判断当前下有没有项目名称目录，那么没有就会去github克隆项目到当前目录</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$PROJECT_NAME</span> ]; <span class="keyword">then</span></span><br><span class="line">   git <span class="built_in">clone</span> https://github.com/lizhenliang/php-demo</span><br><span class="line"><span class="comment">#切到项目名称目录</span></span><br><span class="line">   <span class="built_in">cd</span> <span class="variable">$PROJECT_NAME</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">cd</span> <span class="variable">$PROJECT_NAME</span></span><br><span class="line"><span class="comment">#否则有的话，就去增量拉取</span></span><br><span class="line">   git pull</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line"><span class="comment">#判断当前网站的根目录是否存在，如果没有那就去创建</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$WWWROOT</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">mkdir</span> -p <span class="variable">$WWWROOT</span></span><br><span class="line">   rsync -avz --exclude=.git <span class="variable">$WORK_DIR</span>/<span class="variable">$PROJECT_NAME</span>/* <span class="variable">$WWWROOT</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">#rsync数据同步工具，增量同步（php项目不需要编译，实际环境都是增量	去发布的）</span></span><br><span class="line"><span class="comment">#将临时目录/tmp/项目名称目录下的数据增量同步到网站根目录</span></span><br><span class="line">   rsync -avz --exclude=.git <span class="variable">$WORK_DIR</span>/<span class="variable">$PROJECT_NAME</span>/* <span class="variable">$WWWROOT</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行</span></span><br><span class="line">bash 16.sh demo1</span><br><span class="line">bash 16.sh demo2</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">访问：</span><br><span class="line"><span class="comment">#项目1和项目2</span></span><br><span class="line">http://192.168.1.2/demo1/index.html</span><br><span class="line">http://192.168.1.2/demo2/index.html</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例四一键查看服务器利用率</title>
    <url>/2021/03/13/%E6%A1%88%E4%BE%8B%E5%9B%9B%E4%B8%80%E9%94%AE%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%A9%E7%94%A8%E7%8E%87/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment">#function是一个函数,可以省略不写,后面是函数名;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">cpu</span></span>() &#123;</span><br><span class="line"><span class="comment">#use变量名,vmstat命令是查看cpu信息的,NR代表的是行,$1,2..代表的是列;</span></span><br><span class="line"><span class="comment">#解释:判断NR是不是第三行,如果是打印第十三列和第十四列的值,以此类推;</span></span><br><span class="line">	use=$(vmstat |awk <span class="string">&#x27;&#123;if (NR==3)print $13+$14&#125;&#x27;</span>)</span><br><span class="line">	iowait=$(vmstat |awk <span class="string">&#x27;&#123;if (NR==3)print $16&#125;&#x27;</span>)</span><br><span class="line">	user=$(vmstat |awk <span class="string">&#x27;&#123;if (NR==3)print $13&#125;&#x27;</span>)</span><br><span class="line">	sys=$(vmstat |awk <span class="string">&#x27;&#123;if (NR==3)print $14&#125;&#x27;</span>)</span><br><span class="line">	<span class="built_in">echo</span>  <span class="string">&quot;cpu - 使用率: <span class="variable">$&#123;user&#125;</span>% , 等待磁盘IO响应使用率: <span class="variable">$&#123;iowait&#125;</span>% &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">memory</span></span>() &#123;</span><br><span class="line"><span class="comment">#free -m命令是查看内存的,以M为单位;printf是格式化输出,光标定位在最后一个字符之后;</span></span><br><span class="line"><span class="comment">#解释:判断NR是不是第二行,如果是打印第二列的值,转换为G单位,保留一位小数;</span></span><br><span class="line">	total=$(free -m |awk <span class="string">&#x27;&#123;if (NR==2) printf &quot;%.1f&quot;,$2/1024&#125;&#x27;</span>)</span><br><span class="line">	used=$(free -m |awk <span class="string">&#x27;&#123;if (NR==2) printf &quot;%.1f&quot;,($2-$NF)/1024&#125;&#x27;</span>)</span><br><span class="line">	available=$(free -m |awk <span class="string">&#x27;&#123;if (NR==2) printf &quot;%.1f&quot;,$NF/1024&#125;&#x27;</span>)</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;内存 - 总大小: <span class="variable">$&#123;total&#125;</span>G , 已使用: <span class="variable">$&#123;used&#125;</span>G , 剩余: <span class="variable">$&#123;available&#125;</span>G &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">disk</span></span> ()&#123;</span><br><span class="line"><span class="comment">#df -h命令是查看磁盘的;</span></span><br><span class="line"><span class="comment">#解释:打印出第一列中以/dev/开头的值;^:以/dev/开头;\指转义符，屏蔽下一个字符的特殊意义;</span></span><br><span class="line">	dev=$(<span class="built_in">df</span> -h |awk <span class="string">&#x27;/^\/dev/&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable">$dev</span>; <span class="keyword">do</span></span><br><span class="line"><span class="comment">#解释:-v:变量赋值;$NF:最后一列</span></span><br><span class="line"><span class="comment">#解释:判断s是不是第一列以/dev/开头的其中的一个值，如果是打印最后一列的值;</span></span><br><span class="line">		mounted=$(<span class="built_in">df</span> -h |awk -v s=<span class="variable">$p</span> <span class="string">&#x27;s==$1&#123;print $NF&#125;&#x27;</span> )</span><br><span class="line">		size=$(<span class="built_in">df</span> -h |awk -v s=<span class="variable">$p</span> <span class="string">&#x27;s==$1&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">		used=$(<span class="built_in">df</span> -h |awk -v s=<span class="variable">$p</span> <span class="string">&#x27;s==$1&#123;print $3&#125;&#x27;</span>)</span><br><span class="line">		used_percent=$(<span class="built_in">df</span> -h |awk -v s=<span class="variable">$p</span> <span class="string">&#x27;s==$1&#123;print $5&#125;&#x27;</span>)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;硬盘 - 挂载点： <span class="variable">$mounted</span> , 总大小: <span class="variable">$size</span> , 已使用: <span class="variable">$used</span> , 使用率: <span class="variable">$used_percent</span> &quot;</span></span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">tcp_status</span></span>()&#123;</span><br><span class="line"><span class="comment">#解释:[$6]:数组为第六列的值,++:每遇见一次一样的值都加1;a:统计数组中不同类别的值对应的个数;</span></span><br><span class="line"><span class="comment">#解释:打印出第六列中不同类别的值以及值对应的个数;</span></span><br><span class="line">		status=$(netstat -anpt | awk <span class="string">&#x27;&#123;a[$6]++&#125;END&#123;for (i in a) printf i &quot;:&quot; a[i]&quot; &quot;&#125;&#x27;</span>)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;TCP连接状态 - <span class="variable">$status</span> &quot;</span></span><br><span class="line">&#125;</span><br><span class="line">cpu</span><br><span class="line">memory</span><br><span class="line">disk</span><br><span class="line">tcp_status</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>案例十部署LNMP网站平台</title>
    <url>/2021/03/19/%E6%A1%88%E4%BE%8B%E5%8D%81%E9%83%A8%E7%BD%B2lnmp%E7%BD%91%E7%AB%99%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#nginx配置文件</span></span><br><span class="line"><span class="comment">#vim nginx.conf </span></span><br><span class="line"></span><br><span class="line">user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line">error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        access_log  logs/default.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            root           html;</span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">NGINX_V=1.15.6</span><br><span class="line">PHP_V=5.6.36</span><br><span class="line">TMP_DIR=/tmp</span><br><span class="line"></span><br><span class="line">INSTALL_DIR=/usr/local</span><br><span class="line"></span><br><span class="line">PWD_C=<span class="variable">$PWD</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\tMenu\n&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;1. Install Nginx&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;2. Install PHP&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;3. Install MySQL&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;4. Deploy LNMP&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;9. Quit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">command_status_check</span></span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line">		<span class="built_in">exit</span></span><br><span class="line">	<span class="keyword">fi</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">install_nginx</span></span>() &#123;</span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$TMP_DIR</span></span><br><span class="line">    yum install -y gcc gcc-c++ make openssl-devel pcre-devel wget</span><br><span class="line">    wget http://nginx.org/download/nginx-<span class="variable">$&#123;NGINX_V&#125;</span>.tar.gz</span><br><span class="line">    tar zxf nginx-<span class="variable">$&#123;NGINX_V&#125;</span>.tar.gz</span><br><span class="line">    <span class="built_in">cd</span> nginx-<span class="variable">$&#123;NGINX_V&#125;</span></span><br><span class="line">    ./configure --prefix=<span class="variable">$INSTALL_DIR</span>/nginx \</span><br><span class="line">    --with-http_ssl_module \</span><br><span class="line">    --with-http_stub_status_module \</span><br><span class="line">    --with-stream</span><br><span class="line">    command_status_check <span class="string">&quot;Nginx - 平台环境检查失败！&quot;</span></span><br><span class="line">    make -j 4 </span><br><span class="line">    command_status_check <span class="string">&quot;Nginx - 编译失败！&quot;</span></span><br><span class="line">    make install</span><br><span class="line">    command_status_check <span class="string">&quot;Nginx - 安装失败！&quot;</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p <span class="variable">$INSTALL_DIR</span>/nginx/conf/vhost</span><br><span class="line">    <span class="built_in">alias</span> <span class="built_in">cp</span>=<span class="built_in">cp</span> ; <span class="built_in">cp</span> -rf <span class="variable">$PWD_C</span>/nginx.conf <span class="variable">$INSTALL_DIR</span>/nginx/conf</span><br><span class="line">    <span class="built_in">rm</span> -rf <span class="variable">$INSTALL_DIR</span>/nginx/html/*</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;ok&quot;</span> &gt; <span class="variable">$INSTALL_DIR</span>/nginx/html/status.html</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;&lt;?php echo &quot;ok&quot;?&gt;&#x27;</span> &gt; <span class="variable">$INSTALL_DIR</span>/nginx/html/status.php</span><br><span class="line">    <span class="variable">$INSTALL_DIR</span>/nginx/sbin/nginx</span><br><span class="line">    command_status_check <span class="string">&quot;Nginx - 启动失败！&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">install_php</span></span>() &#123;</span><br><span class="line">	<span class="built_in">cd</span> <span class="variable">$TMP_DIR</span></span><br><span class="line">    yum install -y gcc gcc-c++ make gd-devel libxml2-devel \</span><br><span class="line">        libcurl-devel libjpeg-devel libpng-devel openssl-devel \</span><br><span class="line">        libmcrypt-devel libxslt-devel libtidy-devel</span><br><span class="line">    wget http://docs.php.net/distributions/php-<span class="variable">$&#123;PHP_V&#125;</span>.tar.gz</span><br><span class="line">    tar zxf php-<span class="variable">$&#123;PHP_V&#125;</span>.tar.gz</span><br><span class="line">    <span class="built_in">cd</span> php-<span class="variable">$&#123;PHP_V&#125;</span></span><br><span class="line">    ./configure --prefix=<span class="variable">$INSTALL_DIR</span>/php \</span><br><span class="line">    --with-config-file-path=<span class="variable">$INSTALL_DIR</span>/php/etc \</span><br><span class="line">    --enable-fpm --enable-opcache \</span><br><span class="line">    --with-mysql --with-mysqli --with-pdo-mysql \</span><br><span class="line">    --with-openssl --with-zlib --with-curl --with-gd \</span><br><span class="line">    --with-jpeg-dir --with-png-dir --with-freetype-dir \</span><br><span class="line">    --enable-mbstring --enable-hash</span><br><span class="line">    command_status_check <span class="string">&quot;PHP - 平台环境检查失败！&quot;</span></span><br><span class="line">    make -j 4 </span><br><span class="line">    command_status_check <span class="string">&quot;PHP - 编译失败！&quot;</span></span><br><span class="line">    make install</span><br><span class="line">    command_status_check <span class="string">&quot;PHP - 安装失败！&quot;</span></span><br><span class="line">    <span class="built_in">cp</span> php.ini-production <span class="variable">$INSTALL_DIR</span>/php/etc/php.ini</span><br><span class="line">    <span class="built_in">cp</span> sapi/fpm/php-fpm.conf <span class="variable">$INSTALL_DIR</span>/php/etc/php-fpm.conf</span><br><span class="line">    <span class="built_in">cp</span> sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm</span><br><span class="line">    <span class="built_in">chmod</span> +x /etc/init.d/php-fpm</span><br><span class="line">    /etc/init.d/php-fpm start</span><br><span class="line">    command_status_check <span class="string">&quot;PHP - 启动失败！&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入编号：&quot;</span> number</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$number</span> <span class="keyword">in</span></span><br><span class="line">    1)</span><br><span class="line">        install_nginx;;</span><br><span class="line">    2)</span><br><span class="line">        install_php;;</span><br><span class="line">    3)</span><br><span class="line">        install_mysql;;</span><br><span class="line">    4)</span><br><span class="line">        install_nginx</span><br><span class="line">        install_php</span><br><span class="line">        ;;</span><br><span class="line">    9)</span><br><span class="line">        <span class="built_in">exit</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">验证：</span><br><span class="line">ps -ef |grep nginx </span><br><span class="line">ps -ef |grep php</span><br><span class="line">curl 127.0.0.1/status.html</span><br><span class="line">curl 127.0.0.1/status.php</span><br><span class="line"><span class="built_in">ls</span> /usr/local/nginx/</span><br><span class="line"><span class="built_in">ls</span> /usr/local/php/</span><br><span class="line"><span class="built_in">ls</span> /usr/local/nginx/html/</span><br><span class="line">vim /usr/local/nginx/html/phpinfo.php</span><br><span class="line">&lt;?php phpinfo();?&gt;</span><br><span class="line">curl 127.0.0.1/phpinfo.php | more</span><br><span class="line"><span class="comment">#php安装一些模块</span></span><br><span class="line">/usr/local/php/bin/php -m</span><br><span class="line"><span class="comment">#php的版本</span></span><br><span class="line">/usr/local/php/bin/php -v</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Pod对象：基本管理</title>
    <url>/2022/06/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3pod%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="Pod基本概念">Pod基本概念</h2>
<p>Pod是Kubernetes创建和管理的最小单元，一个Pod由一个容器 或多个容器组成，这些容器共享存储、网络。</p>
<p><img src="/images/3E268FAA2D524894BEC9CE7602E5ACDFclipboard.png" alt></p>
<p>Pod特点：</p>
<ul>
<li>
<p>一个Pod可以理解为是一个应用实例，提供服务</p>
</li>
<li>
<p>Pod中容器始终部署在一个Node上</p>
</li>
<li>
<p>Pod中容器共享网络、存储资源</p>
</li>
<li>
<p>Kubernetes直接管理Pod，而不是容器</p>
</li>
</ul>
<h2 id="Pod存在的意义">Pod存在的意义</h2>
<p>Pod主要用法：</p>
<ul>
<li>
<p>运行单个容器：最常见的用法，在这种情况下，可以将Pod看做是单个容器的抽象封装</p>
</li>
<li>
<p>运行多个容器：封装多个紧密耦合且需要共享资源的应用程序</p>
</li>
</ul>
<p>如果有这些需求，你可以运行多个容器：</p>
<ul>
<li>
<p>两个应用之间发生文件交互</p>
</li>
<li>
<p>两个应用需要通过127.0.0.1或者socket通信</p>
</li>
<li>
<p>两个应用需要发生频繁的调用</p>
</li>
</ul>
<h2 id="Pod资源共享实现机制">Pod资源共享实现机制</h2>
<p><img src="/images/615C60882D224E8DB8C6C12AAD1DB9CEclipboard.png" alt></p>
<p>共享网络：将业务容器网络加入到“负责网络的容器”实现网络共享</p>
<p>测试验证是否共享网络：</p>
<p>vim pod-net.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line">  - name: <span class="built_in">test</span></span><br><span class="line">    image: busybox</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;sleep 360000&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-net.yaml </span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-pod -c <span class="built_in">test</span> -- sh   <span class="comment">#进入tets容器验证是否能访问nginx</span></span><br><span class="line">wget 127.0.0.1:80 </span><br><span class="line"><span class="built_in">cat</span> index.html      </span><br></pre></td></tr></table></figure>
<p><img src="/images/83663818D7C24666AB6C087931A7E27Bclipboard.png" alt></p>
<p>共享存储：容器通过数据卷共享数据</p>
<p>测试验证是否共享存储：</p>
<p>vim pod-vol.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod2</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web2</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: <span class="built_in">log</span></span><br><span class="line">      mountPath: /data</span><br><span class="line"></span><br><span class="line">  - name: test2</span><br><span class="line">    image: busybox</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;sleep 360000&quot;</span>]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: <span class="built_in">log</span></span><br><span class="line">      mountPath: /data</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: <span class="built_in">log</span></span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-vol.yaml </span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-pod2 -c test2 -- sh     <span class="comment">#进入test容器在/data目录下创建文件</span></span><br><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line"><span class="built_in">touch</span> 1.txt</span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-pod2 -c web2 -- bash   <span class="comment">#进入web2容器/data目录下查看是否有1.txt</span></span><br><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<h2 id="Pod管理命令">Pod管理命令</h2>
<p>创建Pod：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod.yaml </span><br><span class="line">或者使用命令 kubectl run nginx --image=nginx </span><br></pre></td></tr></table></figure>
<p>查看Pod：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods </span><br><span class="line">kubectl describe pod &lt;pod名称&gt;</span><br></pre></td></tr></table></figure>
<p>查看日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod名称&gt; [-c CONTAINER] </span><br><span class="line">kubectl logs &lt;pod名称&gt; [-c CONTAINER] -f </span><br></pre></td></tr></table></figure>
<p>进入容器终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> &lt;pod名称&gt; [-c CONTAINER] -- bash </span><br></pre></td></tr></table></figure>
<p>删除Pod：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete &lt;pod名称&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/images/D3AF0D4278F7416FA89311678BF55FBDclipboard.png" alt></p>
<h2 id="重启策略-健康检查（应用自修复）">重启策略+健康检查（应用自修复）</h2>
<p><img src="/images/61383041DB4F45189A6A194539803642clipboard.png" alt></p>
<p>重启策略：</p>
<ul>
<li>
<p>Always：当容器终止退出后，总是重启容器，默认策略。</p>
</li>
<li>
<p>OnFailure：当容器异常退出（退出状态码非0）时，才重启容器。</p>
</li>
<li>
<p>Never：当容器终止退出，从不重启容器</p>
</li>
</ul>
<p>健康检查有以下两种类型：</p>
<ul>
<li>
<p>livenessProbe（存活检查）：如果检查失败，将杀死容器，根据Pod 的restartPolicy来操	    作。</p>
</li>
<li>
<p>readinessProbe（就绪检查）：如果检查失败，Kubernetes会把 Pod从service endpoints中剔除。</p>
</li>
<li>
<p>startupProbe（启动检查）：</p>
</li>
</ul>
<p>支持以下三种检查方法：</p>
<ul>
<li>
<p>httpGet：发送HTTP请求，返回200-400范围状态码为成功。</p>
</li>
<li>
<p>exec：执行Shell命令返回状态码是0为成功。</p>
</li>
<li>
<p>tcpSocket：发起TCP Socket建立成功</p>
</li>
</ul>
<p>参考链接：<a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</a></p>
<p>测试验证：</p>
<p>vim pod-check.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    <span class="built_in">test</span>: liveness</span><br><span class="line">  name: pod-check</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - <span class="built_in">touch</span> /tmp/healthy; <span class="built_in">sleep</span> 30; <span class="built_in">rm</span> -rf /tmp/healthy; <span class="built_in">sleep</span> 600</span><br><span class="line">    livenessProbe:</span><br><span class="line">      <span class="built_in">exec</span>:</span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - <span class="built_in">cat</span></span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 5</span><br><span class="line">    readinessProbe:</span><br><span class="line">      <span class="built_in">exec</span>:</span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - <span class="built_in">cat</span></span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5     <span class="comment">##启动容器后多少秒健康检查</span></span><br><span class="line">      periodSeconds: 5           <span class="comment">##以后间隔多少秒检查一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-check.yaml</span><br><span class="line">kubectl expose pod pod-check --port 80 --target-port=80</span><br><span class="line">kubectl get pod -w           <span class="comment">#实时验证pod的重启次数是否增加</span></span><br><span class="line">kubectl get endpoints -w     <span class="comment">#实时验证pod是否被service剔除</span></span><br><span class="line">kubectl describe pod pod-check  <span class="comment">#查看pod的变化信息</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/619AB9E4410C495098F4F286EC63B2FBclipboard.png" alt></p>
<p><img src="/images/3D917C45F9F8485CBA8164C9A519E60Bclipboard.png" alt></p>
<p>示例：端口探测</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: probe-demo</span><br><span class="line">  namespace: demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    readinessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /</span><br><span class="line">        port: 80</span><br><span class="line">      initialDelaySeconds: 30 <span class="comment">#启动容器后多少秒健康检查</span></span><br><span class="line">      periodSeconds: 10 <span class="comment">#以后间隔多少秒检查一次</span></span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /</span><br><span class="line">        port: 80</span><br><span class="line">      initialDelaySeconds: 30 <span class="comment">#启动容器后多少秒健康检查</span></span><br><span class="line">      periodSeconds: 10 <span class="comment">#以后间隔多少秒检查一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：livenessProbe与readinessProbe配置一样。</p>
<p>示例：执行Shell命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  <span class="built_in">exec</span>:</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    - <span class="built_in">cat</span></span><br><span class="line">    - /tmp/healthy</span><br></pre></td></tr></table></figure>
<p>示例：HTTP请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  httpGet:</span><br><span class="line">    path: /healthz</span><br><span class="line">    port: 8080</span><br><span class="line">    httpHeaders:</span><br><span class="line">    - name: Custom-Header</span><br><span class="line">      value: Awesome</span><br></pre></td></tr></table></figure>
<h2 id="环境变量">环境变量</h2>
<p>变量值几种定义方式：</p>
<ul>
<li>
<p>自定义变量值</p>
</li>
<li>
<p>变量值从Pod属性获取</p>
</li>
<li>
<p>变量值从Secret、ConfigMap获取</p>
</li>
</ul>
<p>示例</p>
<p>vim pod-var.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-envars</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: <span class="built_in">test</span></span><br><span class="line">      image: busybox</span><br><span class="line">      <span class="built_in">command</span>: [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 36000&quot;</span>]</span><br><span class="line">      <span class="built_in">env</span>:</span><br><span class="line">      - name: MY_NODE_NAME</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: spec.nodeName</span><br><span class="line">      - name: MY_POD_NAME</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: metadata.name</span><br><span class="line">      - name: MY_POD_NAMESPACE</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: metadata.namespace</span><br><span class="line">      - name: MY_POD_IP</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: status.podIP</span><br><span class="line">      - name: ABC</span><br><span class="line">        value: <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-var.yaml </span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod-envars -- sh</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<p><img src="/images/4DA5F5128F174CD0BDF4FD1B2B0EF9C0clipboard.png" alt></p>
<h2 id="Init-Container">Init Container</h2>
<p>Init Container：顾名思义，用于初始化工作，执行完就结束，可以理解为一次性任务。</p>
<ul>
<li>
<p>支持大部分应用容器配置，但不支持健康检查</p>
</li>
<li>
<p>优先应用容器执行</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>
<p>环境检查：例如确保应用容器依赖的服务启动后再启动应用容器</p>
</li>
<li>
<p>初始化配置：例如给应用容器准备配置文件</p>
</li>
</ul>
<p>示例：</p>
<p>部署一个web网站，网站程序没有打到镜像中，而是希望从代码 仓库中动态拉取放到应用容器中。</p>
<p>vim pod-init.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: init-demo</span><br><span class="line">spec:</span><br><span class="line">  initContainers:</span><br><span class="line">  - name: download</span><br><span class="line">    image: busybox</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    - wget</span><br><span class="line">    - <span class="string">&quot;-O&quot;</span></span><br><span class="line">    - <span class="string">&quot;/opt/index.html&quot;</span></span><br><span class="line">    - http://www.ctnrs.com</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: wwwroot</span><br><span class="line">      mountPath: <span class="string">&quot;/opt&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: wwwroot</span><br><span class="line">      mountPath: /usr/share/nginx/html</span><br><span class="line">  volumes:</span><br><span class="line">  - name: wwwroot</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-init.yaml </span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl describe pod init-demo </span><br><span class="line">kubectl <span class="built_in">exec</span> -it init-demo -- bash</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<p><img src="/images/3A5212D0E7FE4E829F051C6E3F7E4136clipboard.png" alt></p>
<p>因此，Pod中会有这几种类型的容器：</p>
<p>Infrastructure Container：基础容器</p>
<p>维护整个Pod网络空间</p>
<p>InitContainers：初始化容器</p>
<p>先于业务容器开始执行</p>
<p>Containers：业务容器</p>
<p>并行启动</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>监控docker主机</title>
    <url>/2021/09/03/%E7%9B%91%E6%8E%A7docker%E4%B8%BB%E6%9C%BA/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">监控docker主机（暴露指标端口8080）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务端配置</span></span><br><span class="line"><span class="comment">#在Prometheus配置文件添加被监控端</span></span><br><span class="line">vim /opt/monitor/prometheus/prometheus.yml</span><br><span class="line">scrape_configs:</span><br><span class="line">   - job_name: <span class="string">&#x27;docker&#x27;</span></span><br><span class="line">     static_configs:</span><br><span class="line">    - targets: [<span class="string">&#x27;192.168.1.13:8080&#x27;</span>,<span class="string">&#x27;192.168.1.11:8080&#x27;</span>]</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">#配置完成后，使用promtool工具检查配置文件是否有误</span></span><br><span class="line"><span class="built_in">cd</span> /opt/monitor/prometheus</span><br><span class="line">./promtool check config ./prometheus.yml </span><br><span class="line"><span class="comment">#查看prometheus的进程id,上面修改配置进行热加载配置</span></span><br><span class="line">ps -ef |grep prometheus</span><br><span class="line"><span class="built_in">kill</span> -HUP 62291 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker主机配置（被监控端）</span></span><br><span class="line"><span class="comment">#配置docker加速源</span></span><br><span class="line">在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://dockerhub.azk8s.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://reg-mirror.qiniu.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#cAdvisor （Container Advisor） ：用于收集正在运行的容器资源使用和性能信息。</span></span><br><span class="line"><span class="comment">#Docker部署cAdvisor：</span></span><br><span class="line">docker run -d --volume=/:/rootfs:ro --volume=/var/run:/var/run:ro --volume=/sys:/sys:ro --volume=/var/lib/docker/:/var/lib/docker:ro --volume=/dev/disk/:/dev/disk:ro --publish=8080:8080 --detach=<span class="literal">true</span> --name=cadvisor google/cadvisor:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/02ABEC7EC0084E8389E683469EDCD7B6clipboard.png" alt></p>
<p>添加选择多节点按钮</p>
<p><img src="/images/AAE00B83F9834EFC9FD68F6A5076FABFclipboard.png" alt></p>
<p>图表增加筛选条件</p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Pod对象：调度</title>
    <url>/2022/06/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3pod%E5%AF%B9%E8%B1%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="创建一个Pod的工作流程">创建一个Pod的工作流程</h2>
<p>Kubernetes基于list-watch机制的控制器架构，实现组件间交 互的解耦。 其他组件监控自己负责的资源，当这些资源发生变化时，kubeapiserver会通知这些组件，这个过程类似于发布与订阅。</p>
<p><img src="/images/D8794DF48C0F4816BA54E7FA97CDBB36clipboard.png" alt></p>
<h2 id="Pod中影响调度的主要属性">Pod中影响调度的主要属性</h2>
<p><img src="/images/8AF33B3162AB4F3D882A6D2D180DC683clipboard.png" alt></p>
<h2 id="资源限制对Pod调度的影响">资源限制对Pod调度的影响</h2>
<p>容器资源限制：</p>
<ul>
<li>
<p>resources.limits.cpu</p>
</li>
<li>
<p>resources.limits.memory</p>
</li>
</ul>
<p>容器使用的最小资源需求，作为容器调度时资 源分配的依据：</p>
<ul>
<li>
<p>resources.requests.cpu</p>
</li>
<li>
<p>resources.requests.memory</p>
</li>
</ul>
<p>CPU单位：可以写m也可以写浮点数，例如0.5=500m，1=1000m</p>
<p><img src="/images/221BA88F1B514916BB8177EFC3777F22clipboard.png" alt></p>
<p>K8s会根据Request的值去查找有足够资源的Node来调度此Pod</p>
<p>vim pod-resources.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-resources</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line">    resources:</span><br><span class="line">      requests:             <span class="comment">#容器最小资源配额</span></span><br><span class="line">        memory: <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        cpu: <span class="string">&quot;250m&quot;</span></span><br><span class="line">      limits:               <span class="comment">#容器最大资源上限</span></span><br><span class="line">        memory: <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        cpu: <span class="string">&quot;500m&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-resources.yaml </span><br><span class="line">kubectl describe pod pod-resources </span><br><span class="line">kubectl describe nodes  k8s-node1</span><br><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure>
<h2 id="nodeSelector-nodeAffinity">nodeSelector &amp; nodeAffinity</h2>
<p>nodeSelector：用于将Pod调度到匹配Label的Node上，如果没有匹配的标签会调度失败。</p>
<p>作用：</p>
<ul>
<li>
<p>约束Pod到特定的节点运行</p>
</li>
<li>
<p>完全匹配节点标签</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>
<p>专用节点：根据业务线将Node分组管理</p>
</li>
<li>
<p>配备特殊硬件：部分Node配有SSD硬盘、GPU</p>
</li>
</ul>
<p>示例：确保Pod分配到具有SSD硬盘的节点上</p>
<p>第一步：给节点添加标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt;</span><br><span class="line">例如：kubectl label nodes k8s-node1 disktype=ssd</span><br><span class="line">验证：kubectl get nodes --show-labels</span><br></pre></td></tr></table></figure>
<p><img src="/images/A8DD05B47B464360BC6A4C9562D81BBBclipboard.png" alt></p>
<p>第二步：添加nodeSelector字段到Pod配置中</p>
<p>vim pod-selector.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-selector</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector:</span><br><span class="line">    disktype: <span class="string">&quot;ssd&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-selector.yaml </span><br><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure>
<p><img src="/images/5B3E454BCE9B4228A079570CF0D7D7F0clipboard.png" alt></p>
<p>示例：使Pod分配到gpu是NVIDIA的节点上，k8s节点中并没有这个标签的节点</p>
<p>vim pod-selector2.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-selector2</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector:</span><br><span class="line">    gpu: <span class="string">&quot;NVIDIA&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-selector2.yaml </span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl describe pod pod-selector2 </span><br></pre></td></tr></table></figure>
<p><img src="/images/825563AE4A8E4FB1A54BDE56BAB0FCA0clipboard.png" alt></p>
<p><img src="/images/AE756360AFBA4009A26073FD733BC33Aclipboard.png" alt></p>
<p>nodeAffinity：节点亲和性，与nodeSelector作用一样，但相比 更灵活，满足更多条件，诸如：</p>
<ul>
<li>
<p>匹配有更多的逻辑组合，不只是字符串的完全相等</p>
</li>
<li>
<p>调度分为软策略和硬策略，而不是硬性要求</p>
</li>
<li>
<p>硬（required）：必须满足</p>
</li>
<li>
<p>软（preferred）：尝试满足，但不保证</p>
</li>
</ul>
<p>操作符：In、NotIn、Exists、DoesNotExist、Gt、Lt</p>
<p>示例：在pod满足硬性标签要求的前提下，如果没有满足其他的标签，则在满足硬性标签要求的机器上随机调度分配一台</p>
<p>vim pod-affinity.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-node-affinity</span><br><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        nodeSelectorTerms:</span><br><span class="line">        - matchExpressions:</span><br><span class="line">          - key: gpu</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - nvidia-tesla</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 1</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: group</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - ai</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-affinity.yaml</span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl describe pod pod-node-affinity </span><br></pre></td></tr></table></figure>
<p><img src="/images/095D6E3DA6D04C2192B2F95B272255D5clipboard.png" alt></p>
<p>验证：</p>
<p>1.如果两个节点都满足硬性标签要求，其中一个节点也满足软性标签要求，那么会优先分配到这个节点。</p>
<p>2.如果两个节点都满足硬性标签要求，都没有满足软性标签要求，那么会随机调度到其中的一个节点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#给节点添加标签的命令</span></span><br><span class="line">kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt; </span><br><span class="line">例如：kubectl label node 192.168.1.205 mem=large</span><br><span class="line"><span class="comment">#给节点删除标签的命令</span></span><br><span class="line">kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;-</span><br><span class="line">例如：kubectl label node 192.168.1.205 mem-</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Taint（污点）与Tolerations（污点容忍）">Taint（污点）与Tolerations（污点容忍）</h2>
<p>Taints：避免Pod调度到特定Node上</p>
<p>Tolerations：允许Pod调度到持有Taints的Node上</p>
<p>应用场景：</p>
<ul>
<li>
<p>专用节点：根据业务线将Node分组管理，希望在默认情况下不调度该节点，只有配置了污点容忍才允许分配</p>
</li>
<li>
<p>配备特殊硬件：部分Node配有SSD硬盘、GPU，希望在默认情况下不调度该节点，只有配置了污点容忍才允许分配</p>
</li>
<li>
<p>基于Taint的驱逐</p>
</li>
</ul>
<p>第一步：给节点添加污点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：kubectl taint node [node] key=value:[effect] </span><br><span class="line">例如：kubectl taint node k8s-node1 gpu=<span class="built_in">yes</span>:NoSchedule </span><br><span class="line">验证：kubectl describe node k8s-node1 |grep Taint</span><br></pre></td></tr></table></figure>
<p>其中[effect] 可取值：</p>
<ul>
<li>
<p>NoSchedule ：一定不能被调度</p>
</li>
<li>
<p>PreferNoSchedule：尽量不要调度，非必须配置容忍</p>
</li>
<li>
<p>NoExecute：不仅不会调度，还会驱逐Node上已有的Pod</p>
</li>
</ul>
<p>第二步：添加污点容忍（tolrations）字段到Pod配置中</p>
<p><img src="/images/6D0B55F924AC4E66A1BBBEEB2457C77Cclipboard.png" alt></p>
<p>去掉污点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node [node] key:[effect]-</span><br></pre></td></tr></table></figure>
<p>示例一</p>
<p>1.给node节点添加标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label nodes k8s-node1 gpu=iniaid</span><br><span class="line">kubectl label nodes k8s-node2 disktype=ssd</span><br><span class="line">kubectl get nodes --show-labels </span><br><span class="line">kubectl taint node |grep Taint</span><br></pre></td></tr></table></figure>
<p>2.给node1节点配置污点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node k8s-node1 gpu=iniaid:NoSchedule</span><br></pre></td></tr></table></figure>
<p>3.新建pod2.yaml文件并启动pod</p>
<p>vim pod2.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod2</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure>
<p>4.验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod2.yaml </span><br><span class="line">kubectl get pod -o wide  <span class="comment">#观察pod2是否被调度到node2节点上</span></span><br></pre></td></tr></table></figure>
<p>示例二</p>
<p>1.基于示例一，给node2节点配置污点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node k8s-node2 disktype=ssd:NoSchedule</span><br></pre></td></tr></table></figure>
<p>2.新建pod3.yaml文件并启动pod</p>
<p>vim pod3.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod3</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure>
<p>3.验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod3.yaml </span><br><span class="line">kubectl get pod   <span class="comment">#查看pod3是否处于pending状态</span></span><br><span class="line">kubectl describe pod pod3    <span class="comment">#查看pod3的状态</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/5E8FF7CD88DC4C12AF574509137E2137clipboard.png" alt></p>
<p>上面的意思是默认计划程序0/3个节点可用：1个节点有污点{disktype:ssd}，pod不能容忍，1个节点有污点{gpu:iniaid}，pod不能容忍，1个节点有污点{node}-role.kubernetes.io/主。</p>
<p>示例三</p>
<p>1.基于示例二，添加污点容忍使pod能够分配到node1节点上</p>
<p>vim pod4.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod4</span><br><span class="line">spec:</span><br><span class="line">  tolerations:                  <span class="comment">#意思是分配到标签gpu=iniaid的这个节点上</span></span><br><span class="line">  - key: <span class="string">&quot;gpu&quot;</span>                   </span><br><span class="line">    operator: <span class="string">&quot;Equal&quot;</span>           <span class="comment">#操作符等于的意思</span></span><br><span class="line">    value: <span class="string">&quot;iniaid&quot;</span></span><br><span class="line">    effect: <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加上effect: &quot;NoSchedule&quot;的意思：更精确一点，如果不加的话，比如两个节点都有gpu=iniaid这个标签，但它们的effect的调度策略不同，那么pod可能会分配到这两个节点上。</p>
<p>2.验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod4.yaml </span><br><span class="line">kubectl get pod  -o wide   <span class="comment">#验证是否被分配到node1节点上</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/982EB5703C1E487E9146B059C6435868clipboard.png" alt></p>
<p>最后去掉污点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe nodes |grep Taint   <span class="comment">#查看当前有污点的节点</span></span><br><span class="line">kubectl taint node k8s-nod2 disktype-    <span class="comment">#去掉node1节点的污点</span></span><br><span class="line">kubectl taint node k8s-node2 disktype-   <span class="comment">#去掉node2节点的污点</span></span><br><span class="line">kubectl describe nodes |grep Taint      <span class="comment">#验证是否去掉了污点</span></span><br></pre></td></tr></table></figure>
<p>验证pod3是否被调度成功</p>
<p><img src="/images/4978D9F6F11F4C1987D9EC08C3E68324clipboard.png" alt></p>
<h2 id="nodeName">nodeName</h2>
<p>nodeName：指定节点名称，用于将Pod调度到指定的Node上，不经过调度器</p>
<p>示例：将pod指定到有污点的节点上</p>
<p>vim pod5.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod5</span><br><span class="line">spec:</span><br><span class="line">  nodeName: k8s-node2</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod5.yaml </span><br><span class="line">kubectl get pod   <span class="comment">#可以看到pod成功运行，因为它不经过调度器</span></span><br></pre></td></tr></table></figure>
<p>适用于调度器故障的时候，可以手动指定分配pod到某个节点上，很少使用。</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>监控linux主机</title>
    <url>/2021/09/01/%E7%9B%91%E6%8E%A7linux%E4%B8%BB%E6%9C%BA/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一、Linux 时间同步</span><br><span class="line">1、时间同步一次：ntpdate ntp1.aliyun.com</span><br><span class="line">2、定时任务同步</span><br><span class="line">（1）crontab -e</span><br><span class="line">（2）按i 写入*/10 * * * * ntpdate ntp1.aliyun.com</span><br><span class="line">说明放入定时任务中每隔10分钟执行一次</span><br><span class="line">crontab -l 查看定时任务</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#监控Linux主机系统指标</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务端配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装prometheus（端口9000）</span></span><br><span class="line">tar -zxf prometheus-2.22.0.linux-amd64.tar.gz </span><br><span class="line"><span class="comment">#创建工作目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/monitor</span><br><span class="line"><span class="built_in">mv</span> prometheus-2.22.0.linux-amd64 /opt/monitor/prometheus</span><br><span class="line"><span class="comment">#配置为系统服务管理</span></span><br><span class="line">vi /usr/lib/systemd/system/prometheus.service</span><br><span class="line">[Unit] </span><br><span class="line">Description=prometheus</span><br><span class="line">[Service] </span><br><span class="line">ExecStart=/opt/monitor/prometheus/prometheus --config.file=/opt/monitor/prometheus/prometheus.yml </span><br><span class="line">ExecReload=/bin/kill -HUP <span class="variable">$MAINPID</span> </span><br><span class="line">KillMode=process </span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install] </span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="comment">#加载服务配置启动，开机启动</span></span><br><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl start prometheus </span><br><span class="line">systemctl <span class="built_in">enable</span> prometheus</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装grafana（端口3000）</span></span><br><span class="line">tar -zxf grafana-7.2.2.linux-amd64.tar.gz </span><br><span class="line"><span class="built_in">mv</span> grafana-7.2.2 /opt/monitor/grafana</span><br><span class="line"><span class="comment">#配置为系统服务管理</span></span><br><span class="line">vi /usr/lib/systemd/system/grafana.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=grafana</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/opt/monitor/grafana/bin/grafana-server -homepath=/opt/monitor/grafana</span><br><span class="line">ExecReload=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="comment">#加载服务配置启动，开机启动</span></span><br><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl start  grafana</span><br><span class="line">systemctl <span class="built_in">enable</span> grafana</span><br><span class="line"><span class="comment">#在Prometheus配置文件添加被监控端</span></span><br><span class="line">vim /opt/monitor/prometheus/prometheus.yml：</span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: <span class="string">&#x27;linux server&#x27;</span></span><br><span class="line">    basic_auth:</span><br><span class="line">     username: prometheus</span><br><span class="line">     password: 123.com</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [<span class="string">&#x27;192.168.0.13:9100&#x27;</span>]</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">#配置完成后，使用promtool工具检查配置文件是否有误</span></span><br><span class="line"><span class="built_in">cd</span> /opt/monitor/prometheus</span><br><span class="line">./promtool check config ./prometheus.yml </span><br><span class="line"><span class="comment">#查看prometheus的进程id,上面修改配置进行热加载配置</span></span><br><span class="line">ps -ef |grep prometheus</span><br><span class="line"><span class="built_in">kill</span> -HUP 62291 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#被监控端配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装node_exporter采集器（端口9100）</span></span><br><span class="line">tar -zxf node_exporter-1.0.1.linux-amd64.tar.gz </span><br><span class="line"><span class="built_in">mv</span> node_exporter-1.0.1.linux-amd64 /usr/local/node_exporter</span><br><span class="line"><span class="comment">#启用HTTP认证：</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/node_exporter</span><br><span class="line">vi config.yml</span><br><span class="line">basic_auth_users:</span><br><span class="line">  prometheus: $2y$12<span class="variable">$F8D</span>.zKZEh9SRCLD4D6YnK.hNRWwWJQjD5guti5N846lTDsY.ToHMq</span><br><span class="line">     用户名 ：密码</span><br><span class="line"> -----------------------------------------------------------------    </span><br><span class="line"><span class="comment">#上面密码用下面命令生成： </span></span><br><span class="line">yum install httpd-tools –y </span><br><span class="line">htpasswd -nBC 12 <span class="string">&#x27;&#x27;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;:\n&#x27;</span></span><br><span class="line"><span class="comment">#配置为系统服务管理：</span></span><br><span class="line">vi /usr/lib/systemd/system/node_exporter.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=node_exporter</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/node_exporter/node_exporter --web.config=/usr/local/node_exporter/config.yml</span><br><span class="line">ExecReload=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="comment">#加载服务配置启动，开机启动</span></span><br><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl start node_exporter </span><br><span class="line">systemctl <span class="built_in">enable</span> node_exporter</span><br><span class="line"></span><br><span class="line"><span class="comment">#监控被systemd管理的系统服务</span></span><br><span class="line"><span class="built_in">cat</span> /usr/lib/systemd/system/node_exporter.service </span><br><span class="line">[Unit]</span><br><span class="line">Description=node_exporter</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/node_exporter/node_exporter --web.config=/usr/local/node_exporter/config.yml --collector.systemd --collector.systemd.unit-whitelist=(docker|sshd|nginx).service</span><br><span class="line">ExecReload=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">--collector.systemd <span class="comment">#采集被systemd管理的服务</span></span><br><span class="line">--collector.systemd.unit-whitelist=(docker|sshd|nginx).service  <span class="comment">#采集相关的服务</span></span><br></pre></td></tr></table></figure>
<p>学习：</p>
<p><a href="https://www.cnblogs.com/chenqionghe/p/10494868.html">https://www.cnblogs.com/chenqionghe/p/10494868.html</a></p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>监控k8s</title>
    <url>/2021/09/11/%E7%9B%91%E6%8E%A7k8s/</url>
    <content><![CDATA[<p>监控k8s：</p>
<p><img src="/images/0E67C323A1F54CAC9615D0099FA32400clipboard.png" alt></p>
<p><img src="/images/F2ECA4EA019F46B2926152066C66F1E2clipboard.png" alt></p>
<p><img src="/images/3E183C2EC9594327A83D0EB1A868F084clipboard.png" alt></p>
<p><img src="/images/9D38ACAE19CD43D4ADC06A7A6FB57613clipboard.png" alt></p>
<p>prometheus----&gt;apiserver(192.168.0.13:6443 )----&gt;kubelet(cadvisor)</p>
<p>prometheus采集是通过访问k8s的统一接口aipserver这个地址获取数据的，apiserver是去请求kubelet的，而kubelet集成了cadvisor，cadvisor用于收集正在运行的容器资源使用和性能信息。</p>
<p>apiserver一般是不能被访问的，使用https协议，需要授权，那么prometheus怎么获取数据呢？就需	要在k8s上授权RBAC，授权后就会产生一个token，prometheus就是拿着这个token去访问apiserver的。</p>
<p><img src="/images/150622684DBE4BACA1FA5682B3BF854Cclipboard.png" alt></p>
<p>监控K8s集群Pod步骤：</p>
<p>k8s节点配置</p>
<p>1、K8s RBAC授权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f rbac.yaml</span><br></pre></td></tr></table></figure>
<p>2、获取Token并保存到文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get sa prometheus -n kube-system -o yaml</span><br><span class="line">kubectl describe secret prometheus-token-xxx -n kube-system</span><br><span class="line">kubectl describe secret prometheus-token-xxx -n kube-system &gt;token.k8s</span><br><span class="line">将获取的token.k8s拿到prometheus服务器上，让prometheus去拿着token访问k8s的apiserver接口</span><br><span class="line">scp token.k8s root@192.168.0.11:/opt/monitor/prometheus/</span><br><span class="line">token文件保留最后一串字符（token的值)其余不要</span><br></pre></td></tr></table></figure>
<p>prometheus配置</p>
<p>3、创建Job和kubeconfig_sd_configs</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- job_name: kubernetes-nodes-cadvisor </span><br><span class="line">  metrics_path: /metrics</span><br><span class="line">  scheme: https                <span class="comment">#apiserver接口是https协议的</span></span><br><span class="line">  kubernetes_sd_configs:       <span class="comment">#启用kubernetes服务发现机制    </span></span><br><span class="line">  - role: node                 <span class="comment">#服务发现类型角色 node:发现集群中的节点，默认地址为kubelet的HTTP端口</span></span><br><span class="line">    api_server: https://192.168.0.13:6443  </span><br><span class="line">    bearer_token_file: /opt/monitor/prometheus/token.k8s   <span class="comment">#这个是访问k8s获取node节点相关的资源</span></span><br><span class="line">    tls_config:                         </span><br><span class="line">      insecure_skip_verify: <span class="literal">true</span>                            <span class="comment">#跳过https的证书效验</span></span><br><span class="line">  bearer_token_file: /opt/monitor/prometheus/token.k8s      <span class="comment">#这个是获取采集相关的资源</span></span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件中对应自己的aipserver接口指标的地址 192.168.0.13:6443</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># kubectl get ep</span></span><br><span class="line">NAME         ENDPOINTS           AGE</span><br><span class="line">kubernetes   192.168.0.13:6443   155m</span><br></pre></td></tr></table></figure>
<p>4、Grafana导入仪表盘</p>
<p><img src="/images/3E39115E97CC46CA945ACBE36FE41231clipboard.png" alt></p>
<p>使用kubeadm部署的master节点默认是污点节点，去除污点</p>
<p>让它可以运行pod,否则该节点不会分配到pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe node |grep Taint</span><br><span class="line">kubectl taint node k8s-master node-role.kubernetes.io/master-</span><br><span class="line">kubectl describe node |grep Taint</span><br></pre></td></tr></table></figure>
<p>监控K8s资源对象状态步骤：</p>
<p>k8s节点配置</p>
<p>1.部署kube-state-metrics</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f kube-state-metrics.yaml</span><br><span class="line">访问：curl http://10.244.0.4:8081/metrics    <span class="comment">#访问到即采集到资源对象的指标</span></span><br></pre></td></tr></table></figure>
<p>prometheus配置</p>
<p>2、创建Job和kubeconfig_sd_configs</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- job_name: kubernetes-nodes-cadvisor </span><br><span class="line">  metrics_path: /metrics</span><br><span class="line">  scheme: https                <span class="comment">#apiserver接口是https协议的</span></span><br><span class="line">  kubernetes_sd_configs:       <span class="comment">#启用kubernetes服务发现机制    </span></span><br><span class="line">  - role: node                 <span class="comment">#服务发现类型角色 node:发现集群中的节点，默认地址为kubelet的HTTP端口</span></span><br><span class="line">    api_server: https://192.168.0.13:6443  </span><br><span class="line">    bearer_token_file: /opt/monitor/prometheus/token.k8s   <span class="comment">#这个是访问k8s获取node节点相关的资源</span></span><br><span class="line">    tls_config:                         </span><br><span class="line">      insecure_skip_verify: <span class="literal">true</span>                            <span class="comment">#跳过https的证书效验</span></span><br><span class="line">  bearer_token_file: /opt/monitor/prometheus/token.k8s      <span class="comment">#这个是获取采集相关的资源</span></span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件中对应自己的aipserver接口指标的地址 192.168.0.13:6443</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># kubectl get ep</span></span><br><span class="line">NAME         ENDPOINTS           AGE</span><br><span class="line">kubernetes   192.168.0.13:6443   155m</span><br></pre></td></tr></table></figure>
<p>配置完成后，prometheus如果想采集到k8s资源对象的指标，必须能够访问k8s暴露的指标，</p>
<p>也就是必须能够访问到k8s内部的pod IP，这样才能采集到。</p>
<p>添加一条能够访问到pod的路由</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route add 10.244.0.0/16 via 192.168.0.13 dev ens33</span><br><span class="line">访问：curl http://10.244.0.4:8081/metrics    <span class="comment">#访问到即采集到资源对象的指标</span></span><br></pre></td></tr></table></figure>
<p>3、Grafana导入仪表盘</p>
<p><img src="/images/CD46953D4B3E4318A5A9C3811E7A1E8Cclipboard.png" alt></p>
<p>k8s常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n kube-system</span><br><span class="line">kubectl get pod -n kube-system -o wide </span><br><span class="line">kubectl describe pod &lt;pod名&gt; -n kube-system</span><br><span class="line">kubectl create deployment web --image=nginx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>认识vue.js</title>
    <url>/2024/06/01/%E8%AE%A4%E8%AF%86vue.js/</url>
    <content><![CDATA[<h2 id="Vue介绍">Vue介绍</h2>
<p>Vue.js（简称Vue） 是一套用于构建用户界面的渐进式前端框架。</p>
<p>Vue.js 核心实现：</p>
<ul>
<li>
<p>响应式的数据绑定：当数据发生改变，视图可以自动更新，不用关心 DOM操作，而专心数据操作。</p>
</li>
<li>
<p>可组合的视图组件：把视图按照功能切分成若干基本单元，可维护，可重 用，可测试等特点。</p>
</li>
</ul>
<p>官网：<a href="https://v3.cn.vuejs.org/">https://v3.cn.vuejs.org/</a></p>
<h2 id="引入Vue">引入Vue</h2>
<p>使用Vue的四种方式：</p>
<ul>
<li>
<p>在HTML中以CDN包的形式导入</p>
</li>
<li>
<p>下载JS文件保存到本地再导入</p>
</li>
<li>
<p>使用npm安装</p>
</li>
<li>
<p>使用官方VueCli脚手架构建项目（不建议新手直接用）</p>
</li>
</ul>
<p>参考文档：<a href="https://v3.cn.vuejs.org/guide/installation.html">https://v3.cn.vuejs.org/guide/installation.html</a></p>
<p>从一个Hello World例子开始：</p>
<p><img src="/images/5697E485CBF7456196AC73ACF927AD53clipboard.png" alt></p>
<h2 id="声明式渲染">声明式渲染</h2>
<p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进DOM 的系统：</p>
<p><img src="/images/178CD64315B147FE8DFA848EE58D6A16clipboard.png" alt></p>
<p>现在数据和DOM已经被建立了关联，所有东西都是响应式的，可通过下面示例确认：</p>
<p><img src="/images/10DF204762EB4FA98E55BE5475C18BADclipboard.png" alt></p>
<h2 id="模板语法">模板语法</h2>
<p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将DOM 绑定至底层组件实例 的数据。所有Vue.js 的模板都是合法的HTML，所以能被遵循规范的浏览器和HTML 解 析器解析。</p>
<p>数据绑定最常见的形式就是使用&quot;双大括号&quot;语法在HTML中插入文本：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123;msg&#125;&#125;将被替代对应组件实例中msg属性的值。无论何时，绑定的组件实例上msg属性发 生改变，插值处内容都会更新。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>监控MySQL服务器</title>
    <url>/2021/09/02/%E7%9B%91%E6%8E%A7mysql%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#监控mysql数据库主机</span></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line"> <span class="comment">#服务端配置</span></span><br><span class="line"><span class="comment">#在Prometheus配置文件添加被监控端</span></span><br><span class="line">vim /opt/monitor/prometheus/prometheus.yml</span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: <span class="string">&#x27;dbserver&#x27;</span></span><br><span class="line">    static_configs:</span><br><span class="line">   - targets: [<span class="string">&#x27;192.168.1.11:9104&#x27;</span>]</span><br><span class="line">---------------------------------------------------</span><br><span class="line"><span class="comment">#配置完成后，使用promtool工具检查配置文件是否有误</span></span><br><span class="line"><span class="built_in">cd</span> /opt/monitor/prometheus</span><br><span class="line">./promtool check config ./prometheus.yml </span><br><span class="line"><span class="comment">#查看prometheus的进程id,上面修改配置进行热加载配置</span></span><br><span class="line">ps -ef |grep prometheus</span><br><span class="line"><span class="built_in">kill</span> -HUP 62291 </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MySQL服务器（被监控端 端口9104）</span></span><br><span class="line">mysql_exporter：用于收集MySQL性能信息。监听端口：9104</span><br><span class="line">项目地址：https://github.com/prometheus/mysqld_exporter</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行MySQL容器</span></span><br><span class="line">docker run -d --name db -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br><span class="line">docker <span class="built_in">exec</span> -it db bash</span><br><span class="line">mysql -uroot -p123456</span><br><span class="line">mysql&gt; grant PROCESS, REPLICATION CLIENT, SELECT ON *.* to <span class="string">&#x27;exporter&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装mysql_exporter采集器</span></span><br><span class="line">tar -zxf mysqld_exporter-0.12.1.linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">mv</span> mysqld_exporter-0.12.1.linux-amd64 /usr/local/mysqld_exporter</span><br><span class="line"><span class="built_in">cd</span> /usr/local/mysqld_exporter/</span><br><span class="line"><span class="comment">#指定MySQL的用户名密码</span></span><br><span class="line">vi .my.cnf</span><br><span class="line">[client] </span><br><span class="line">user=exporter      </span><br><span class="line">password=123456  </span><br><span class="line"> <span class="comment">#配置为系统服务管理：   </span></span><br><span class="line">vi /usr/lib/systemd/system/mysqld_exporter.service </span><br><span class="line">[Unit]</span><br><span class="line">Description=mysqld_exporter </span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/mysqld_exporter/mysqld_exporter --config.my-cnf=/usr/local/mysqld_exporter/.my.cnf</span><br><span class="line">ExecReload=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="comment">#加载服务配置启动，开机启动</span></span><br><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl start mysqld_exporter </span><br><span class="line">systemctl <span class="built_in">enable</span> mysqld_exporter</span><br></pre></td></tr></table></figure>
<p><img src="/images/4E21C60F7C3C444A9C689466029BE435clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>管理应用程序配置</title>
    <url>/2022/07/11/%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="ConfigMap">ConfigMap</h2>
<p>创建ConfigMap后，数据实际会存储在K8s中Etcd，然后通过创建Pod时引用该数据。</p>
<p>应用场景：应用程序配置</p>
<p>Pod使用configmap数据有两种方式：</p>
<ul>
<li>
<p>变量注入</p>
</li>
<li>
<p>数据卷挂载</p>
</li>
</ul>
<p>两种数据类型：</p>
<ul>
<li>
<p>键值</p>
</li>
<li>
<p>多行数据</p>
</li>
</ul>
<p>#解释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  <span class="comment">#pod的名字</span></span><br><span class="line">  name: configmap-demo-pod   </span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: demo</span><br><span class="line">      image: alpine</span><br><span class="line">      <span class="comment">#用进程夯筑容器不让它退出</span></span><br><span class="line">      <span class="built_in">command</span>: [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3600&quot;</span>]   </span><br><span class="line">      <span class="built_in">env</span>:</span><br><span class="line">        <span class="comment"># 定义环境变量</span></span><br><span class="line">        <span class="comment"># 请注意这里和 ConfigMap中的键名是不一样的（自定义键的名字）</span></span><br><span class="line">        - name: ABC </span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              <span class="comment"># 这个值来自 ConfigMa(comfigmap的名字)</span></span><br><span class="line">              name: configmap-demo     </span><br><span class="line">              <span class="comment"># 需要取值的键          </span></span><br><span class="line">              key: abc                       </span><br><span class="line">        - name: CDE</span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              name: configmap-demo</span><br><span class="line">              key: cde</span><br><span class="line">      volumeMounts:</span><br><span class="line">      <span class="comment">#引用下面数据卷的名字</span></span><br><span class="line">      - name: config     </span><br><span class="line">        <span class="comment">#挂载到容器中哪个目录下（一般是指你的应用程序配置文件存放目录）</span></span><br><span class="line">        mountPath: <span class="string">&quot;/config&quot;</span>            </span><br><span class="line">        readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">    <span class="comment"># 你可以在 Pod 级别设置卷，然后将其挂载到 Pod 内的容器中</span></span><br><span class="line">    - name: config     <span class="comment">#数据卷的名字</span></span><br><span class="line">      configMap:</span><br><span class="line">        <span class="comment"># 提供你想要挂载的 ConfigMap 的名字</span></span><br><span class="line">        name: configmap-demo</span><br><span class="line">        <span class="comment"># 来自 ConfigMap 的一组键，将被创建为文件</span></span><br><span class="line">        items:</span><br><span class="line">        - key: <span class="string">&quot;redis.properties&quot;</span>     </span><br><span class="line">          path: <span class="string">&quot;redis.properties&quot;</span>   <span class="comment">#挂载到/config目录下的文件名</span></span><br></pre></td></tr></table></figure>
<p>vim configmap.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: configmap-demo</span><br><span class="line">data:</span><br><span class="line">  abc: <span class="string">&quot;123&quot;</span></span><br><span class="line">  cde: <span class="string">&quot;456&quot;</span></span><br><span class="line"></span><br><span class="line">  redis.properties: |</span><br><span class="line">    port: 6379</span><br><span class="line">    host: 192.168.0.11</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim configmap-demo-pod.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: configmap-demo-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: demo</span><br><span class="line">      image: nginx</span><br><span class="line">      <span class="built_in">env</span>:</span><br><span class="line">        - name: ABC</span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              name: configmap-demo</span><br><span class="line">              key: abc</span><br><span class="line">        - name: CDE</span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              name: configmap-demo</span><br><span class="line">              key: cde</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - name: config</span><br><span class="line">        mountPath: <span class="string">&quot;/config&quot;</span></span><br><span class="line">        readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">    - name: config</span><br><span class="line">      configMap:</span><br><span class="line">        name: configmap-demo</span><br><span class="line">        items:</span><br><span class="line">        - key: <span class="string">&quot;redis.properties&quot;</span></span><br><span class="line">          path: <span class="string">&quot;redis.properties&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f configmap.yaml</span><br><span class="line">kubectl apply -f configmap-demo-pod.yaml </span><br><span class="line">kubectl get configmaps </span><br><span class="line">kubectl <span class="built_in">exec</span> -it configmap-demo-pod -- bash   <span class="comment">#进入pod中测试是否注入变量和挂载</span></span><br><span class="line"><span class="comment">#echo $ABC</span></span><br><span class="line"><span class="comment">#echo $CDE</span></span><br><span class="line"><span class="comment">#ls /config/   </span></span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://kubernetes.io/zh/docs/concepts/configuration/configmap/">https://kubernetes.io/zh/docs/concepts/configuration/configmap/</a></p>
<h2 id="Secret">Secret</h2>
<p>与ConfigMap类似，区别在于Secret主要存储敏感数据，所有的数据要经过base64编码。</p>
<p>应用场景：凭据</p>
<p>kubectl create secret 支持三种数据类型：</p>
<ul>
<li>
<p>docker-registry（<a href="http://kubernetes.io/dockerconfigjson%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF">kubernetes.io/dockerconfigjson）：存储镜像仓库认证信息</a></p>
</li>
<li>
<p>generic（Opaque）：存储密码、密钥等</p>
</li>
<li>
<p>tls（<a href="http://kubernetes.io/tls%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8TLS%E8%AF%81%E4%B9%A6">kubernetes.io/tls）：存储TLS证书</a></p>
</li>
</ul>
<p>Pod使用Secret数据与ConfigMap方式一样。</p>
<p>第一步：将用户名密码进行编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]<span class="comment"># echo -n &#x27;admin&#x27; |base64 </span></span><br><span class="line">YWRtaW4=</span><br><span class="line">[root@k8s-node1 ~]<span class="comment"># echo -n &#x27;123.com&#x27; |base64 </span></span><br><span class="line">MTIzLmNvbQ==</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二步：将编码后值放到Secret</p>
<p>vim secret.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: db-user-pass</span><br><span class="line"><span class="built_in">type</span>: Opaque</span><br><span class="line">data:</span><br><span class="line">  username: YWRtaW4=</span><br><span class="line">  password: MTIzLmNvbQ==</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim secret-demo-pod.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: secret-demo-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: demo</span><br><span class="line">    image: nginx</span><br><span class="line">    <span class="built_in">env</span>:</span><br><span class="line">    - name: USER</span><br><span class="line">      valueFrom:</span><br><span class="line">        secretKeyRef:</span><br><span class="line">          name: db-user-pass</span><br><span class="line">          key: username</span><br><span class="line">    - name: PASS</span><br><span class="line">      valueFrom:</span><br><span class="line">        secretKeyRef:</span><br><span class="line">          name: db-user-pass</span><br><span class="line">          key: password</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: config</span><br><span class="line">      mountPath: <span class="string">&quot;/config&quot;</span></span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">  - name: config</span><br><span class="line">    secret:</span><br><span class="line">      secretName: db-user-pass</span><br><span class="line">      items:</span><br><span class="line">      - key: username</span><br><span class="line">        path: my-username</span><br><span class="line">      - key: password</span><br><span class="line">        path: my-password</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f secret.yaml </span><br><span class="line">kubectl apply -f secret-demo-pod.yaml </span><br><span class="line">kubectl get secrets </span><br><span class="line">kubectl <span class="built_in">exec</span> -it secret-demo-pod -- bash     <span class="comment">#进入pod中测试是否注入变量和挂载</span></span><br><span class="line"><span class="comment">#echo $USER</span></span><br><span class="line"><span class="comment">#echo $PASS </span></span><br><span class="line"><span class="comment">#ls /config/</span></span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/">https://kubernetes.io/zh/docs/concepts/configuration/secret/</a></p>
<h2 id="应用程序如何动态更新配置">应用程序如何动态更新配置</h2>
<p>应用程序动态更新配置方案：</p>
<ul>
<li>
<p>当ConfigMap发生变更时，应用程序自动感知动态加载（需要程序自身支持）</p>
</li>
<li>
<p>触发滚动更新，即重启服务</p>
</li>
</ul>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>资源编排（YAML）</title>
    <url>/2022/06/13/%E8%B5%84%E6%BA%90%E7%BC%96%E6%8E%92/</url>
    <content><![CDATA[<h2 id="YAML文件格式说明">YAML文件格式说明</h2>
<p>K8s是一个容器编排引擎，使用YAML文件编排要部署应用，因此在学习之前，应先了解YAML语法格式：</p>
<ul>
<li>
<p>缩进表示层级关系</p>
</li>
<li>
<p>不支持制表符“tab”缩进，使用空格缩进</p>
</li>
<li>
<p>通常开头缩进 2 个空格</p>
</li>
<li>
<p>字符后缩进 1 个空格，如冒号、逗号等</p>
</li>
<li>
<p>“—” 表示YAML格式，一个文件的开始</p>
</li>
<li>
<p>“#”注释</p>
</li>
</ul>
<h2 id="YAML文件创建资源对象">YAML文件创建资源对象</h2>
<p><img src="/images/DDD11D0D0D92486CBFCC20771E6BA98Dclipboard.png" alt></p>
<p>等同于：kubectl create deployment web --image=lizhenliang/java-demo -n default</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: lizhenliang/java-demo</span><br></pre></td></tr></table></figure>
<p><img src="/images/5F75CF2C8465417682F5B254CD102040clipboard.png" alt></p>
<p>等同于：kubectl expose deployment web --port=80 --target-port=8080 --type=NodePort -n default</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector:</span><br><span class="line">    app: web</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br></pre></td></tr></table></figure>
<p>将你需要创建的资源描述到YAML文件中。</p>
<p>部署：kubectl apply -f xxx.yaml</p>
<p>卸载：kubectl delete -f xxx.yaml</p>
<p><img src="/images/049922DAA12B45238787D8DCE47434FBclipboard.png" alt></p>
<h2 id="资源字段太多，记不住怎么办">资源字段太多，记不住怎么办</h2>
<p>用create命令生成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment nginx --image=nginx:1.16 -o yaml --dry-run=client &gt; my-deploy.yaml</span><br></pre></td></tr></table></figure>
<p>用get命令导出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get deployment nginx -o yaml &gt; my-deploy.yaml</span><br></pre></td></tr></table></figure>
<p>Pod容器的字段拼写忘记了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl explain pods.spec.containers </span><br><span class="line">kubectl explain deployment</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>银河麒麟离线安装zabbix7</title>
    <url>/2024/08/26/%E9%93%B6%E6%B2%B3%E9%BA%92%E9%BA%9F%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85zabbix7/</url>
    <content><![CDATA[<h2 id="环境准备">环境准备</h2>
<p>1.操作系统版本</p>
<p><img src="/images/B037ACF189164075B825DB3ACE1C46F2clipboard.png" alt></p>
<p>2.关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>
<p>3.关闭selinux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<p>4.永久关闭selinux，修改完保存退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>
<p>5.下载安装包</p>
<p>百度网盘链接: <a href="https://pan.baidu.com/s/1nRkRKi0ifsSyGo9mPVhlNg">https://pan.baidu.com/s/1nRkRKi0ifsSyGo9mPVhlNg</a> 提取码: xc85</p>
<h2 id="yum安装依赖离线包">yum安装依赖离线包</h2>
<p>若通外网，可以直接yum在线安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install net-tools nginx pcre-devel gcc make libxml2 libxml2-devel net-snmp-devel OpenIPMI-devel libevent-devel libcurl-devel libxml2-devel libjpeg-devel libpng-devel openssl-devel libcurl-devel libxslt-devel libzip-devel wget vim unzip oniguruma-devel gd gd-devel freetype freetype-devel sqlite-devel</span><br></pre></td></tr></table></figure>
<p>1.拷贝zabbix_package.zip包到服务器root家目录</p>
<p>2.解压安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip zabbix_package.zip</span><br></pre></td></tr></table></figure>
<p>3.安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd zabbix_package</span><br><span class="line">yum localinstall *.rpm -y</span><br></pre></td></tr></table></figure>
<h2 id="安装mysql">安装mysql</h2>
<p>1.拷贝mysql-8.0.37-1.el8.x86_64.rpm-bundle.tar到服务器root家目录</p>
<p>2.解压安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xf mysql-8.0.37-1.el8.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure>
<p>3.安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-8.0.37-1.el8.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.37-1.el8.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-libs-8.0.37-1.el8.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-8.0.37-1.el8.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-icu-data-files-8.0.37-1.el8.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-devel-8.0.37-1.el8.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-8.0.37-1.el8.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>4.查看版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -V</span><br></pre></td></tr></table></figure>
<p><img src="/images/278F4A25358A4E858234AC8C2CA6F9E9clipboard.png" alt></p>
<p>5.修改配置文件并保存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加如下配置</span></span><br><span class="line">log_bin_trust_function_creators=1</span><br></pre></td></tr></table></figure>
<p><img src="/images/68B4AA2CFAAF4E1CA73ABE4EC8863E89clipboard.png" alt></p>
<p>6.启动mysql并加入开机自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld </span><br><span class="line">systemctl enable mysqld </span><br><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure>
<p><img src="/images/09FCEBF654E04E58B1D09E81A4CA77C1clipboard.png" alt></p>
<p>7.查看mysql密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/log/mysqld.log | grep root@localhost</span><br></pre></td></tr></table></figure>
<p><img src="/images/9050ABCF3DF344D3BE624A641A57D942clipboard.png" alt></p>
<p>8.登录mysql并修改密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p&#x27;6&amp;Mzk:h&gt;kgRD&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入数据库后修改密码，（Test123.com）是密码，可以自定义</span></span><br><span class="line">alter user root@localhost identified by &#x27;Test123.com&#x27;;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置完成后退出</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p><img src="/images/7E1A62D2CBCC4D01A3D1627C91C4AFA3clipboard.png" alt></p>
<h2 id="安装zabbix">安装zabbix</h2>
<p>1.拷贝zabbix-7.0.3.tar.gz到服务器root家目录</p>
<p>2.解压安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxf zabbix-7.0.3.tar.gz</span><br></pre></td></tr></table></figure>
<p>3.创建zabbix数据库并授权</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd zabbix-7.0.3</span><br><span class="line">mysql -uroot -p&#x27;Test123.com&#x27;</span><br><span class="line">create database zabbix character set utf8mb4 collate utf8mb4_bin;</span><br><span class="line">create user &#x27;zabbix&#x27;@&#x27;%&#x27; identified by &#x27;Test123.com&#x27;;</span><br><span class="line">grant all privileges on zabbix.* to &#x27;zabbix&#x27;@&#x27;%&#x27;;</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
<p><img src="/images/EBA9BCD6B990479C92BD91CCF1DE5FFDclipboard.png" alt></p>
<p>4.导入数据到数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd database/mysql</span><br><span class="line">mysql -uzabbix -pTest123.com zabbix &lt; schema.sql</span><br><span class="line">mysql -uzabbix -pTest123.com zabbix &lt; images.sql</span><br><span class="line">mysql -uzabbix -pTest123.com zabbix &lt; data.sql</span><br></pre></td></tr></table></figure>
<p><img src="/images/ADE96B075FAA41878A26E0CF8C54D554clipboard.png" alt></p>
<p>5.创建zabbix账号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd --system zabbix</span><br><span class="line">useradd --system -g zabbix -d /usr/lib/zabbix -s /sbin/nologin -c &quot;Zabbix Monitoring System&quot; zabbix</span><br></pre></td></tr></table></figure>
<p>6.创建zabbix目录并授权</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -m u=rwx,g=rwx,o= -p /usr/lib/zabbix</span><br><span class="line">chown zabbix:zabbix /usr/lib/zabbix</span><br></pre></td></tr></table></figure>
<p>7.编译安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/zabbix-7.0.3</span><br><span class="line">./configure --enable-server --enable-agent --with-mysql --enable-ipv6 --with-net-snmp --with-libcurl --with-libxml2 --with-openipmi --prefix=/usr/local/zabbix</span><br><span class="line">make install </span><br></pre></td></tr></table></figure>
<p><img src="/images/34EECB81329545B2B5677B2A695C7A1Eclipboard.png" alt></p>
<p>8.修改zabbix配置文件并保存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/zabbix/etc/zabbix_server.conf</span><br><span class="line">DBHost=192.168.7.120     #这里的IP指的是本地IP，可以通过ip a 查看</span><br><span class="line">DBPassword=Test123.com   #zabbix账号密码</span><br></pre></td></tr></table></figure>
<p><img src="/images/62757738D2794481BBC3DF8200F947FBclipboard.png" alt></p>
<p><img src="/images/864BF499B469410E8AD917DE42988B34clipboard.png" alt></p>
<p><img src="/images/48D8CCD3AD444CCF8F9C86AB6647B858clipboard.png" alt></p>
<p>9.配置zabbix-server 和zabbix-agent启动文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/zabbix-server.service</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加下面内容</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Zxbbix Server</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/zabbix/sbin/zabbix_server -f</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存并启动</span></span><br><span class="line">systemctl start zabbix-server</span><br><span class="line">systemctl enable zabbix-server</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/zabbix-agent.service</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加下面内容</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Zxbbix agent</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/zabbix/sbin/zabbix_agentd -f</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存并启动</span></span><br><span class="line">systemctl start zabbix-agent</span><br><span class="line">systemctl enable zabbix-agent</span><br></pre></td></tr></table></figure>
<h2 id="安装php">安装php</h2>
<p>1.拷贝php-8.0.1.tar.gz到服务器root家目录</p>
<p>2.解压安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxf php-8.0.1.tar.gz</span><br></pre></td></tr></table></figure>
<p>3.安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd php-8.0.1</span><br><span class="line">./configure --prefix=/usr/local/php8 --with-config-file-path=/usr/local/php8/etc --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --enable-gd --with-jpeg=/usr/local/jpeg --with-freetype=/usr/local/freetype --with-xpm=/usr/lib64 --with-zlib-dir=/usr/local/zlib --with-iconv --with-libxml --enable-xml --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-opcache --enable-mbregex --enable-fpm --enable-mbstring --enable-ftp --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --with-zip --enable-soap --without-pear --with-gettext --enable-session --with-curl --enable-ctype --enable-mysqlnd --enable-pdo --with-zlib  --with-bz2</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><img src="/images/AE28FBAEBB3E4239A6C6C6FA764DF17Fclipboard.png" alt></p>
<p>4.配置文件导入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/php8/etc</span><br><span class="line">mv php-fpm.conf.default php-fpm.conf</span><br><span class="line">mv php-fpm.d/www.conf.default php-fpm.d/www.conf</span><br><span class="line">cd /root/php-8.0.1</span><br><span class="line">cp php.ini-development /usr/local/php8/etc/php.ini</span><br></pre></td></tr></table></figure>
<p>5.修改配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/php8/etc/php.ini</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改完成后保存退出</span></span><br><span class="line">post_max_size = 16M</span><br><span class="line">max_execution_time = 300</span><br><span class="line">max_input_time = 300</span><br></pre></td></tr></table></figure>
<p><img src="/images/55B50108685D410DBFA334EE625C96F7clipboard.png" alt></p>
<p><img src="/images/8DD653BDFCFD48108584171476E46D02clipboard.png" alt></p>
<p>6.添加环境变量和软连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/php8 /usr/local/php  </span><br><span class="line"></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在末尾添加：</span></span><br><span class="line">export PHP_PATH=/usr/local/php</span><br><span class="line">export PATH=.:$PATH:$PHP_PATH/bin:$PHP_PATH/sbin</span><br></pre></td></tr></table></figure>
<p><img src="/images/EFEF1E07B6E44244BF1DF6CDFCB78647clipboard.png" alt></p>
<p>生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> source /etc/profile</span><br></pre></td></tr></table></figure>
<p>7.配置启动文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/php-fpm.service</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加下面内容</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=PHP FastCGI Process Manager</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/php8/sbin/php-fpm --nodaemonize --fpm-config /usr/local/php8/etc/php-fpm.conf</span><br><span class="line">ExecReload=/bin/kill -USR2 $MAINPID</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>启动并设置开机自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable php-fpm</span><br><span class="line">systemctl start php-fpm</span><br></pre></td></tr></table></figure>
<p>8.查看安装版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php -v</span><br></pre></td></tr></table></figure>
<p><img src="/images/7FE5E09100A6402493285E53ADDB95D8clipboard.png" alt></p>
<h2 id="配置Nginx">配置Nginx</h2>
<p>1.拷贝静态文件到nginx网站根目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/share/nginx/html/</span><br><span class="line">rm -f *   </span><br><span class="line">mkdir zabbix</span><br><span class="line">cp -a /root/zabbix-7.0.3/ui/*  /usr/share/nginx/html/zabbix</span><br></pre></td></tr></table></figure>
<p>2.修改nginx配置文件并保存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf </span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        listen       [::]:80;</span><br><span class="line">        server_name  _;</span><br><span class="line">        root         /usr/share/nginx/html/zabbix;</span><br><span class="line">        index  index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        root          /usr/share/nginx/html/zabbix;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME    /scripts$fastcgi_script_name;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/ACAEE5EBEC184FD6ADB577F2EBB8DBEAclipboard.png" alt></p>
<p>3.启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure>
<h2 id="最后访问Zabbix并配置">最后访问Zabbix并配置</h2>
<p>访问地址：<a href="http://192.168.7.120/">http://192.168.7.120/</a></p>
<p><img src="/images/3605A93393C7482D9E08AC7A66BAC3BBclipboard.png" alt></p>
<p><img src="/images/283E5C6D14FC42DC83196C04DF2E98BBclipboard.png" alt></p>
<p><img src="/images/E893A2763AA84ED78EF7D38982BE6F06clipboard.png" alt></p>
<p><img src="/images/CA278645C7334B41BF808527B0F433B3clipboard.png" alt></p>
<p><img src="/images/0FE77CB3F9564875BBE5D8D77FD9F340clipboard.png" alt></p>
<p><img src="/images/F31B96F928F04CC4A409F0C98CF676BCclipboard.png" alt></p>
<p>下载文件后拷贝到服务器的/usr/share/nginx/html/zabbix/conf 目录下</p>
<p><img src="/images/18766648D48A4E18B76F29E37577399Eclipboard.png" alt></p>
<p>刷新一下就到登录页面了</p>
<p><img src="/images/FF4C8532E1154CADA929D7BBED5E82BBclipboard.png" alt></p>
<p>默认账号：Admin，密码：zabbix</p>
<p>登录后，再按照如上配置再配置下</p>
<p><img src="/images/28EB89E60CDA4689BA17A07ABC0C066Bclipboard.png" alt></p>
<p>到这一步就算完成了， 再次登录就进入到控制台了。</p>
<p><img src="/images/512D0D75323F422C858DB9D0E0950AD0clipboard.png" alt></p>
]]></content>
      <categories>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>集成Ansible，实现发布多台Web服务器</title>
    <url>/2021/05/19/%E9%9B%86%E6%88%90ansible%E5%AE%9E%E7%8E%B0%E5%8F%91%E5%B8%83%E5%A4%9A%E5%8F%B0Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>实验环境：</p>
<table>
<thead>
<tr>
<th><br>    gitlab（4G）</th>
<th><br>  jenkins（3G）</th>
<th><br>   slave/ansible</th>
<th><br>      nginx</th>
<th><br>     tomcat</th>
<th><br>      tomcat</th>
</tr>
</thead>
<tbody>
<tr>
<td><br>192.168.1.2/24</td>
<td><br>192.168.1.3/24</td>
<td><br>192.168.1.4/24</td>
<td><br>192.168.1.5/24</td>
<td><br>192.168.1.6/24</td>
<td><br>192.168.1.7/24</td>
</tr>
</tbody>
</table>
<hr>
<p>架构原理：使用gitlab作为代码版本管理系统，jenkins作为代码持续集成测试，结合ansible实现批量部署多台web服务器，nginx作为反向代理服务器代理后端web集群。</p>
<p>自动化部署流程：</p>
<p>1.git代码拉取</p>
<p>2.编译构建</p>
<p>3.推送到远程web服务器</p>
<p>4.备份web服务器上网站根目录的程序文件</p>
<p>5.部署新的程序文件到网站根目录</p>
<p>6.重启web服务验证访问</p>
<p>部署：</p>
<ol>
<li>安装docker(gitlab服务器和jenkins服务器）</li>
</ol>
<p><a href="https://blog.csdn.net/qq_24760259/article/details/106785283">https://blog.csdn.net/qq_24760259/article/details/106785283</a></p>
<ol start="2">
<li>安装gitlab</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">###########安装配置gitlab##############</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/gitlab </span><br><span class="line">GITLAB_HOME=/opt/gitlab <span class="comment"># 数据持久化目录</span></span><br><span class="line">docker run --detach \</span><br><span class="line">--hostname gitlab.ctnrs.com \</span><br><span class="line">--publish 80:80 --publish 2222:22 \</span><br><span class="line">--name gitlab \</span><br><span class="line">--restart always \</span><br><span class="line">--volume <span class="variable">$GITLAB_HOME</span>/config:/etc/gitlab \</span><br><span class="line">--volume <span class="variable">$GITLAB_HOME</span>/logs:/var/log/gitlab \</span><br><span class="line">--volume <span class="variable">$GITLAB_HOME</span>/data:/var/opt/gitlab \</span><br><span class="line">gitlab/gitlab-ce:latest</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker exec -it gitlab bash   </span></span><br><span class="line">root@gitlab:/<span class="comment"># gitlab-ctl reconfigure   #加载配置并启动</span></span><br><span class="line"></span><br><span class="line">页面登录后新建用户---&gt;新建组---&gt;将用户加入组中（赋予作者权限）---&gt;在组中新建项目</span><br><span class="line"></span><br><span class="line"><span class="comment">#############上传java网站代码#############</span></span><br><span class="line">yum install git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/lizhenliang/tomcat-java-demo</span><br><span class="line"><span class="built_in">cd</span> tomcat-java-demo</span><br><span class="line">git init   <span class="comment">#初始化为.git的目录</span></span><br><span class="line">git remote add origin http://gitlab.ctnrs.com/group-lz/java-demo.git</span><br><span class="line"> <span class="comment">#修改为自己的仓库地址</span></span><br><span class="line"><span class="built_in">cat</span> .git/config    </span><br><span class="line">   url = http://gitlab.ctnrs.com/group-lz/java-demo.git</span><br><span class="line">   </span><br><span class="line">git add .     <span class="comment">#添加到暂存区</span></span><br><span class="line">git commit -m <span class="string">&quot;java-demo&quot;</span>    <span class="comment">#提交到本地仓库</span></span><br><span class="line">git push origin master   <span class="comment">#上传到远程仓库的master分支</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.安装jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############安装jenkins###########</span></span><br><span class="line">tar zxvf jdk-8u45-linux-x64.tar.gz</span><br><span class="line"><span class="built_in">mv</span> jdk1.8.0_45 /usr/local/jdk</span><br><span class="line">tar zxf apache-maven-3.5.0-bin.tar.gz</span><br><span class="line"><span class="built_in">mv</span> apache-maven-3.5.0 /usr/local/maven</span><br><span class="line">docker run -d --name jenkins -p 8080:8080 -p 50000:50000 -u root -v /opt/jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker -v /usr/local/maven:/usr/local/maven -v /usr/local/jdk:/usr/local/jdk -v /etc/localtime:/etc/localtime --restart=always --add-host=gitlab.ctnrs.com:192.168.0.5  --name jenkins jenkins/jenkins:lts</span><br><span class="line"><span class="comment">#########配置jdk和mvn环境##########</span></span><br><span class="line"><span class="comment"># vi /etc/profile </span></span><br><span class="line">JAVA_HOME=/usr/local/jdk </span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span>:/usr/local/jdk/bin</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME PATH </span><br><span class="line"><span class="comment"># source /etc/profile</span></span><br><span class="line"></span><br><span class="line">配置插件加速器：</span><br><span class="line">docker <span class="built_in">exec</span> -it jenkins bash</span><br><span class="line"><span class="built_in">cd</span> /var/jenkins_home/updates</span><br><span class="line">sed -i <span class="string">&#x27;s/https:\/\/updates.jenkins.io\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27;</span> default.json </span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27;</span> default.json</span><br><span class="line">jenkins访问页面非常慢的办法：</span><br><span class="line"><span class="built_in">cat</span> /opt/jenkins_home/hudson.model.UpdateCenter.xml </span><br><span class="line">修改为以下地址：</span><br><span class="line">http://mirror.xmission.com/jenkins/updates/update-center.json</span><br><span class="line"><span class="comment">#重启jenkins服务</span></span><br><span class="line">docker restart jenkins或者http://ip:8080/restart</span><br><span class="line"></span><br><span class="line">配置域名解析</span><br><span class="line"><span class="built_in">cat</span> /etc/hosts</span><br><span class="line">192.168.1.5 gitlab.ctnrs.com</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装jenkins需要的插件：</p>
<p>ansible 插件</p>
<p><img src="/images/C4E7BBE42C314399A8AD3A859602D69C%E6%8F%92%E4%BB%B6.JPG" alt></p>
<p>系统管理----&gt;节点管理----新建节点（配置slave从节点）</p>
<p><img src="/images/FC6FB3B979BE468E90B89EBC4147DB42clipboard.png" alt></p>
<p><img src="/images/48997CBE6DA04A68BD546B4193E9A51Bclipboard.png" alt></p>
<p><img src="/images/E3D8A9DA4B374D52906AACB109D7A3ACclipboard.png" alt></p>
<p>在jenkins客户端执行并创建工作目录/opt/jenkins：</p>
<p>安装Agent 1、节点安装JDK 2、下载agent.jar 3、使用nohup xxx &amp;&gt;slave.log &amp;</p>
<p>新建项目—&gt;进入到项目配置页面（配置项目）</p>
<p><img src="/images/13157DAB267F4A13AEE03E5F34E0C788clipboard.png" alt></p>
<p><img src="/images/9C2295E1CEFC489D90E59FD5890E65F2clipboard.png" alt></p>
<p><img src="/images/A2D39F63AD304318B3C3BFD77346F788clipboard.png" alt></p>
<p><img src="/images/D9725F94245A493B9AE5D4099249CBA3clipboard.png" alt></p>
<p><img src="/images/FC59AF5517BE41C5BB1BA6A85E6A0234clipboard.png" alt></p>
<p><img src="/images/8DD3DEDFC2C64D8086EA2EC110F47099clipboard.png" alt></p>
<p><img src="/images/778211F3727145E48FCA4604C9CED7E7clipboard.png" alt></p>
<p><img src="/images/94B5A36A5C1040BDB336C3C1D4E16C8Fclipboard.png" alt></p>
<p>4.在jnekins的slave上安装ansible，maven，jdk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">配置域名解析</span><br><span class="line"><span class="built_in">cat</span> /etc/hosts</span><br><span class="line">192.168.1.5 gitlab.ctnrs.com</span><br><span class="line"><span class="comment">#安装ansible</span></span><br><span class="line">yum -y install ansible</span><br><span class="line"><span class="comment">#安装git工具 (jenkins工作节点要去远程仓库拉取代码)</span></span><br><span class="line">yum -y install git </span><br><span class="line"><span class="comment">#安装jdk和maven</span></span><br><span class="line">tar zxvf jdk-8u45-linux-x64.tar.gz </span><br><span class="line"><span class="built_in">mv</span> jdk1.8.0_45 /usr/local/jdk</span><br><span class="line">tar zxf apache-maven-3.5.0-bin.tar.gz </span><br><span class="line"><span class="built_in">mv</span> apache-maven-3.5.0 /usr/local/maven</span><br><span class="line"><span class="comment">#配置环境变量</span></span><br><span class="line">vi /etc/profile </span><br><span class="line">JAVA_HOME=/usr/local/jdk </span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span>:/usr/local/maven/bin </span><br><span class="line"><span class="built_in">export</span> JAVA_HOME PATH </span><br><span class="line"><span class="comment">#加载生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置文件修改：</span></span><br><span class="line"><span class="built_in">cat</span> /etc/ansible/hosts   <span class="comment">#主机清单文件</span></span><br><span class="line">[webserver1]</span><br><span class="line">192.168.1.2</span><br><span class="line">192.168.1.5</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /etc/ansible/ansible.cfg   <span class="comment">#配置文件</span></span><br><span class="line"><span class="comment">#主机清单 inventory 文 件，就是一些需要连接的 主机</span></span><br><span class="line">inventory = /etc/ansible/hosts </span><br><span class="line"><span class="comment">#并发进程数。多少个进程 同时工作，可以根据控制 主机的性能和被管理节点 的数量来确定。</span></span><br><span class="line">forks = 5 </span><br><span class="line"><span class="comment">#提权</span></span><br><span class="line">sudo_user = root </span><br><span class="line"><span class="comment">#连接被管理服务器默认端 口</span></span><br><span class="line">remote_port = 22 </span><br><span class="line"><span class="comment">#是否检查 SSH 主机的密钥</span></span><br><span class="line">host_key_checking = False </span><br><span class="line"><span class="comment">#SSH 连接超时时间，单位 秒，可以增大值</span></span><br><span class="line"><span class="built_in">timeout</span> = 10 </span><br><span class="line"><span class="comment">#默认不记录日志，如果想 记录日志需要开启指定日 志文件，需要 ansible 用 户有写入日志权限</span></span><br><span class="line">log_path = /var/log/ansible.log </span><br><span class="line"><span class="comment">#私钥 key</span></span><br><span class="line">private_key_file = /root/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用root账户生成一对密钥</span></span><br><span class="line">ssh-keygen</span><br><span class="line">ssh-copy root@x.x.x.x  (拷贝到要部署的web服务器上实现免密登录)</span><br><span class="line"><span class="comment">#使用ansible命令测试一下</span></span><br><span class="line">ansible webserver1 -m shell -a <span class="string">&quot;ls /root&quot;</span> -u root</span><br><span class="line"><span class="comment">#在/opt/jenkins目录下新建文件playbook.yml</span></span><br><span class="line"><span class="built_in">cat</span> playbook.yml</span><br><span class="line">---</span><br><span class="line">- hosts: <span class="string">&quot;&#123;&#123;env&#125;&#125;&quot;</span></span><br><span class="line">  tasks:</span><br><span class="line">  - name: copy file </span><br><span class="line">    copy: src=/opt/jenkins/workspace/java-demo/target/ly-simple-tomcat-0.0.1-SNAPSHOT.war dest=/tmp</span><br><span class="line">  - name: deploy</span><br><span class="line">    shell: |</span><br><span class="line">      tomcat=/usr/local/tomcat</span><br><span class="line">      <span class="built_in">cd</span> <span class="variable">$tomcat</span>/webapps</span><br><span class="line">      <span class="built_in">mv</span> ROOT.war  /data/backup/$(<span class="built_in">date</span> +%F_%T)_ROOT.war </span><br><span class="line">      <span class="built_in">mv</span> /tmp/ly-simple-tomcat-0.0.1-SNAPSHOT.war <span class="variable">$tomcat</span>/webapps/ROOT.war</span><br><span class="line">      pid=$(ps -ef |grep tomcat |egrep -v <span class="string">&quot;grep|$$&quot;</span> |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">      [ -n <span class="variable">$pid</span> ] &amp;&amp; <span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">      <span class="built_in">nohup</span>  /usr/local/tomcat/bin/startup.sh </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.nginx反向代理服务器配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置nginx yum源（使用yum安装nginx)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/yum.repos.d/nginx.repo </span></span><br><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/7/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"><span class="comment">#配置nginx虚拟主机配置文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/nginx/conf.d/default.conf </span></span><br><span class="line">upstream java-demo &#123;</span><br><span class="line">	server 192.168.1.2:8080;</span><br><span class="line">	server 192.168.1.5:8080;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">	proxy_pass http://java-demo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启nginx</span></span><br><span class="line">systemctl restart nginx </span><br></pre></td></tr></table></figure>
<p>6.tomcat服务器（两台web服务器一样的配置）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装tomcat</span></span><br><span class="line">tar zxvf jdk-8u45-linux-x64.tar.gz </span><br><span class="line"><span class="built_in">mv</span> jdk1.8.0_45 /usr/local/jdk </span><br><span class="line">tar -zxf apache-tomcat-8.5.59.tar.gz </span><br><span class="line"><span class="built_in">mv</span> apache-tomcat-8.5.59 /usr/local/tomcat</span><br><span class="line"><span class="built_in">cd</span> /usr/local/tomcat/webapps/</span><br><span class="line"><span class="built_in">rm</span> -rf *</span><br><span class="line"><span class="built_in">touch</span> ROOT.war</span><br><span class="line"><span class="comment">#新建备份数据目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /data/backup -p</span><br><span class="line"><span class="comment">#配置jdk环境变量</span></span><br><span class="line">vi /etc/profile </span><br><span class="line">JAVA_HOME=/usr/local/jdk </span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span>:/usr/local/maven/bin </span><br><span class="line"><span class="built_in">export</span> JAVA_HOME PATH </span><br><span class="line"><span class="comment">#加载生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<p>访问nginx反向代理服务器</p>
<p>192.168.1.5:80</p>
<p>访问tomcat web服务器1</p>
<p>192.168.1.6:8080</p>
<p>访问tomcat web服务器2</p>
<p>192.168.1.7:8080</p>
<p>模拟提交代码验证:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改页面代码</span></span><br><span class="line">vim java-demo/src/main/resources/templates/index.ftl</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;demo&quot;</span></span><br><span class="line">git push origin master </span><br><span class="line"></span><br><span class="line">提交代码等待jenkins触发构建，验证查看页面是否变化</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>镜像的制作CMD与ENTRYPOINT区别</title>
    <url>/2022/05/24/%E9%95%9C%E5%83%8F%E7%9A%84%E5%88%B6%E4%BD%9Ccmd%E4%B8%8Eentrypoint%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>1.构建镜像时必须指定一个CMD 或者ENTRYPOINT 去夯住进程，不让它退出，放在容器前台执行，否则容器就退出了。</p>
<p>2.CMD exec 形式变量传参需要指定（“sh”,“-c”,“/usr/bin/run.sh $abc”）</p>
<p>FROM centos:7</p>
<p>LABEL maintalner liuzhe</p>
<p>COPY <a href="http://run.sh">run.sh</a> /usr/bin</p>
<p>ENV abc=azhe</p>
<p>EXPOSE 80</p>
<p>CMD [“sh”,“-c”,“/usr/bin/run.sh $abc”]</p>
<p>3.CMD shell形式直接使用变量传参</p>
<p>FROM centos:7</p>
<p>LABEL maintalner liuzhe</p>
<p>COPY <a href="http://run.sh">run.sh</a> /usr/bin</p>
<p>ENV abc=azhe</p>
<p>EXPOSE 80</p>
<p>CMD <a href="http://run.sh">run.sh</a> $abc</p>
<p>4.docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<p>docker run -d test <a href="http://run.sh">run.sh</a> liuzhe</p>
<p>通过命令行指定的形式覆盖Dockerfile 中的CMD命令</p>
<p>5.docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<p>docker run -d test <a href="http://run.sh">run.sh</a> wangwu</p>
<p>通过命令行指定的形式覆盖Dockerfile 中的ENTRYPOINT命令需要指定 --entrypoint参数</p>
<p>6.当CMD和ENTRYPOINT配合使用时，CMD的值会作为ENTRYPOINT 的默认参数</p>
<p>FROM centos:7</p>
<p>LABEL maintalner liuzhe</p>
<p>COPY <a href="http://run.sh">run.sh</a> /usr/bin</p>
<p>ENV abc=azhe</p>
<p>EXPOSE 80</p>
<p>ENTRYPOINT [“<a href="http://run.sh">run.sh</a>”]     #ENTRYPOINT执行 可执行文件  必须使用exec的形式</p>
<p>CMD [“hello”,“libai”]      #CMD的值为ENTRYPOINT传参</p>
<p>#####<a href="http://run.sh#######">run.sh#######</a></p>
<p>#!/bin/bash</p>
<p>echo $@</p>
<p>sleep 70000</p>
<p>最终执行的命令就是</p>
<p>/usr/bin/run.sh hello libai</p>
<p>docker run -d test hello liuzhe 也可以通过命令行的形式覆盖CMD命令的值</p>
<p>小结：</p>
<ol>
<li>
<p>CMD和ENTRYPOINT指令都可以用来定义运行容器时所使用的默认命令</p>
</li>
<li>
<p>Dockerfile至少指定一个CMD或ENTRYPOINT</p>
</li>
<li>
<p>CMD可以用作ENTRYPOINT默认参数，或者用作容器的默认命令</p>
</li>
<li>
<p>docker run指定<command>时，将会覆盖CMD的值</p>
</li>
<li>
<p>如果是可执行文件，希望运行时传参，应该使用ENTRYPOINT</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
